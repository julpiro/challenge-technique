{"text_full":"[DESCRIPTION]There are $$$n$$$ positive integers $$$a_1, a_2, \\dots, a_n$$$. For the one move you can choose any even value $$$c$$$ and divide by two all elements that equal $$$c$$$.For example, if $$$a=[6,8,12,6,3,12]$$$ and you choose $$$c=6$$$, and $$$a$$$ is transformed into $$$a=[3,8,12,3,3,12]$$$ after the move.You need to find the minimal number of moves for transforming $$$a$$$ to an array of only odd integers (each element shouldn't be divisible by $$$2$$$).[SOURCE CODE]a = int(input())\nfor i in range(a):\n    f = int(input())\n    k = list(map(int, input().split()))\n    l = set()\n    ch = 0\n    lol = 0\n    for i in range(len(k)):\n        lol = k[i]\n        while lol % 2 == 0:\n            l.add(lol)\n            lol \/= 2\n    print(len(l))","tags":["number theory"],"src_uid":"afcd41492158e68095b01ff1e88c3dd4"}
{"text_full":"[DESCRIPTION]In Summer Informatics School, if a student doesn't behave well, teachers make a hole in his badge. And today one of the teachers caught a group of $$$n$$$ students doing yet another trick. Let's assume that all these students are numbered from $$$1$$$ to $$$n$$$. The teacher came to student $$$a$$$ and put a hole in his badge. The student, however, claimed that the main culprit is some other student $$$p_a$$$.After that, the teacher came to student $$$p_a$$$ and made a hole in his badge as well. The student in reply said that the main culprit was student $$$p_{p_a}$$$.This process went on for a while, but, since the number of students was finite, eventually the teacher came to the student, who already had a hole in his badge.After that, the teacher put a second hole in the student's badge and decided that he is done with this process, and went to the sauna.You don't know the first student who was caught by the teacher. However, you know all the numbers $$$p_i$$$. Your task is to find out for every student $$$a$$$, who would be the student with two holes in the badge if the first caught student was $$$a$$$.[SOURCE CODE]def solve(arr, n):\n\n    ans = \"\"\n    for i in range(1, n+1):\n        holes = [0] * (n+1)\n        holes[i] = 1\n        j = i\n        while holes[j] < 2:\n            j = arr[j]\n            holes[j] += 1\n\n        ans += str(j) + \" \"\n\n    print(ans)\n\n\n# Main\ndef main():\n\n    n = int(input())\n\n    arr = list(map(int, input().split()))\n\n    arr2 = [0]\n    arr2.extend(arr)\n\n    solve(arr2, n)\n\n# end main\n\n\n# Program Start\nif __name__ == \"__main__\":\n    main()","tags":["graphs"],"src_uid":"c0abbbf1cf6c8ec11e942cdaaf01ad7c"}
{"text_full":"[DESCRIPTION]You are given a text consisting of n lines. Each line contains some space-separated words, consisting of lowercase English letters.We define a syllable as a string that contains exactly one vowel and any arbitrary number (possibly none) of consonants. In English alphabet following letters are considered to be vowels: 'a', 'e', 'i', 'o', 'u' and 'y'.Each word of the text that contains at least one vowel can be divided into syllables. Each character should be a part of exactly one syllable. For example, the word \"mamma\" can be divided into syllables as \"ma\" and \"mma\", \"mam\" and \"ma\", and \"mamm\" and \"a\". Words that consist of only consonants should be ignored.The verse patterns for the given text is a sequence of n integers p1, p2, ..., pn. Text matches the given verse pattern if for each i from 1 to n one can divide words of the i-th line in syllables in such a way that the total number of syllables is equal to pi.You are given the text and the verse pattern. Check, if the given text matches the given verse pattern.[SOURCE CODE]n=int(input())\npatterns=list(map(int,input().split()))\ntexts=[]\nfor i in range(n):\n\ttexts.append(input().split())\n\ntest=True\n\nfor i in range(n):\n\tpattern=patterns[i]\n\ttext=texts[i]\n\tvoyels=0\n\tfor ch in text:\n\t\tvoyels+=ch.count(\"a\")+ch.count(\"e\")+ch.count(\"i\")+ch.count(\"o\")+ch.count(\"u\")+ch.count(\"y\")\n\tif voyels!=pattern:\n\t\ttest=False\n\t\tbreak\n\nif test:\n\tprint(\"YES\")\nelse:\n\tprint(\"NO\")","tags":["strings"],"src_uid":"cf595689b5cbda4f1d629524ad275650"}
{"text_full":"[DESCRIPTION]Evlampiy was gifted a rooted tree. The vertices of the tree are numbered from $$$1$$$ to $$$n$$$. Each of its vertices also has an integer $$$a_i$$$ written on it. For each vertex $$$i$$$, Evlampiy calculated $$$c_i$$$ — the number of vertices $$$j$$$ in the subtree of vertex $$$i$$$, such that $$$a_j &lt; a_i$$$. Illustration for the second example, the first integer is $$$a_i$$$ and the integer in parentheses is $$$c_i$$$After the new year, Evlampiy could not remember what his gift was! He remembers the tree and the values of $$$c_i$$$, but he completely forgot which integers $$$a_i$$$ were written on the vertices.Help him to restore initial integers![SOURCE CODE]# https:\/\/codeforces.com\/contest\/1287\/problem\/D\n\ndef push(g, u, v):\n    if u not in g:\n        g[u] = []\n    g[u].append(v)    \n    \ndef build():\n    S     = [root]\n    i     = 0\n    order = {}\n    \n    while i < len(S):\n        u = S[i]\n        if u in g:\n            for v in g[u]:\n                S.append(v)\n        i+=1            \n        \n    for u in S[::-1]:\n        order[u] = []\n        flg=False\n        \n        if u not in g:\n            if cnt[u]==0:\n                order[u].append(u)\n                flg=True\n            else:\n                return False, root, order\n        else:\n            cur = 0\n            for v in g[u]:\n                for x in order[v]:\n                    if cur==cnt[u]:\n                        flg=True\n                        order[u].append(u)\n                        cur+=1    \n                    order[u].append(x)    \n                    cur+=1\n                    \n        if flg == False:\n            if cnt[u] > len(order[u]):\n                return False, root, order\n            else:\n                order[u].append(u)\n            \n    return True, root, order\n\nn    = int(input()) \ng    = {} \ncnt  = {}\n\nfor i in range(1, n+1):\n    p, c     = map(int, input().split())\n    cnt[i]   = c   \n    \n    if p==0:\n        root = i\n    else:\n        push(g, p, i)\n\nflg, root, order = build()\nif flg==False:\n    print('NO')\nelse:\n    ans = [-1] * n\n    for val, u in zip(list(range(n)), order[root]):\n        ans[u-1] = val + 1\n    print('YES')\n    print(' '.join([str(x) for x in ans]))\n    \n#5\n#0 1\n#1 3\n#2 1\n#3 0\n#2 0\n\n#3\n#2 0\n#0 2\n#2 0","tags":["graphs","trees"],"src_uid":"f097cc7057bb9a6b9fc1d2a11ee99835"}
{"text_full":"[DESCRIPTION]Vasya has got three integers $$$n$$$, $$$m$$$ and $$$k$$$. He'd like to find three integer points $$$(x_1, y_1)$$$, $$$(x_2, y_2)$$$, $$$(x_3, y_3)$$$, such that $$$0 \\le x_1, x_2, x_3 \\le n$$$, $$$0 \\le y_1, y_2, y_3 \\le m$$$ and the area of the triangle formed by these points is equal to $$$\\frac{nm}{k}$$$.Help Vasya! Find such points (if it's possible). If there are multiple solutions, print any of them.[SOURCE CODE]#Code by Sounak, IIESTS\n#------------------------------warmup----------------------------\n\nimport os\nimport sys\nimport math\nfrom io import BytesIO, IOBase\nfrom fractions import Fraction\nimport collections\nfrom itertools import permutations\nfrom collections import defaultdict\n\n\nBUFSIZE = 8192\n \n \nclass FastIO(IOBase):\n    newlines = 0\n    \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n     \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n  \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n#-------------------game starts now-----------------------------------------------------\nn,m,k=map(int,input().split())\ng=math.gcd(n*m,k)\nd=(n*m)\/\/g\nf=k\/\/g\n#print(d,f)\nif d%f!=0 and f!=2:\n    print(\"NO\")\nelse:\n    j=1\n    l=1\n    copy1,copy2=n,m\n    ch=1\n    if k%2==0:\n        k\/\/=2\n        ch=0\n    while k%2==0:\n        k\/\/=2\n        if n%2==0:\n            n\/\/=2\n        else:\n            m\/\/=2\n    for i in range (3,int(math.sqrt(k))+1,2):\n        while k%i==0:\n            k\/\/=i\n            if n%i==0:\n                n\/\/=i\n            else:\n                m\/\/=i\n    if k>2:\n        if n%k==0:\n            n\/\/=k\n        else:\n            m\/\/=k\n    if ch==1:\n        if n*2<=copy1:\n            n*=2\n        else:\n            m*=2\n    print(\"YES\")\n    print(\"0 0\")\n    print(0,m)\n    print(n,0)","tags":["number theory","geometry"],"src_uid":"5c026adda2ae3d7b707d5054bd84db3f"}
{"text_full":"[DESCRIPTION]Vivek has encountered a problem. He has a maze that can be represented as an $$$n \\times m$$$ grid. Each of the grid cells may represent the following:  Empty — '.'  Wall — '#'  Good person  — 'G'  Bad person — 'B' The only escape from the maze is at cell $$$(n, m)$$$.A person can move to a cell only if it shares a side with their current cell and does not contain a wall. Vivek wants to block some of the empty cells by replacing them with walls in such a way, that all the good people are able to escape, while none of the bad people are able to. A cell that initially contains 'G' or 'B' cannot be blocked and can be travelled through.Help him determine if there exists a way to replace some (zero or more) empty cells with walls to satisfy the above conditions.It is guaranteed that the cell $$$(n,m)$$$ is empty. Vivek can also block this cell.[SOURCE CODE]import sys\ninput = sys.stdin.buffer.readline\n\ndef main():\n\n    t = int(input())\n    for _ in range(t):\n        n, m = map(int, input().split())\n        M = [list(str(input())[2:m+2]) for _ in range(n)]\n        M = [['#']*m] + M + [['#']*m]\n        M = [['#']+c+['#'] for c in M]\n        #print(M)\n        B = []\n        G = []\n        flag1 = True\n        for i in range(1, n+1):\n            for j in range(1, m+1):\n                if M[i][j] == 'B':\n                    for di, dj in (-1, 0), (1, 0), (0, -1), (0, 1):\n                        ni, nj = i+di, j+dj\n                        if 1 <= ni <= n and 1 <= nj <= m:\n                            if M[ni][nj] == '.':\n                                M[ni][nj] = '#'\n                            if M[ni][nj] == 'G':\n                                flag1 = False\n                                break\n                    B.append((i, j))\n                if M[i][j] == 'G':\n                    G.append((i, j))\n        if not flag1:\n            print('No')\n            continue\n        if len(G) > 0 and M[n][m] == '#':\n            print('No')\n            continue\n\n        s = []\n        s.append((n, m))\n        visit = [[-1]*(m+2) for _ in range(n+2)]\n        visit[n][m] = 0\n        while s:\n            y, x = s.pop()\n            for dy, dx in (-1, 0), (1, 0), (0, -1), (0, 1):\n                ny, nx = y+dy, x+dx\n                if visit[ny][nx] == -1 and M[ny][nx] != '#':\n                    visit[ny][nx] = visit[y][x]+1\n                    s.append((ny, nx))\n        flag = True\n        for sy, sx in G:\n            if visit[sy][sx] == -1:\n                flag = False\n                break\n        #print(visit)\n        if flag:\n            print('Yes')\n        else:\n            print('No')\n\nif __name__ == '__main__':\n    main()","tags":["graphs"],"src_uid":"a5e649f4d984a5c5365ca31436ad5883"}
{"text_full":"[DESCRIPTION]Let's denote a function You are given an array a consisting of n integers. You have to calculate the sum of d(ai, aj) over all pairs (i, j) such that 1 ≤ i ≤ j ≤ n.[SOURCE CODE]n = int(input()) \na = list(map(int,input().split()))\n\ns = 0\nmx = a[0]\ndic = dict()\nfor i in range(n):\n    dic[a[i]] = 0\n\nfor i in range(n):\n    s = s - a[i]*(n-i-1) + a[i]*i\n    if a[i]-1 in dic:\n        s = s + dic[a[i]-1]*(a[i] - 1 - a[i])\n    if a[i]+1 in dic: \n        s = s + dic[a[i]+1]*(a[i] + 1 - a[i])\n    d = dic[a[i]]+1\n    t = {a[i]:d}\n    dic.update(t)\n           \nprint(s)","tags":["math"],"src_uid":"c7cca8c6524991da6ea1b423a8182d24"}
{"text_full":"[DESCRIPTION]Note that the only difference between the easy and hard version is the constraint on the number of queries. You can make hacks only if all versions of the problem are solved.This is an interactive problem.You are given a tree consisting of $$$n$$$ nodes numbered with integers from $$$1$$$ to $$$n$$$. Ayush and Ashish chose two secret distinct nodes in the tree. You need to find out both the nodes. You can make the following query:   Provide a list of nodes and you will receive a node from that list whose sum of distances to both the hidden nodes is minimal (if there are multiple such nodes in the list, you will receive any one of them). You will also get the sum of distances of that node to the hidden nodes. Recall that a tree is a connected graph without cycles. The distance between two nodes is defined as the number of edges in the simple path between them.More formally, let's define two hidden nodes as $$$s$$$ and $$$f$$$. In one query you can provide the set of nodes $$$\\{a_1, a_2, \\ldots, a_c\\}$$$ of the tree. As a result, you will get two numbers $$$a_i$$$ and $$$dist(a_i, s) + dist(a_i, f)$$$. The node $$$a_i$$$ is any node from the provided set, for which the number $$$dist(a_i, s) + dist(a_i, f)$$$ is minimal.You can ask no more than $$$14$$$ queries.[SOURCE CODE]from collections import deque\ndef NC_Dij(lis,start):\n\n    ret = [float(\"inf\")] * len(lis)\n    ret[start] = 0\n    \n    q = deque([start])\n    plis = [i for i in range(len(lis))]\n\n    while len(q) > 0:\n        now = q.popleft()\n\n        for nex in lis[now]:\n\n            if ret[nex] > ret[now] + 1:\n                ret[nex] = ret[now] + 1\n                plis[nex] = now\n                q.append(nex)\n\n    return ret,plis\n\ntt = int(input())\n\nfor loop in range(tt):\n\n    n = int(input())\n    lis = [ [] for i in range(n)]\n\n    for i in range(n-1):\n\n        v,u = map(int,input().split())\n        v -= 1\n        u -= 1\n\n        lis[v].append(u)\n        lis[u].append(v)\n\n    print (\"?\",n,*[i+1 for i in range(n)] , flush=True)\n\n    x1,d1 = map(int,input().split())\n    x1 -= 1\n\n    dlis,plis = NC_Dij(lis,x1)\n\n    r = max(dlis)+1\n    l = 0\n\n    dic = {}\n    dic[0] = x1\n\n    while r-l != 1:\n\n        m = (l+r)\/\/2\n        #print (l,r,m)\n\n        nodes = []\n        for i in range(n):\n            if dlis[i] == m:\n                nodes.append(i+1)\n        \n        print (\"?\",len(nodes), *nodes , flush=True)\n        nx,nd = map(int,input().split())\n        nx -= 1\n\n        dic[m] = nx\n        if nd == d1:\n            l = m \n        else:\n            r = m\n\n    ans1 = dic[l]\n    dlis2,plis2 = NC_Dij(lis,ans1)\n    nodes = []\n    for i in range(n):\n        if dlis2[i] == d1:\n            nodes.append(i+1)\n    print (\"?\",len(nodes), *nodes , flush=True)\n    ans2,tmp = map(int,input().split())\n\n    print (\"!\",ans1+1,ans2 , flush=True)\n\n    ret = input()","tags":["graphs","trees"],"src_uid":"28a14d68fe01c4696ab1ccb7f3932901"}
{"text_full":"[DESCRIPTION]You are a rebel leader and you are planning to start a revolution in your country. But the evil Government found out about your plans and set your punishment in the form of correctional labor.You must paint a fence which consists of $$$10^{100}$$$ planks in two colors in the following way (suppose planks are numbered from left to right from $$$0$$$):   if the index of the plank is divisible by $$$r$$$ (such planks have indices $$$0$$$, $$$r$$$, $$$2r$$$ and so on) then you must paint it red;  if the index of the plank is divisible by $$$b$$$ (such planks have indices $$$0$$$, $$$b$$$, $$$2b$$$ and so on) then you must paint it blue;  if the index is divisible both by $$$r$$$ and $$$b$$$ you can choose the color to paint the plank;  otherwise, you don't need to paint the plank at all (and it is forbidden to spent paint on it). Furthermore, the Government added one additional restriction to make your punishment worse. Let's list all painted planks of the fence in ascending order: if there are $$$k$$$ consecutive planks with the same color in this list, then the Government will state that you failed the labor and execute you immediately. If you don't paint the fence according to the four aforementioned conditions, you will also be executed.The question is: will you be able to accomplish the labor (the time is not important) or the execution is unavoidable and you need to escape at all costs.[SOURCE CODE]def gcd(a,b):\n    if(b==0):\n        return a\n    return gcd(b,a%b)\nt=int(input())\nfor _ in range(t):\n    r,b,k=map(int,input().split())\n    mini=min(r,b)\n    maxi=max(r,b)\n    gg=gcd(mini,maxi)\n    mini=mini\/\/gg\n    maxi=maxi\/\/gg\n    if((k-1)*mini+1<maxi):\n        print(\"REBEL\")\n    else:\n        print(\"OBEY\")","tags":["number theory","math"],"src_uid":"be141f316d6e5d9d8f09192913f4be47"}
{"text_full":"[DESCRIPTION]Captain Flint and his crew keep heading to a savage shore of Byteland for several months already, drinking rum and telling stories. In such moments uncle Bogdan often remembers his nephew Denis. Today, he has told a story about how Denis helped him to come up with an interesting problem and asked the crew to solve it.In the beginning, uncle Bogdan wrote on a board a positive integer $$$x$$$ consisting of $$$n$$$ digits. After that, he wiped out $$$x$$$ and wrote integer $$$k$$$ instead, which was the concatenation of binary representations of digits $$$x$$$ consists of (without leading zeroes). For example, let $$$x = 729$$$, then $$$k = 111101001$$$ (since $$$7 = 111$$$, $$$2 = 10$$$, $$$9 = 1001$$$).After some time, uncle Bogdan understood that he doesn't know what to do with $$$k$$$ and asked Denis to help. Denis decided to wipe last $$$n$$$ digits of $$$k$$$ and named the new number as $$$r$$$.As a result, Denis proposed to find such integer $$$x$$$ of length $$$n$$$ that $$$r$$$ (as number) is maximum possible. If there are multiple valid $$$x$$$ then Denis is interested in the minimum one.All crew members, including captain Flint himself, easily solved the task. All, except cabin boy Kostya, who was too drunk to think straight. But what about you?Note: in this task, we compare integers ($$$x$$$ or $$$k$$$) as numbers (despite what representations they are written in), so $$$729 &lt; 1999$$$ or $$$111 &lt; 1000$$$.[SOURCE CODE]t=int(input())\nfor i in range(t):\n    x=int(input())\n    ans=8\n    u=0\n    an=\"\" \n    n=0\n    \n    \n    if x<=4:\n        \n        for i in range(u+1,x):\n            ans+=(9)*(10**i)\n        print(ans)\n    else:\n        a=\"\"\n        q=(x-1)\/\/4\n        a+='9'*(x-q-1)\n        a+='8'*(q+1)\n       \n        print(int(a))","tags":["math"],"src_uid":"80c75a4c163c6b63a614075e094ad489"}
{"text_full":"[DESCRIPTION]Levko loves permutations very much. A permutation of length n is a sequence of distinct positive integers, each is at most n.Let’s assume that value gcd(a, b) shows the greatest common divisor of numbers a and b. Levko assumes that element pi of permutation p1, p2, ... , pn is good if gcd(i, pi) &gt; 1. Levko considers a permutation beautiful, if it has exactly k good elements. Unfortunately, he doesn’t know any beautiful permutation. Your task is to help him to find at least one of them.[SOURCE CODE]n, k = map(int, input().split())\n\nif k == n:\n    print(-1)\nelse:\n    print(*([n - k] + list(range(1, n - k)) + list(range(n - k + 1, n + 1))))","tags":["number theory","math"],"src_uid":"dc548fe1d8683b4b0ee4e0fa67638185"}
{"text_full":"[DESCRIPTION]Sherlock has a new girlfriend (so unlike him!). Valentine's day is coming and he wants to gift her some jewelry.He bought n pieces of jewelry. The i-th piece has price equal to i + 1, that is, the prices of the jewelry are 2, 3, 4, ... n + 1.Watson gave Sherlock a challenge to color these jewelry pieces such that two pieces don't have the same color if the price of one piece is a prime divisor of the price of the other piece. Also, Watson asked him to minimize the number of different colors used.Help Sherlock complete this trivial task.[SOURCE CODE]def f(n):\n    if n==2:\n        return True\n    for i in range(2,int(n**0.5)+1):\n        if n%i==0:\n            return False\n    return True\ns=int(input())\nif s>2:\n    print(2)\n    q=[1]*(s)\n    for i in range(2,s+2):\n        if f(i):\n            q[i-2]=2\n    print(' '.join([str(w)for w in q]))\nelif s==1:\n    print(1)\n    print(1)\nelse:\n    print(1)\n    print('1 1')","tags":["number theory"],"src_uid":"a99f5e08f3f560488ff979a3e9746e7f"}
{"text_full":"[DESCRIPTION]Bimokh is Mashmokh's boss. For the following n days he decided to pay to his workers in a new way. At the beginning of each day he will give each worker a certain amount of tokens. Then at the end of each day each worker can give some of his tokens back to get a certain amount of money. The worker can save the rest of tokens but he can't use it in any other day to get more money. If a worker gives back w tokens then he'll get  dollars. Mashmokh likes the tokens however he likes money more. That's why he wants to save as many tokens as possible so that the amount of money he gets is maximal possible each day. He has n numbers x1, x2, ..., xn. Number xi is the number of tokens given to each worker on the i-th day. Help him calculate for each of n days the number of tokens he can save.[SOURCE CODE]import sys\nimport string\nimport math\nfrom collections import defaultdict\nfrom functools import lru_cache\nfrom collections import Counter\n\ndef mi(s):\n    return map(int, s.strip().split())\n\ndef lmi(s):\n    return list(mi(s))\n\ndef tmi(s):\n    return tuple(mi(s))\n\ndef mf(f, s):\n    return map(f, s)\n\ndef lmf(f, s):\n    return list(mf(f, s))\n\ndef js(lst):\n    return \" \".join(str(d) for d in lst)\n\ndef line():\n    return sys.stdin.readline().strip()\n\ndef linesp():\n    return line().split()\n\ndef iline():\n    return int(line())\n\ndef dist(x, y):\n    return ((x[0] - y[0])**2 + (x[1] - y[1])**2)**0.5\n\ndef bin_search(a, b, n):\n    form = lambda x: math.floor((x\/b)*a)\n    looking = form(n)\n    hi = n\n    lo = 0\n\n    while lo <= hi:\n        if lo == hi:\n            return lo\n        elif lo == hi - 1:\n            if form(lo) == looking:\n                return lo\n            else:\n                return hi\n\n        mid = (hi + lo) \/\/ 2\n        if form(mid) < looking:\n            lo = mid\n        else:\n            hi = mid\n\ndef main(a, b, arr):\n    div = b \/ a\n\n    final = []\n    for n in arr:\n        looking = math.floor((a * n)\/b)\n        ans = math.ceil(b * (looking \/ a))\n        final.append(n - ans)\n        # final.append(n - bin_search(a, b, n))\n    print(js(final))\n\nif __name__ == \"__main__\":\n    _, a, b = mi(line())\n    arr = lmi(line())\n    main(a, b, arr)","tags":["math"],"src_uid":"3c63e2e682d3c8051c3cecc3fa9c4e8c"}
{"text_full":"[DESCRIPTION]Let $$$a$$$ be a matrix of size $$$r \\times c$$$ containing positive integers, not necessarily distinct. Rows of the matrix are numbered from $$$1$$$ to $$$r$$$, columns are numbered from $$$1$$$ to $$$c$$$. We can construct an array $$$b$$$ consisting of $$$r + c$$$ integers as follows: for each $$$i \\in [1, r]$$$, let $$$b_i$$$ be the greatest common divisor of integers in the $$$i$$$-th row, and for each $$$j \\in [1, c]$$$ let $$$b_{r+j}$$$ be the greatest common divisor of integers in the $$$j$$$-th column. We call the matrix diverse if all $$$r + c$$$ numbers $$$b_k$$$ ($$$k \\in [1, r + c]$$$) are pairwise distinct. The magnitude of a matrix equals to the maximum of $$$b_k$$$.For example, suppose we have the following matrix: $$$\\begin{pmatrix} 2 &amp; 9 &amp; 7\\\\ 4 &amp; 144 &amp; 84 \\end{pmatrix}$$$ We construct the array $$$b$$$:  $$$b_1$$$ is the greatest common divisor of $$$2$$$, $$$9$$$, and $$$7$$$, that is $$$1$$$;  $$$b_2$$$ is the greatest common divisor of $$$4$$$, $$$144$$$, and $$$84$$$, that is $$$4$$$;  $$$b_3$$$ is the greatest common divisor of $$$2$$$ and $$$4$$$, that is $$$2$$$;  $$$b_4$$$ is the greatest common divisor of $$$9$$$ and $$$144$$$, that is $$$9$$$;  $$$b_5$$$ is the greatest common divisor of $$$7$$$ and $$$84$$$, that is $$$7$$$. So $$$b = [1, 4, 2, 9, 7]$$$. All values in this array are distinct, so the matrix is diverse. The magnitude is equal to $$$9$$$.For a given $$$r$$$ and $$$c$$$, find a diverse matrix that minimises the magnitude. If there are multiple solutions, you may output any of them. If there are no solutions, output a single integer $$$0$$$.[SOURCE CODE]import sys\ndef gcd(a, b):\n    if min(a, b) == 0:\n        return max(a,b)\n    if a >= b:\n        return gcd(a % b, b)\n    elif b > a:\n        return gcd(a, b % a)\n\n\n\nn, m = list(map(int, input().split()))\nif n == 1 and m == 1:\n    print(0)\n    exit()\na = []\nif n == 1:\n    for i in range(m):\n        a.append(str(i+2))\n    print(' '.join(a))\n    exit()\nfor i in range(n):\n    a.append([0] * m)\nfor i in range(n):\n    a[i][0]= i + 2\n\nnum = n+1\nfor i in range(len(a)):\n    for j in range(1, len(a[i])):\n        a[i][j] = (a[i][0] * (num+j))\n\nfor i in range(len(a)):\n    sys.stdout.write(' '.join(list(map(str, a[i]))) + '\\n')","tags":["number theory","math"],"src_uid":"acebe5e1d927d32d65a4500d1d45c4ba"}
{"text_full":"[DESCRIPTION]The Bitlandians are quite weird people. They do everything differently. They have a different alphabet so they have a different definition for a string.A Bitlandish string is a string made only of characters \"0\" and \"1\".BitHaval (the mayor of Bitland) loves to play with Bitlandish strings. He takes some Bitlandish string a, and applies several (possibly zero) operations to it. In one operation the mayor may take any two adjacent characters of a string, define one of them as x and the other one as y. Then he calculates two values p and q: p = x xor y, q = x or y. Then he replaces one of the two taken characters by p and the other one by q.The xor operation means the bitwise excluding OR operation. The or operation is the bitwise OR operation.So for example one operation can transform string 11 to string 10 or to string 01. String 1 cannot be transformed into any other string.You've got two Bitlandish strings a and b. Your task is to check if it is possible for BitHaval to transform string a to string b in several (possibly zero) described operations.[SOURCE CODE]s1 = input()\ns2 = input()\nif len(s1) != len(s2):\n    print(\"NO\")\n    exit()\nelif len(s1) == 1:\n    if s1 != s2:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n    exit()\nelif s1 == s2:\n    print(\"YES\")\n    exit()\nif (s1.count(\"1\") != 0) and (s2.count(\"1\") != 0):\n    print(\"YES\")\nelse:\n    print(\"NO\")","tags":["math"],"src_uid":"113ae625e67c8ea5ab07be44c3b58a8f"}
{"text_full":"[DESCRIPTION]Calculate the minimum number of characters you need to change in the string s, so that it contains at least k different letters, or print that it is impossible.String s consists only of lowercase Latin letters, and it is allowed to change characters only to lowercase Latin letters too.[SOURCE CODE]s = input()\nk = int(input())\nt = frozenset(s)\nif len(s) < k:\n    print(\"impossible\")\n    exit()\nprint(max(k - len(t), 0))","tags":["strings"],"src_uid":"bd5912fe2c5c37658f28f6b159b39645"}
{"text_full":"[DESCRIPTION]You are given $$$n$$$ integers $$$a_1, a_2, \\dots, a_n$$$, where $$$n$$$ is odd. You are allowed to flip the sign of some (possibly all or none) of them. You wish to perform these flips in such a way that the following conditions hold:  At least $$$\\frac{n - 1}{2}$$$ of the adjacent differences $$$a_{i + 1} - a_i$$$ for $$$i = 1, 2, \\dots, n - 1$$$ are greater than or equal to $$$0$$$.  At least $$$\\frac{n - 1}{2}$$$ of the adjacent differences $$$a_{i + 1} - a_i$$$ for $$$i = 1, 2, \\dots, n - 1$$$ are less than or equal to $$$0$$$. Find any valid way to flip the signs. It can be shown that under the given constraints, there always exists at least one choice of signs to flip that satisfies the required condition. If there are several solutions, you can find any of them.[SOURCE CODE]for _ in range(int(input())):\n                                     \n                        t=int(input())\n                        l=[int(x) for x in input().split()]\n                        for i in range(t):\n                                         if i%2==0 and l[i]<0:                    \n                                                             l[i]=0-l[i]\n                                         elif i%2!=0 and l[i]>0:\n                                                             l[i]=0-l[i]                 \n                                         else:k=0                    \n                        print(*l)","tags":["math"],"src_uid":"d07ae42b7902ba3a49cf4463248710ea"}
{"text_full":"[DESCRIPTION]You and your friend are playing the game Mortal Kombat XI. You are trying to pass a challenge tower. There are $$$n$$$ bosses in this tower, numbered from $$$1$$$ to $$$n$$$. The type of the $$$i$$$-th boss is $$$a_i$$$. If the $$$i$$$-th boss is easy then its type is $$$a_i = 0$$$, otherwise this boss is hard and its type is $$$a_i = 1$$$.During one session, either you or your friend can kill one or two bosses (neither you nor your friend can skip the session, so the minimum number of bosses killed during one session is at least one). After your friend session, your session begins, then again your friend session begins, your session begins, and so on. The first session is your friend's session.Your friend needs to get good because he can't actually kill hard bosses. To kill them, he uses skip points. One skip point can be used to kill one hard boss.Your task is to find the minimum number of skip points your friend needs to use so you and your friend kill all $$$n$$$ bosses in the given order.For example: suppose $$$n = 8$$$, $$$a = [1, 0, 1, 1, 0, 1, 1, 1]$$$. Then the best course of action is the following:  your friend kills two first bosses, using one skip point for the first boss;  you kill the third and the fourth bosses;  your friend kills the fifth boss;  you kill the sixth and the seventh bosses;  your friend kills the last boss, using one skip point, so the tower is completed using two skip points. You have to answer $$$t$$$ independent test cases.[SOURCE CODE]for _ in range(int(input())):\n    n=int(input())\n    arr=[int(el) for el in input().split()]\n    him=[0]*(n+1)\n    us=[0]*(n+1)\n    for i in range(n-1,-1,-1):\n        him[i]=us[i+1]+arr[i]\n        if (i+2)<=n:\n            him[i]=min(him[i],us[i+2]+arr[i]+arr[i+1])\n        us[i]=him[i+1]\n        if (i+2)<=n:\n            us[i]=min(us[i],him[i+2])\n    print(him[0])","tags":["graphs"],"src_uid":"d34ffd75ef82111d1077db4b033d5195"}
{"text_full":"[DESCRIPTION]Yura is tasked to build a closed fence in shape of an arbitrary non-degenerate simple quadrilateral. He's already got three straight fence segments with known lengths $$$a$$$, $$$b$$$, and $$$c$$$. Now he needs to find out some possible integer length $$$d$$$ of the fourth straight fence segment so that he can build the fence using these four segments. In other words, the fence should have a quadrilateral shape with side lengths equal to $$$a$$$, $$$b$$$, $$$c$$$, and $$$d$$$. Help Yura, find any possible length of the fourth side.A non-degenerate simple quadrilateral is such a quadrilateral that no three of its corners lie on the same line, and it does not cross itself.[SOURCE CODE]for _ in range(int(input())):\n    num = list(map(int, input().split()))\n    q = 0\n    num.sort()\n    c = num[0]\n    a = num[1]\n    b = num[2]\n    print(int((((b - c) ** 2 + a ** 2) ** 0.5)))","tags":["geometry","math"],"src_uid":"40d679f53417ba058144c745e7a2c76d"}
{"text_full":"[DESCRIPTION]Polycarp lives on the coordinate axis $$$Ox$$$ and travels from the point $$$x=a$$$ to $$$x=b$$$. It moves uniformly rectilinearly at a speed of one unit of distance per minute.On the axis $$$Ox$$$ at the point $$$x=c$$$ the base station of the mobile operator is placed. It is known that the radius of its coverage is $$$r$$$. Thus, if Polycarp is at a distance less than or equal to $$$r$$$ from the point $$$x=c$$$, then he is in the network coverage area, otherwise — no. The base station can be located both on the route of Polycarp and outside it.Print the time in minutes during which Polycarp will not be in the coverage area of the network, with a rectilinear uniform movement from $$$x=a$$$ to $$$x=b$$$. His speed — one unit of distance per minute.[SOURCE CODE]a=int(input())\nfor i in range(a):\n    count=0\n    b=list(map(int,input().split(\" \")))\n    l=b[2]-b[3]\n    u=b[2]+b[3]\n    s=min(b[0],b[1])\n    e=max(b[0],b[1])\n    if l<=s<=e<=u:\n        count=0\n    elif l<=s<=u<=e:\n        count=e-u\n    elif s<=l<=e<=u:\n        count=l-s\n    elif s<=l<=u<=e:\n        count=e-u-s+l\n    elif l<=u<=s<=e or s<=e<=l<=u:\n        count=e-s\n    print(count)","tags":["math"],"src_uid":"783772cb7a54bf65f648d3f8b7648263"}
{"text_full":"[DESCRIPTION]Vasya has got two number: a and b. However, Vasya finds number a too short. So he decided to repeat the operation of lengthening number a n times.One operation of lengthening a number means adding exactly one digit to the number (in the decimal notation) to the right provided that the resulting number is divisible by Vasya's number b. If it is impossible to obtain the number which is divisible by b, then the lengthening operation cannot be performed.Your task is to help Vasya and print the number he can get after applying the lengthening operation to number a n times.[SOURCE CODE]'''\n260A\n\n\nVasya has got two number: a and b. However, Vasya finds number a too short. So he decided to repeat the operation of lengthening number a n times.\n\nOne operation of lengthening a number means adding exactly one digit to the number (in the decimal notation) to the right provided that the resulting number is divisible by Vasya's number b. If it is impossible to obtain the number which is divisible by b, then the lengthening operation cannot be performed.\n\nYour task is to help Vasya and print the number he can get after applying the lengthening operation to number a n times.\nInput\n\nThe first line contains three integers: a,b, n\nOutput\n\nIn a single line print the integer without leading zeros, which Vasya can get when he applies the lengthening operations to number a n times. If no such number exists, then print number -1. If there are multiple possible answers, print any of them.\n'''\n\nvalues = (input(\"\"))\nvalues = values.split(' ')\na = int(values[0])\nb = int(values[1])\nn = int(values[2])\n#print(a,b,n)\n\n''' My first answer \nwhile n>0:\n    digit = 0\n    while digit<10:\n        if (a*10+digit)%b == 0:\n            a=(a*10+digit)\n            break\n        else:\n            digit+=1\n    if digit == 10 and a%b != 0:\n        a=-1\n        break\n    else:\n        n=n-1\nprint(a)\n        '''\n            \n''' effective answer in terms of execution time '''\na=a*10+9\nif (a%b)<10: \n    print (str(a-a%b)+\"0\"*(n-1))\nelse:\n    print (-1)","tags":["math"],"src_uid":"206eb67987088843ef42923b0c3939d4"}
{"text_full":"[DESCRIPTION]John Doe started thinking about graphs. After some thought he decided that he wants to paint an undirected graph, containing exactly k cycles of length 3. A cycle of length 3 is an unordered group of three distinct graph vertices a, b and c, such that each pair of them is connected by a graph edge. John has been painting for long, but he has not been a success. Help him find such graph. Note that the number of vertices there shouldn't exceed 100, or else John will have problems painting it.[SOURCE CODE]n, k = 0, int(input())\np = [['0'] * 100 for i in range(100)]\nwhile k:\n    for i in range(n):\n        if i > k: break\n        p[n][i] = p[i][n] = '1'\n        k -= i\n    n += 1\nprint(n)\nfor i in range(n): print(''.join(p[i][:n]))","tags":["graphs"],"src_uid":"d3f4c7fedd6148c28d8780142b6594f4"}
{"text_full":"[DESCRIPTION]Lee tried so hard to make a good div.2 D problem to balance his recent contest, but it still doesn't feel good at all. Lee invented it so tediously slow that he managed to develop a phobia about div.2 D problem setting instead. And now he is hiding behind the bushes...Let's define a Rooted Dead Bush (RDB) of level $$$n$$$ as a rooted tree constructed as described below.A rooted dead bush of level $$$1$$$ is a single vertex. To construct an RDB of level $$$i$$$ we, at first, construct an RDB of level $$$i-1$$$, then for each vertex $$$u$$$:   if $$$u$$$ has no children then we will add a single child to it;  if $$$u$$$ has one child then we will add two children to it;  if $$$u$$$ has more than one child, then we will skip it.   Rooted Dead Bushes of level $$$1$$$, $$$2$$$ and $$$3$$$. Let's define a claw as a rooted tree with four vertices: one root vertex (called also as center) with three children. It looks like a claw:  The center of the claw is the vertex with label $$$1$$$. Lee has a Rooted Dead Bush of level $$$n$$$. Initially, all vertices of his RDB are green.In one move, he can choose a claw in his RDB, if all vertices in the claw are green and all vertices of the claw are children of its center, then he colors the claw's vertices in yellow.He'd like to know the maximum number of yellow vertices he can achieve. Since the answer might be very large, print it modulo $$$10^9+7$$$.[SOURCE CODE]#!\/usr\/bin\/env python\nimport os\nimport sys\nfrom io import BytesIO, IOBase\nimport threading \nfrom math import floor\nfrom bisect import bisect_right\nfrom collections import Counter\nfrom math import gcd\n\n\nmod=10**9+7\n\n\n\ndef main():\n    size=2*10**6+1\n    ans=[0]*(size)\n    a=0\n    b=0\n    for i in range(1,2*10**6+1):\n        # if i<10:\n            # print(i,a,b)\n        a,b=b,b+2*a\n        if i%3==0:\n            b+=1\n        a%=mod\n        b%=mod\n        ans[i]=b\n\n    for _ in range(int(input())):\n        # print(ans[:10])\n        n=int(input())\n        print(ans[n]*4%mod)\n\n\n\n\n\n\n        \n\n\n\n        \n\n\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\n\nif __name__ == \"__main__\":\n    main()","tags":["graphs","math","trees"],"src_uid":"43ace9254c5d879d11e3484eacb0bcc4"}
{"text_full":"[DESCRIPTION]You are given a tree consisting exactly of $$$n$$$ vertices. Tree is a connected undirected graph with $$$n-1$$$ edges. Each vertex $$$v$$$ of this tree has a value $$$a_v$$$ assigned to it.Let $$$dist(x, y)$$$ be the distance between the vertices $$$x$$$ and $$$y$$$. The distance between the vertices is the number of edges on the simple path between them.Let's define the cost of the tree as the following value: firstly, let's fix some vertex of the tree. Let it be $$$v$$$. Then the cost of the tree is $$$\\sum\\limits_{i = 1}^{n} dist(i, v) \\cdot a_i$$$.Your task is to calculate the maximum possible cost of the tree if you can choose $$$v$$$ arbitrarily.[SOURCE CODE]import sys,math\nfrom collections import defaultdict\nfrom io import BytesIO\n\nsys.stdin = BytesIO(sys.stdin.read())\nsys.setrecursionlimit(200200)\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n')\nn = int(input())\narr = [0] + [int(x) for x in input().split(' ')]\ncnts = [0] * (n+1)\nsv = set()\n\ndn = defaultdict(set)\nfor _ in range(n-1):\n    s,f = map(int, input().split(' '))\n    dn[s].add(f)\n    dn[f].add(s)\n\nvisited = [False for i in range(n+1)]\ncost = [arr[i] for i in range(n+1)]\nparent = [0 for i in range(n+1)]\nval = 0\n\ndef dfs(s, depth):\n    global val\n    stack = [(s,depth)]\n    while stack:\n        s, depth = stack[-1]\n        if visited[s]:\n            stack.pop()\n            cost[parent[s]]+=cost[s]\n            continue\n        else:    \n            visited[s] = True\n            val += depth * arr[s]\n        for i in dn[s]:\n            if not visited[i]:   \n                parent[i] = s\n                stack.append((i, depth+1))\n\ndfs(1, 0)\n\nmax_cost = val\nvisited = [False for i in range(n+1)]\ncost[0] = sum(arr)\ndef trav(s, some_val):\n    global max_cost\n    stack = [(s,some_val)]\n    while stack:\n        s, some_val = stack.pop()\n        visited[s] = True\n        if some_val>max_cost:\n            max_cost = some_val\n\n        for i in dn[s]:\n            if not visited[i]:\n                stack.append((i, some_val+(cost[0]-cost[i])-cost[i] ))\n\n\ntrav(1, val)\nprint(max_cost)","tags":["trees"],"src_uid":"0ed34310c59e3946b1c55b2618218120"}
{"text_full":"[DESCRIPTION]One way to create a task is to learn from math. You can generate some random math statement or modify some theorems to get something new and build a new task from that.For example, there is a statement called the \"Goldbach's conjecture\". It says: \"each even number no less than four can be expressed as the sum of two primes\". Let's modify it. How about a statement like that: \"each integer no less than 12 can be expressed as the sum of two composite numbers.\" Not like the Goldbach's conjecture, I can prove this theorem.You are given an integer n no less than 12, express it as a sum of two composite numbers.[SOURCE CODE]n = int(raw_input().strip())\nif n%2==0:\n  print '4 ' +str(n-4)\nelse:\n  print '9 ' +str(n-9)","tags":["number theory","math"],"src_uid":"3ea971165088fae130d866180c6c868b"}
{"text_full":"[DESCRIPTION]You are given the following points with integer coordinates on the plane: M0, A0, A1, ..., An - 1, where n is odd number. Now we define the following infinite sequence of points Mi: Mi is symmetric to Mi - 1 according  (for every natural number i). Here point B is symmetric to A according M, if M is the center of the line segment AB. Given index j find the point Mj.[SOURCE CODE]#!\/usr\/bin\/env python\n\ndef mul(a, b):\n    res = []\n    for i in range(len(b)):\n        res.append(a*b[i])\n    return tuple(res)\n\ndef add(a, b):\n    res = []\n    for i in range(len(a)):\n        res.append(a[i]+b[i])\n    return tuple(res)\n\nn, j = tuple(map(int, raw_input().split()))\n\nm0 = tuple(map(int, raw_input().split()))\na = []\nfor k in range(n):\n    a.append(tuple(map(int, raw_input().split())))\n\npar = j \/ (2*n)\nj = j % (2*n)\nsign = 1\nif par % 2 == 1:\n    sign = -1\n\ns = 1\nsum = (0, 0)\nwhile j != 0:\n    sum = add(sum, mul(2*s, a[(j-1)%n]))\n    s = -s\n    j -= 1\nsum = add(sum, mul(s, m0))\n\nprint sum[0], sum[1]","tags":["geometry","math"],"src_uid":"c19afaa6c46cd361e0e5ccee61f6f520"}
{"text_full":"[DESCRIPTION]Limak is a little bear who loves to play. Today he is playing by destroying block towers. He built n towers in a row. The i-th tower is made of hi identical blocks. For clarification see picture for the first sample.Limak will repeat the following operation till everything is destroyed.Block is called internal if it has all four neighbors, i.e. it has each side (top, left, down and right) adjacent to other block or to the floor. Otherwise, block is boundary. In one operation Limak destroys all boundary blocks. His paws are very fast and he destroys all those blocks at the same time.Limak is ready to start. You task is to count how many operations will it take him to destroy all towers.[SOURCE CODE]N = raw_input()\nN = int(N)\nh = raw_input().split(' ')\nfor i in range(len(h)):\n    h[i] = int(h[i])\nk = [0]*N\nfor i in range(len(h)):\n    if i != 0 and i != N-1:\n        k[i] = min(k[i-1] + 1, h[i])\n    else:\n        k[i] = 1\nfor i in range(len(h)):\n    if i != 0 and i != N-1:\n        k[N - i - 1] = min(k[N-i] + 1, k[N - i - 1])\n    else:\n        k[i] = 1\nprint(max(k))","tags":["math"],"src_uid":"a548737890b4bf322d0f8989e5cd25ac"}
{"text_full":"[DESCRIPTION]A recently found Ancient Prophesy is believed to contain the exact Apocalypse date. The prophesy is a string that only consists of digits and characters \"-\".We'll say that some date is mentioned in the Prophesy if there is a substring in the Prophesy that is the date's record in the format \"dd-mm-yyyy\". We'll say that the number of the date's occurrences is the number of such substrings in the Prophesy. For example, the Prophesy \"0012-10-2012-10-2012\" mentions date 12-10-2012 twice (first time as \"0012-10-2012-10-2012\", second time as \"0012-10-2012-10-2012\").The date of the Apocalypse is such correct date that the number of times it is mentioned in the Prophesy is strictly larger than that of any other correct date.A date is correct if the year lies in the range from 2013 to 2015, the month is from 1 to 12, and the number of the day is strictly more than a zero and doesn't exceed the number of days in the current month. Note that a date is written in the format \"dd-mm-yyyy\", that means that leading zeroes may be added to the numbers of the months or days if needed. In other words, date \"1-1-2013\" isn't recorded in the format \"dd-mm-yyyy\", and date \"01-01-2013\" is recorded in it.Notice, that any year between 2013 and 2015 is not a leap year.[SOURCE CODE]import re\n\ndef c(d):\n    d,m,y=map(int,d.split('-'))\n    M=set([1,3,5,7,8,10,12])\n    return y > 2012 and y< 2016 and d>0and(d<29 and m==2 or d<32 and m in M or d<30 and m in (set(range(4,13))-M))\n    \n    \nd=re.findall(\"(?=(\\d\\d-\\d\\d-\\d{4}))\", raw_input())\nr={}\nfor i in d:\n    r[i]=r.get(i,0)+c(i)\n\nprint max(r.items(), key=lambda y:y[1])[0]","tags":["strings"],"src_uid":"dd7fd84f7915ad57b0e21f416e2a3ea0"}
{"text_full":"[DESCRIPTION]Allen wants to enter a fan zone that occupies a round square and has $$$n$$$ entrances.There already is a queue of $$$a_i$$$ people in front of the $$$i$$$-th entrance. Each entrance allows one person from its queue to enter the fan zone in one minute.Allen uses the following strategy to enter the fan zone:   Initially he stands in the end of the queue in front of the first entrance.  Each minute, if he is not allowed into the fan zone during the minute (meaning he is not the first in the queue), he leaves the current queue and stands in the end of the queue of the next entrance (or the first entrance if he leaves the last entrance). Determine the entrance through which Allen will finally enter the fan zone.[SOURCE CODE]from math import ceil\ndef main():\n    n = int(input())\n    a = list(map(int,input().split()))\n    found = False\n    for i in range(n):\n        if a[i] <= i:\n            found = True\n            index = i+1\n            break\n    if not found:\n        temp = ceil(a[0]\/n)\n        index = 1\n        for i in range(1,n):\n            if ceil((a[i]-i)\/n) < temp:\n                temp = ceil((a[i]-i)\/n)\n                index = i+1\n    print(index)\n\n\n    \nif __name__ == '__main__':\n    main()","tags":["math"],"src_uid":"b18bbefd2a948da9dec1d6f27f219ed1"}
{"text_full":"[DESCRIPTION]Nian is a monster which lives deep in the oceans. Once a year, it shows up on the land, devouring livestock and even people. In order to keep the monster away, people fill their villages with red colour, light, and cracking noise, all of which frighten the monster out of coming.Little Tommy has n lanterns and Big Banban has m lanterns. Tommy's lanterns have brightness a1, a2, ..., an, and Banban's have brightness b1, b2, ..., bm respectively.Tommy intends to hide one of his lanterns, then Banban picks one of Tommy's non-hidden lanterns and one of his own lanterns to form a pair. The pair's brightness will be the product of the brightness of two lanterns.Tommy wants to make the product as small as possible, while Banban tries to make it as large as possible.You are asked to find the brightness of the chosen pair if both of them choose optimally.[SOURCE CODE]n, m = [int(x) for x in input().split()]\nlstT = [int(x) for x in input().split()]\nlstB = [int(x) for x in input().split()]\nz=-9999999999999999999999999999\nT=0\nB=0\nfor i in range(n):\n        for j in range(m):\n                if z<lstT[i]*lstB[j]:\n                        T=i\n                        B=j\n                        z=lstT[i]*lstB[j]\nlol = -99999999999999999999\nfor i in range(n):\n        for j in range(m):\n                if T!=i:\n                        lol = max(lol, lstT[i]*lstB[j])\nprint(lol)","tags":["games"],"src_uid":"c408b1d198c7c88fc635936d960c962a"}
{"text_full":"[DESCRIPTION]Kate has a set $$$S$$$ of $$$n$$$ integers $$$\\{1, \\dots, n\\} $$$. She thinks that imperfection of a subset $$$M \\subseteq S$$$ is equal to the maximum of $$$gcd(a, b)$$$ over all pairs $$$(a, b)$$$ such that both $$$a$$$ and $$$b$$$ are in $$$M$$$ and $$$a \\neq b$$$. Kate is a very neat girl and for each $$$k \\in \\{2, \\dots, n\\}$$$ she wants to find a subset that has the smallest imperfection among all subsets in $$$S$$$ of size $$$k$$$. There can be more than one subset with the smallest imperfection and the same size, but you don't need to worry about it. Kate wants to find all the subsets herself, but she needs your help to find the smallest possible imperfection for each size $$$k$$$, will name it $$$I_k$$$. Please, help Kate to find $$$I_2$$$, $$$I_3$$$, ..., $$$I_n$$$.[SOURCE CODE]def get_primes(n):\n    res = [2]\n    arr = [True] * ((n - 1) \/\/ 2)\n    i = 0\n    for i in range(len(arr)):\n        if arr[i]:\n            a = i * 2 + 3\n            res.append(a)\n            for ii in range(i + a, len(arr), a):\n                arr[ii] = False\n    \n    return res\n \nif __name__ == \"__main__\":\n    n = int(input())\n    primes = get_primes(n)\n    res = [\"1\"] * min(n - 1, len(primes))\n    left = n - 1 - len(res)\n    ii = 2\n    while left > 0:\n        for a in primes:\n            if ii * a <= n:\n                res.append(str(ii))\n                left -= 1\n            else:\n                break\n            if ii % a == 0 or left == 0:\n                break\n        ii += 1\n    print(\" \".join(res))","tags":["number theory","math"],"src_uid":"26fe98904d68cf23c5d24aa85dd92120"}
{"text_full":"[DESCRIPTION]This is an interactive problem.Ayush devised a new scheme to set the password of his lock. The lock has $$$k$$$ slots where each slot can hold integers from $$$1$$$ to $$$n$$$. The password $$$P$$$ is a sequence of $$$k$$$ integers each in the range $$$[1, n]$$$, $$$i$$$-th element of which goes into the $$$i$$$-th slot of the lock.To set the password of his lock, Ayush comes up with an array $$$A$$$ of $$$n$$$ integers each in the range $$$[1, n]$$$ (not necessarily distinct). He then picks $$$k$$$ non-empty mutually disjoint subsets of indices $$$S_1, S_2, ..., S_k$$$ $$$(S_i \\underset{i \\neq j} \\cap S_j = \\emptyset)$$$ and sets his password as $$$P_i = \\max\\limits_{j \\notin S_i} A[j]$$$. In other words, the $$$i$$$-th integer in the password is equal to the maximum over all elements of $$$A$$$ whose indices do not belong to $$$S_i$$$.You are given the subsets of indices chosen by Ayush. You need to guess the password. To make a query, you can choose a non-empty subset of indices of the array and ask the maximum of all elements of the array with index in this subset. You can ask no more than 12 queries.[SOURCE CODE]from sys import stdin,stdout\nT=int(stdin.readline().strip())\ndef query(l,r):\n    print(\"?\",end=\" \")\n    c=0\n    for i in range(l,r+1):\n        for j in s[i]:\n            c+=1\n    print(c,end=\" \")\n    for i in range(l,r+1):\n        for j in s[i]:\n            print(j,end=\" \")\n    print()\n    stdout.flush()\n    \n    x=int(stdin.readline().strip())\n    return x\n    \nfor caso in range(T):\n    n,m=map(int,stdin.readline().strip().split())\n    s=[list(map(int,stdin.readline().strip().split()))[1::] for i in range(m)]\n    l=0\n    r=m\n    aux=[]\n    for i in range(1,n+1):\n        f=False\n        for j in s:\n            if i in j:\n                f=True\n        if f==False:\n            aux.append(i)\n    s.append(aux)\n    x=query(l,r)\n    ans=[x for i in range(m+1)]\n    for i in range(10):\n        l1=l\n        r1=(l+r)\/\/2\n\n        if(l1>r1):\n            break\n        x1=query(l1,r1)\n        if x1!=x:\n            for j in range(l1,r1+1):\n                ans[j]=x\n            l=r1+1\n        else:\n            for j in range(r1+1,r+1):\n                ans[j]=x\n            r=r1\n    c=0\n    for i in range(m+1):\n        if i==l:\n            continue\n        for j in s[i]:\n            c+=1\n    print(\"?\",end=\" \")\n    print(c,end=\" \")\n    for i in range(m+1):\n        if l==i:\n            continue\n        for j in s[i]:\n            print(j,end=\" \")\n    print()\n    stdout.flush()\n    \n    x=int(stdin.readline().strip())\n    ans[l]=x\n    print(\"! \",*ans[0:m])\n    stdout.flush()\n    ans=stdin.readline().strip()\n    if ans!=\"Correct\":\n        print(\"Malll\")\n        exit(-77)","tags":["math"],"src_uid":"b0bce8524eb69b695edc1394ff86b913"}
{"text_full":"[DESCRIPTION]For a given array $$$a$$$ consisting of $$$n$$$ integers and a given integer $$$m$$$ find if it is possible to reorder elements of the array $$$a$$$ in such a way that $$$\\sum_{i=1}^{n}{\\sum_{j=i}^{n}{\\frac{a_j}{j}}}$$$ equals $$$m$$$? It is forbidden to delete elements as well as insert new elements. Please note that no rounding occurs during division, for example, $$$\\frac{5}{2}=2.5$$$.[SOURCE CODE]t = int(input())\n \nwhile t>0:\n    t = t-1\n    n,m = map(int,input().split())\n    arr = list(map(int,input().split()))\n    if (sum(arr) == m):\n        print(\"Yes\")\n    else:\n        print(\"No\")","tags":["math"],"src_uid":"941adee47c2a28588ebe7dfe16e0c91a"}
{"text_full":"[DESCRIPTION]$$$n$$$ boys and $$$m$$$ girls came to the party. Each boy presented each girl some integer number of sweets (possibly zero). All boys are numbered with integers from $$$1$$$ to $$$n$$$ and all girls are numbered with integers from $$$1$$$ to $$$m$$$. For all $$$1 \\leq i \\leq n$$$ the minimal number of sweets, which $$$i$$$-th boy presented to some girl is equal to $$$b_i$$$ and for all $$$1 \\leq j \\leq m$$$ the maximal number of sweets, which $$$j$$$-th girl received from some boy is equal to $$$g_j$$$.More formally, let $$$a_{i,j}$$$ be the number of sweets which the $$$i$$$-th boy give to the $$$j$$$-th girl. Then $$$b_i$$$ is equal exactly to the minimum among values $$$a_{i,1}, a_{i,2}, \\ldots, a_{i,m}$$$ and $$$g_j$$$ is equal exactly to the maximum among values $$$b_{1,j}, b_{2,j}, \\ldots, b_{n,j}$$$.You are interested in the minimum total number of sweets that boys could present, so you need to minimize the sum of $$$a_{i,j}$$$ for all $$$(i,j)$$$ such that $$$1 \\leq i \\leq n$$$ and $$$1 \\leq j \\leq m$$$. You are given the numbers $$$b_1, \\ldots, b_n$$$ and $$$g_1, \\ldots, g_m$$$, determine this number.[SOURCE CODE]n, m = [int(i) for i in input().split()]\n\nmins = [int(i) for i in input().split()]\nmaxs = [int(i) for i in input().split()]\n\ntemp = mins[:]\ntemp.sort()\npivot = temp[-1]\npivot2 = temp[-2]\n\nans = sum(mins)*m\nans += sum(maxs)\nans -= pivot*(m-1) + pivot2\nbad = False\n# for a in maxs:\n#     if a < pivot:\n#         bad = True\n\nq = min(maxs)\nif q < pivot:\n    print(-1)\nelif q == pivot:\n    print(ans +pivot2 - pivot)\nelse:\n    print(ans)","tags":["math"],"src_uid":"4b4c7e7d9d5c45c8635b403bae997891"}
{"text_full":"[DESCRIPTION]You are given $$$n$$$ segments on a coordinate axis $$$OX$$$. The $$$i$$$-th segment has borders $$$[l_i; r_i]$$$. All points $$$x$$$, for which $$$l_i \\le x \\le r_i$$$ holds, belong to the $$$i$$$-th segment.Your task is to choose the maximum by size (the number of segments) subset of the given set of segments such that each pair of segments in this subset either non-intersecting or one of them lies inside the other one.Two segments $$$[l_i; r_i]$$$ and $$$[l_j; r_j]$$$ are non-intersecting if they have no common points. For example, segments $$$[1; 2]$$$ and $$$[3; 4]$$$, $$$[1; 3]$$$ and $$$[5; 5]$$$ are non-intersecting, while segments $$$[1; 2]$$$ and $$$[2; 3]$$$, $$$[1; 2]$$$ and $$$[2; 2]$$$ are intersecting.The segment $$$[l_i; r_i]$$$ lies inside the segment $$$[l_j; r_j]$$$ if $$$l_j \\le l_i$$$ and $$$r_i \\le r_j$$$. For example, segments $$$[2; 2]$$$, $$$[2, 3]$$$, $$$[3; 4]$$$ and $$$[2; 4]$$$ lie inside the segment $$$[2; 4]$$$, while $$$[2; 5]$$$ and $$$[1; 4]$$$ are not.You have to answer $$$t$$$ independent test cases.[SOURCE CODE]import sys\n#sys.stdin=open(\"data.txt\")\ninput=sys.stdin.readline\n\ndef solve(seg):\n  # compress coordinates\n  co=[]\n  for a,b,_ in seg:\n    co.append(a)\n    co.append(b)\n  co=sorted(set(co))\n  d={j:i for i,j in enumerate(co)}\n  # get the best non-overlap answer\n  dp=[0]*(len(co)+1)\n  lo=0\n  for a,b,v in sorted(seg):\n    a=d[a]\n    b=d[b]+1\n    while lo<a:\n      if dp[lo+1]<dp[lo]: dp[lo+1]=dp[lo]\n      lo+=1\n    if dp[b]<dp[a]+v: dp[b]=dp[a]+v\n  #print(seg,max(dp))\n  return max(dp)\n\nfor _ in range(int(input())):\n  n=int(input())\n  seg=[]\n  for _ in range(n):\n    a,b=map(int,input().split())\n    seg.append([b-a,a,b])\n  seg.append([10**6,0,10**6])\n  seg.sort()\n  dp=[0]*(n+1)\n  allow=[]\n  for i in range(n+1):\n    # find the answer for the range [s1,s2]\n    _,s1,s2 = seg[i]\n    dp[i]=solve([(s3,s4,v) for s3,s4,v in allow if s1<=s3<=s4<=s2])+1\n    allow.append((s1,s2,dp[i]))\n  print(max(dp)-1)","tags":["graphs"],"src_uid":"0aa7c678bc06b0a305155b4a31176366"}
{"text_full":"[DESCRIPTION]This is an interactive problem.You are given a sorted in increasing order singly linked list. You should find the minimum integer in the list which is greater than or equal to x.More formally, there is a singly liked list built on an array of n elements. Element with index i contains two integers: valuei is the integer value in this element, and nexti that is the index of the next element of the singly linked list (or -1, if the current element is the last). The list is sorted, i.e. if nexti ≠  - 1, then valuenexti &gt; valuei.You are given the number of elements in the list n, the index of the first element start, and the integer x.You can make up to 2000 queries of the following two types:  ? i (1 ≤ i ≤ n) — ask the values valuei and nexti,  ! ans — give the answer for the problem: the minimum integer, greater than or equal to x, or ! -1, if there are no such integers. Your program should terminate after this query. Write a program that solves this problem.[SOURCE CODE]from random import sample\n\ndef R():\n    return map(int, input().split())\n\ndef ask(i):\n    print('?', i, flush=True)\n    v, nxt = R()\n    if v < 0:\n        exit()\n    return v, nxt\n\ndef ans(v):\n    print('!', v)\n    exit()\n\nn, s, x = R()\nmv = -1\ni = s\nS = 800\nq = range(1, n + 1)\nif n > S:\n    q = sample(q, S)\n    if s not in q:\n        q[0] = s\nfor i in q:\n    v, nxt = ask(i)\n    if v == x or i == s and v > x:\n        ans(v)\n    if v < x:\n        if nxt < 0:\n            ans(-1)\n        if v > mv:\n            mv, mnxt = v, nxt\n\nwhile mv < x and mnxt >= 1:\n    mv, mnxt = ask(mnxt)\nans(mv if mv >= x else -1)","tags":["probabilities"],"src_uid":"8aba8c09ed1b1b25fa92cdad32d6fec3"}
{"text_full":"[DESCRIPTION]The only difference between easy and hard versions is the number of elements in the array.You are given an array $$$a$$$ consisting of $$$n$$$ integers. In one move you can choose any $$$a_i$$$ and divide it by $$$2$$$ rounding down (in other words, in one move you can set $$$a_i := \\lfloor\\frac{a_i}{2}\\rfloor$$$).You can perform such an operation any (possibly, zero) number of times with any $$$a_i$$$.Your task is to calculate the minimum possible number of operations required to obtain at least $$$k$$$ equal numbers in the array.Don't forget that it is possible to have $$$a_i = 0$$$ after some operations, thus the answer always exists.[SOURCE CODE]n, k = [int(i) for i in input().split()]\ndata = [int(i) for i in input().split()]\n\ndic = [[0]*20 for j in range(200001)] \n\nfor d in data:\n    s = 0\n    while d:\n        dic[d][s] += 1\n        d >>= 1\n        s += 1\n    dic[0][s] += 1\n\nmn = 1<<30\n\nfor d in dic:\n    if sum(d) >= k:\n        left = k\n        val = 0\n        for i in range(20):\n            if d[i] >= left:\n                val += i * (left)\n                break\n            else:\n                val += i * d[i]\n                left -= d[i]\n\n        if val < mn:\n            mn = val\nprint(mn)","tags":["math"],"src_uid":"ed1a2ae733121af6486568e528fe2d84"}
{"text_full":"[DESCRIPTION]Given a sequence of integers a1, ..., an and q queries x1, ..., xq on it. For each query xi you have to count the number of pairs (l, r) such that 1 ≤ l ≤ r ≤ n and gcd(al, al + 1, ..., ar) = xi. is a greatest common divisor of v1, v2, ..., vn, that is equal to a largest positive integer that divides all vi.[SOURCE CODE]from math import gcd\nfrom collections import defaultdict\nfrom sys import stdin, stdout\n\n##This method is better cause for all the same results we only calculate once\ndef main():\n    GCD_count = defaultdict(int)\n    GCD_map = defaultdict(int)\n    arr_len = int(stdin.readline())\n    arr = [int(x) for x in stdin.readline().split()]\n    for start in range(arr_len):\n        temp = defaultdict(int)\n        GCD_count[arr[start]] += 1\n        temp[arr[start]] += 1\n        for gcd_now, occurence in GCD_map.items():\n            res = gcd(gcd_now, arr[start])\n            temp[res] += occurence\n            GCD_count[res] += occurence\n        GCD_map = temp\n    num_queries = int(stdin.readline())\n    for _ in range(num_queries):\n        print(GCD_count[int(stdin.readline())])\n\n\nmain()","tags":["math"],"src_uid":"ae7c90b00cc8393fc4db14a6aad32957"}
{"text_full":"[DESCRIPTION]In this problem you will have to help Berland army with organizing their command delivery system.There are $$$n$$$ officers in Berland army. The first officer is the commander of the army, and he does not have any superiors. Every other officer has exactly one direct superior. If officer $$$a$$$ is the direct superior of officer $$$b$$$, then we also can say that officer $$$b$$$ is a direct subordinate of officer $$$a$$$.Officer $$$x$$$ is considered to be a subordinate (direct or indirect) of officer $$$y$$$ if one of the following conditions holds:  officer $$$y$$$ is the direct superior of officer $$$x$$$;  the direct superior of officer $$$x$$$ is a subordinate of officer $$$y$$$. For example, on the picture below the subordinates of the officer $$$3$$$ are: $$$5, 6, 7, 8, 9$$$.The structure of Berland army is organized in such a way that every officer, except for the commander, is a subordinate of the commander of the army.Formally, let's represent Berland army as a tree consisting of $$$n$$$ vertices, in which vertex $$$u$$$ corresponds to officer $$$u$$$. The parent of vertex $$$u$$$ corresponds to the direct superior of officer $$$u$$$. The root (which has index $$$1$$$) corresponds to the commander of the army.Berland War Ministry has ordered you to give answers on $$$q$$$ queries, the $$$i$$$-th query is given as $$$(u_i, k_i)$$$, where $$$u_i$$$ is some officer, and $$$k_i$$$ is a positive integer.To process the $$$i$$$-th query imagine how a command from $$$u_i$$$ spreads to the subordinates of $$$u_i$$$. Typical DFS (depth first search) algorithm is used here.Suppose the current officer is $$$a$$$ and he spreads a command. Officer $$$a$$$ chooses $$$b$$$ — one of his direct subordinates (i.e. a child in the tree) who has not received this command yet. If there are many such direct subordinates, then $$$a$$$ chooses the one having minimal index. Officer $$$a$$$ gives a command to officer $$$b$$$. Afterwards, $$$b$$$ uses exactly the same algorithm to spread the command to its subtree. After $$$b$$$ finishes spreading the command, officer $$$a$$$ chooses the next direct subordinate again (using the same strategy). When officer $$$a$$$ cannot choose any direct subordinate who still hasn't received this command, officer $$$a$$$ finishes spreading the command.Let's look at the following example:  If officer $$$1$$$ spreads a command, officers receive it in the following order: $$$[1, 2, 3, 5 ,6, 8, 7, 9, 4]$$$.If officer $$$3$$$ spreads a command, officers receive it in the following order: $$$[3, 5, 6, 8, 7, 9]$$$.If officer $$$7$$$ spreads a command, officers receive it in the following order: $$$[7, 9]$$$.If officer $$$9$$$ spreads a command, officers receive it in the following order: $$$[9]$$$.To answer the $$$i$$$-th query $$$(u_i, k_i)$$$, construct a sequence which describes the order in which officers will receive the command if the $$$u_i$$$-th officer spreads it. Return the $$$k_i$$$-th element of the constructed list or -1 if there are fewer than $$$k_i$$$ elements in it.You should process queries independently. A query doesn't affect the following queries.[SOURCE CODE]n,q=map(int,input().split())\nfrom heapq import heappush as pu\nfrom heapq import heappop as po\nfrom bisect import bisect_right as br \n\ntr=[[] for i in range(n)]\nsize=[1 for i in range(n)]\n\np=list(map(int,input().split()))\np=[i-1 for i in p]\n\nfor i in range(n-1):\n\ttr[p[i]].append(i+1)\nfor i in range(n):\n\ttr[i].sort(reverse=True)\n\nh={}\nh[0]=0\ns=[0]\nm=[]\nwhile s:\n\tx=s.pop()\n\tm.append(x)\n\tfor i in tr[x]:\n\t\ts.append(i)\n\t\th[i]=h[x]+1\n\nd=[(i,h[i]) for i in range(n)]\nd.sort(key=lambda x:x[1])\nd=[i[0] for i in d]\n\nfor i in range(n-1,0,-1):\n\tsize[p[d[i]-1]]+=size[d[i]]\nind={}\nfor i in range(n):\n\tind[m[i]]=i\nfor _ in range(q):\n\tu,k=map(int,input().split())\n\tu-=1\n\tif k>size[u]:\n\t\tprint(-1)\n\telse:\n\t\ti=ind[u]\n\t\tprint(m[i+k-1]+1)","tags":["trees","graphs"],"src_uid":"4dffa25857c7719a43817e0ad01ef759"}
{"text_full":"[DESCRIPTION]As you must know, the maximum clique problem in an arbitrary graph is NP-hard. Nevertheless, for some graphs of specific kinds it can be solved effectively.Just in case, let us remind you that a clique in a non-directed graph is a subset of the vertices of a graph, such that any two vertices of this subset are connected by an edge. In particular, an empty set of vertexes and a set consisting of a single vertex, are cliques.Let's define a divisibility graph for a set of positive integers A = {a1, a2, ..., an} as follows. The vertices of the given graph are numbers from set A, and two numbers ai and aj (i ≠ j) are connected by an edge if and only if either ai is divisible by aj, or aj is divisible by ai.You are given a set of non-negative integers A. Determine the size of a maximum clique in a divisibility graph for set A.[SOURCE CODE]#!\/usr\/bin\/env python3\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\n\nclass FastO:\n    def __init__(self, fd=1):\n        stream = BytesIO()\n        self.flush = lambda: os.write(fd, stream.getvalue()) and not stream.truncate(0) and stream.seek(0)\n        self.write = lambda b: stream.write(b.encode())\n\n\nclass ostream:\n    def __lshift__(self, a):\n        sys.stdout.write(str(a))\n        return self\n\n\nsys.stdout, cout = FastO(), ostream()\n\nnumbers, num, sign = [], 0, True\nfor char in os.read(0, os.fstat(0).st_size):\n    if char >= 48:\n        num = num * 10 + char - 48\n    elif char == 45:\n        sign = False\n    elif char != 13:\n        numbers.append(num if sign else -num)\n        num, sign = 0, True\n\nif char >= 48:\n    numbers.append(num if sign else -num)\n\ngetnum = iter(numbers).__next__\n\nn = getnum()\ndp = [0] * (10**6 + 1)\nfor _ in range(n):\n    dp[getnum()] = 1\nfor i in reversed(range(10**6 + 1)):\n    dp[i] = max((dp[x] + 1 for x in range(2 * i, 10**6 + 1, i) if dp[x]), default=1) if dp[i] else 0\n\ncout << max(dp)","tags":["number theory","math"],"src_uid":"f33991da3b4a57dd6535af86edeeddc0"}
{"text_full":"[DESCRIPTION]You are given a positive integer $$$n$$$, it is guaranteed that $$$n$$$ is even (i.e. divisible by $$$2$$$).You want to construct the array $$$a$$$ of length $$$n$$$ such that:   The first $$$\\frac{n}{2}$$$ elements of $$$a$$$ are even (divisible by $$$2$$$);  the second $$$\\frac{n}{2}$$$ elements of $$$a$$$ are odd (not divisible by $$$2$$$);  all elements of $$$a$$$ are distinct and positive;  the sum of the first half equals to the sum of the second half ($$$\\sum\\limits_{i=1}^{\\frac{n}{2}} a_i = \\sum\\limits_{i=\\frac{n}{2} + 1}^{n} a_i$$$). If there are multiple answers, you can print any. It is not guaranteed that the answer exists.You have to answer $$$t$$$ independent test cases.[SOURCE CODE]lst=[]\nt = int(input())\nfor i in range(t):\n    n=int(input())\n    lst.append(n)\nfor j in lst:\n    if j%4==0:\n        lst2=[]\n        lst1 = [k for k in range(2,j+1,2)] \n        for m in range(len(lst1)-1):\n            lst2.append(lst1[m]-1)   \n        lst2.append(lst1[-1]+len(lst1)-1)\n        print('YES')\n        for f in lst1+lst2:\n            print(f,end=\" \")\n        print()\n    else:\n        print('NO')","tags":["math"],"src_uid":"0c7e019e1e955cadacca55b4e823a3e5"}
{"text_full":"[DESCRIPTION]Peter likes to travel by train. He likes it so much that on the train he falls asleep. Once in summer Peter was going by train from city A to city B, and as usual, was sleeping. Then he woke up, started to look through the window and noticed that every railway station has a flag of a particular colour.The boy started to memorize the order of the flags' colours that he had seen. But soon he fell asleep again. Unfortunately, he didn't sleep long, he woke up and went on memorizing the colours. Then he fell asleep again, and that time he slept till the end of the journey.At the station he told his parents about what he was doing, and wrote two sequences of the colours that he had seen before and after his sleep, respectively.Peter's parents know that their son likes to fantasize. They give you the list of the flags' colours at the stations that the train passes sequentially on the way from A to B, and ask you to find out if Peter could see those sequences on the way from A to B, or from B to A. Remember, please, that Peter had two periods of wakefulness.Peter's parents put lowercase Latin letters for colours. The same letter stands for the same colour, different letters — for different colours.[SOURCE CODE]\"\"\"\nPeter likes to travel by train. He likes it so much that on the train he falls asleep.\n\nOnce in summer Peter was going by train from city A to city B, and as usual, was sleeping. Then he woke up, started to look through the window and noticed that every railway station has a flag of a particular colour.\n\nThe boy started to memorize the order of the flags' colours that he had seen. But soon he fell asleep again. Unfortunately, he didn't sleep long, he woke up and went on memorizing the colours. Then he fell asleep again, and that time he slept till the end of the journey.\n\nAt the station he told his parents about what he was doing, and wrote two sequences of the colours that he had seen before and after his sleep, respectively.\n\nPeter's parents know that their son likes to fantasize. They give you the list of the flags' colours at the stations that the train passes sequentially on the way from A to B, and ask you to find out if Peter could see those sequences on the way from A to B, or from B to A. Remember, please, that Peter had two periods of wakefulness.\n\nPeter's parents put lowercase Latin letters for colours. The same letter stands for the same colour, different letters — for different colours.\n\nInput\nThe input data contains three lines. The first line contains a non-empty string, whose length does not exceed 105, the string consists of lowercase Latin letters — the flags' colours at the stations on the way from A to B. On the way from B to A the train passes the same stations, but in reverse order.\n\nThe second line contains the sequence, written by Peter during the first period of wakefulness. The third line contains the sequence, written during the second period of wakefulness. Both sequences are non-empty, consist of lowercase Latin letters, and the length of each does not exceed 100 letters. Each of the sequences is written in chronological order.\n\nOutput\nOutput one of the four words without inverted commas:\n\n«forward» — if Peter could see such sequences only on the way from A to B;\n«backward» — if Peter could see such sequences on the way from B to A;\n«both» — if Peter could see such sequences both on the way from A to B, and on the way from B to A;\n«fantasy» — if Peter could not see such sequences.\n\"\"\"\n\n\nx = input()\nx_reversed = ''.join(list(reversed(x)))\n\n# print(x)\n# print(x_reversed)\n\nseq1 = input()\nseq2 = input()\n\nif len(seq1) + len(seq2) > len(x):\n\tprint('fantasy')\nelse:\n\tforward = False\n\tbackward = False\n\n\tx_find_seq1 = x.find(seq1)\n\tif x_find_seq1 > -1:\n\t\tx_find_seq2 = x[x_find_seq1 + len(seq1):].find(seq2)\n\t\tif x_find_seq2 > -1:\n\t\t\tx_find_seq2 += x_find_seq1 + len(seq1)\n\telse:\n\t\tx_find_seq2 = -1\n\n\tx_reversed_find_seq1 = x_reversed.find(seq1)\n\tif x_reversed_find_seq1 > -1:\n\t\tx_reversed_find_seq2 = x_reversed[x_reversed_find_seq1 + len(seq1):].find(seq2)\n\t\tif x_reversed_find_seq2 > -1:\n\t\t\tx_reversed_find_seq2 += x_reversed_find_seq1 + len(seq1)\n\telse:\n\t\tx_reversed_find_seq2 = -1\n\n\t# print('x_find_seq1:', x_find_seq1)\n\t# print('x_find_seq2:', x_find_seq2)\n\n\t# print(\"--------\")\n\t# print(x_reversed)\n\t# print('x_reversed_find_seq1:', x_reversed_find_seq1)\n\t# print('x_reversed_find_seq2:', x_reversed_find_seq2)\n\n\tif (x_find_seq1 != -1 and x_find_seq1 != -1):\n\t\tif x_find_seq1 <= x_find_seq2:\n\t\t\tforward = True\n\n\tif (x_reversed_find_seq1 != -1 and x_reversed_find_seq1 != -1):\n\t\tif x_reversed_find_seq1 <= x_reversed_find_seq2:\n\t\t\tbackward = True\n\n\tif forward and backward:\n\t\tprint('both')\n\telif forward:\n\t\tprint(\"forward\")\n\telif backward:\n\t\tprint(\"backward\")\n\telse:\n\t\tprint('fantasy')\n\n\"\"\"\nx = [1,2,3,4]\nprint(x[1:])\n\n\nseq1_list = list(seq1)\nseq1_len = len(seq1)\n\nseq2_list = list(seq2)\nseq2_len = len(seq2)\n\nx_len = len(x)\n\nseq1_found = False\nfor elm, i in enumerate(x):\n\tif elm == seq1_list[0] and x_len-i >= seq1_len:\n\t\tfor j in seq2_list:\n\t\t\tif j != \n\"\"\"","tags":["strings"],"src_uid":"c3244e952830643938d51ce14f043d7d"}
{"text_full":"[DESCRIPTION]Mike has n strings s1, s2, ..., sn each consisting of lowercase English letters. In one move he can choose a string si, erase the first character and append it to the end of the string. For example, if he has the string \"coolmike\", in one move he can transform it into the string \"oolmikec\".Now Mike asks himself: what is minimal number of moves that he needs to do in order to make all the strings equal?[SOURCE CODE]def rotate(s):\n    n = len(s)\n    return s[1:] + s[0]\n\nn = int(input())\na = [input() for _ in range(n)]\n\ns = a[0]\nn = len(s)\nmin_cost = float('inf')\n\nfor _ in range(n):\n    s = rotate(s)\n    cost = 0\n    for i in a:\n        found = False\n        for _ in range(n):\n            if i == s:\n                found = True\n                break\n            cost += 1\n            i = rotate(i)\n        if not found:\n            cost = -float('inf')\n    min_cost = min(min_cost, cost)\n\nif min_cost < 0:\n    min_cost = -1\nprint(min_cost)","tags":["strings"],"src_uid":"a3a7515219ebb0154218ee3520e20d75"}
{"text_full":"[DESCRIPTION]You are given an array of $$$n$$$ integers $$$a_1,a_2,\\dots,a_n$$$.You have to create an array of $$$n$$$ integers $$$b_1,b_2,\\dots,b_n$$$ such that:   The array $$$b$$$ is a rearrangement of the array $$$a$$$, that is, it contains the same values and each value appears the same number of times in the two arrays. In other words, the multisets $$$\\{a_1,a_2,\\dots,a_n\\}$$$ and $$$\\{b_1,b_2,\\dots,b_n\\}$$$ are equal.For example, if $$$a=[1,-1,0,1]$$$, then $$$b=[-1,1,1,0]$$$ and $$$b=[0,1,-1,1]$$$ are rearrangements of $$$a$$$, but $$$b=[1,-1,-1,0]$$$ and $$$b=[1,0,2,-3]$$$ are not rearrangements of $$$a$$$.  For all $$$k=1,2,\\dots,n$$$ the sum of the first $$$k$$$ elements of $$$b$$$ is nonzero. Formally, for all $$$k=1,2,\\dots,n$$$, it must hold $$$$$$b_1+b_2+\\cdots+b_k\\not=0\\,.$$$$$$ If an array $$$b_1,b_2,\\dots, b_n$$$ with the required properties does not exist, you have to print NO.[SOURCE CODE]def all_perms(elements):\n    if len(elements) <= 1:\n        yield elements\n    else:\n        for perm in all_perms(elements[1:]):\n            for i in range(len(elements)):\n                # nb elements[0:1] works in both string and list contexts\n                yield perm[:i] + elements[0:1] + perm[i:]\n\n\ntests_no = int(input())\nfor _ in range(tests_no):\n    n = int(input())\n    a = list(map(int, input().split()))\n    whole_sum = sum(a)\n    if whole_sum == 0:\n        print(\"NO\")\n    elif whole_sum < 0:\n        ri = n-1\n        li = 0\n        b = [0]*n\n        for i in range(n):\n            if a[i] >= 0:\n                b[ri] = a[i]\n                ri -= 1\n            else:\n                b[li] = a[i]\n                li += 1\n        print(\"YES\")\n        print(*b)\n    else:\n        ri = n - 1\n        li = 0\n        b = [0] * n\n        for i in range(n):\n            if a[i] <= 0:\n                b[ri] = a[i]\n                ri -= 1\n            else:\n                b[li] = a[i]\n                li += 1\n        print(\"YES\")\n        print(*b)\n\n\n\n'''\n100\n1\n-2\n1\n-1\n1\n0\n1\n1\n1\n2\n2\n-2 -2\n2\n-1 -2\n2\n0 -2\n2\n1 -2\n2\n2 -2\n2\n-2 -1\n2\n-1 -1\n2\n0 -1\n2\n1 -1\n2\n2 -1\n2\n-2 0\n2\n-1 0\n2\n0 0\n2\n1 0\n2\n2 0\n2\n-2 1\n2\n-1 1\n2\n0 1\n2\n1 1\n\n\n\n'''","tags":["math"],"src_uid":"e57345f5757654749b411727ebb99c80"}
{"text_full":"[DESCRIPTION]Every person likes prime numbers. Alice is a person, thus she also shares the love for them. Bob wanted to give her an affectionate gift but couldn't think of anything inventive. Hence, he will be giving her a graph. How original, Bob! Alice will surely be thrilled!When building the graph, he needs four conditions to be satisfied:   It must be a simple undirected graph, i.e. without multiple (parallel) edges and self-loops.  The number of vertices must be exactly $$$n$$$ — a number he selected. This number is not necessarily prime.  The total number of edges must be prime.  The degree (i.e. the number of edges connected to the vertex) of each vertex must be prime. Below is an example for $$$n = 4$$$. The first graph (left one) is invalid as the degree of vertex $$$2$$$ (and $$$4$$$) equals to $$$1$$$, which is not prime. The second graph (middle one) is invalid as the total number of edges is $$$4$$$, which is not a prime number. The third graph (right one) is a valid answer for $$$n = 4$$$.   Note that the graph can be disconnected.Please help Bob to find any such graph![SOURCE CODE]prime = [-1]*(2001)\nfor i in range(2,2001):\n\tif prime[i]==-1:\n\t\tfor j in range(i,2001,i):\n\t\t\tprime[j] = i\nn = int(input())\ne = []\nfor i in range(n):\n\te.append((i,(i+1)%n))\nif prime[n]==n:\n\tprint (len(e))\n\tfor i in e:\n\t\tprint (i[0]+1,i[1]+1)\nelse:\n\ti = 1\n\tj = n-1\n\twhile prime[n]!=n:\n\t\te.append((i,j))\n\t\ti += 1\n\t\tj -= 1\n\t\tn += 1\n\tprint (len(e))\n\tfor i in e:\n\t\tprint (i[0]+1,i[1]+1)","tags":["number theory","math"],"src_uid":"17d29a0c2ab4e4be14fe3bdeb10d1e55"}
{"text_full":"[DESCRIPTION]There were n groups of students which came to write a training contest. A group is either one person who can write the contest with anyone else, or two people who want to write the contest in the same team.The coach decided to form teams of exactly three people for this training. Determine the maximum number of teams of three people he can form. It is possible that he can't use all groups to form teams. For groups of two, either both students should write the contest, or both should not. If two students from a group of two will write the contest, they should be in the same team.[SOURCE CODE]n=int(input())\nl=list(map(int,input().split()))\nx=l.count(2)\ny=l.count(1)\nm=min(x,y)\nc=(y-m)\/\/3\nprint(c+m)","tags":["math"],"src_uid":"6c9cbe714f8f594654ebc59b6059b30a"}
{"text_full":"[DESCRIPTION]Catherine received an array of integers as a gift for March 8. Eventually she grew bored with it, and she started calculated various useless characteristics for it. She succeeded to do it for each one she came up with. But when she came up with another one — xor of all pairwise sums of elements in the array, she realized that she couldn't compute it for a very large array, thus she asked for your help. Can you do it? Formally, you need to compute$$$$$$ (a_1 + a_2) \\oplus (a_1 + a_3) \\oplus \\ldots \\oplus (a_1 + a_n) \\\\ \\oplus (a_2 + a_3) \\oplus \\ldots \\oplus (a_2 + a_n) \\\\ \\ldots \\\\ \\oplus (a_{n-1} + a_n) \\\\ $$$$$$Here $$$x \\oplus y$$$ is a bitwise XOR operation (i.e. $$$x$$$ ^ $$$y$$$ in many modern programming languages). You can read about it in Wikipedia: https:\/\/en.wikipedia.org\/wiki\/Exclusive_or#Bitwise_operation.[SOURCE CODE]import io\nimport os\n\nfrom collections import deque, defaultdict, Counter\n\nfrom bisect import bisect_left, bisect_right\n\n\nDEBUG = False\n\n\ndef solveBrute(N, A):\n    ans = 0\n    for i in range(N):\n        for j in range(i + 1, N):\n            ans ^= A[i] + A[j]\n    return ans\n\n\ndef solve(N, A):\n    B = max(A).bit_length()\n    ans = 0\n    for k in range(B + 1):\n        # Count number of pairs with kth bit on (0 indexed)\n        # For example if k==2, want pairs where lower 3 bits are between 100 and 111 inclusive\n        # If we mask A to the lower 3 bits, we can find all pairs that sum to either 100 to 111 or overflowed to 1100 to 1111\n\n        MOD = 1 << (k + 1)\n        MASK = MOD - 1\n\n        # Sort by x & MASK incrementally\n        left = []\n        right = []\n        for x in A:\n            if (x >> k) & 1:\n                right.append(x)\n            else:\n                left.append(x)\n        A = left + right\n        arr = [x & MASK for x in A]\n        if DEBUG:\n            assert arr == sorted(arr)\n\n        numPairs = 0\n        tLo = 1 << k\n        tHi = (1 << (k + 1)) - 1\n\n        for targetLo, targetHi in [(tLo, tHi), (MOD + tLo, MOD + tHi)]:\n            # Want to binary search for y such that targetLo <= x + y <= targetHi\n            # But this TLE so walk the lo\/hi pointers instead\n            lo = N\n            hi = N\n            for i, x in enumerate(arr):\n                lo = max(lo, i + 1)\n                hi = max(hi, lo)\n                while lo - 1 >= i + 1 and arr[lo - 1] >= targetLo - x:\n                    lo -= 1\n                while hi - 1 >= lo and arr[hi - 1] > targetHi - x:\n                    hi -= 1\n                numPairs += hi - lo\n\n                if DEBUG:\n                    # Check\n                    assert lo == bisect_left(arr, targetLo - x, i + 1)\n                    assert hi == bisect_right(arr, targetHi - x, lo)\n                    for j, y in enumerate(arr):\n                        cond = i < j and targetLo <= x + y <= targetHi\n                        if lo <= j < hi:\n                            assert cond\n                        else:\n                            assert not cond\n\n        ans += (numPairs % 2) << k\n\n    return ans\n\n\nif DEBUG:\n    import random\n\n    random.seed(0)\n    for i in range(100):\n        A = [random.randint(1, 1000) for i in range(100)]\n        N = len(A)\n        ans1 = solveBrute(N, A)\n        ans2 = solve(N, A)\n        print(A, bin(ans1), bin(ans2))\n        assert ans1 == ans2\nelse:\n    if False:\n        # Timing\n        import random\n\n        random.seed(0)\n        A = [random.randint(1, 10 ** 7) for i in range(400000)]\n        N = len(A)\n        print(solve(N, A))\n\n\nif __name__ == \"__main__\":\n    (N,) = list(map(int, input().split()))\n    A = list(map(int, input().split()))\n    ans = solve(N, A)\n    print(ans)","tags":["math"],"src_uid":"94f1521ccc24cfb78469c81546346cd5"}
{"text_full":"[DESCRIPTION]You are given an undirected unweighted graph consisting of $$$n$$$ vertices and $$$m$$$ edges.You have to write a number on each vertex of the graph. Each number should be $$$1$$$, $$$2$$$ or $$$3$$$. The graph becomes beautiful if for each edge the sum of numbers on vertices connected by this edge is odd.Calculate the number of possible ways to write numbers $$$1$$$, $$$2$$$ and $$$3$$$ on vertices so the graph becomes beautiful. Since this number may be large, print it modulo $$$998244353$$$.Note that you have to write exactly one number on each vertex.The graph does not have any self-loops or multiple edges.[SOURCE CODE]from collections import deque\nfrom sys import stdin, stdout\ninput = stdin.readline\nprint = stdout.write\n \nanss = []\nt = int(input())\n \nfor test_count in range(t):\n\tans = 1\n\tpart = 0\n\tfactor = 0\n\tqueue = deque([])\n\tn, m = map(int, input().split())\n\tif m > (n \/\/ 2) * ( n \/\/ 2 + 1):\n\t\tanss.append(0)\n\t\tfor edge_count in range(m):\n\t\t\tinput()\n\t\tcontinue\n\tedge = [[] for i in range(n + 1)]\n\tflag = [-1] * (n + 1)\n\tassure = 1\n \n\tfor edge_count in range(m):\n\t\tu, v = map(int, input().split())\n\t\tedge[u].append(v)\n\t\tedge[v].append(u)\n\tflag[1] = 0\n\tqueue.append(1)\n \n\tbreak_all = False\n\twhile not break_all:\n\t\teven, odd = 1, 0\n\t\twhile queue and not break_all:\n\t\t\tsearch = queue.popleft()\n\t\t\t# print('searching vertex {0}, {1}'.format(search, edge[search]))\n\t\t\tcurrent = flag[search]\n\t\t\tfor to in edge[search]:\n\t\t\t\tif flag[to] == -1:\n\t\t\t\t\tflag[to] = current ^ 1\n\t\t\t\t\tif flag[to] & 1:\n\t\t\t\t\t\todd += 1\n\t\t\t\t\telse:\n\t\t\t\t\t\teven += 1\n\t\t\t\t\tqueue.append(to)\n\t\t\t\telif flag[to] == current:\n\t\t\t\t\tbreak_all = True\n\t\t\t\telse:\n\t\t\t\t\tassert flag[to] == current ^ 1\n\t\t# print(flag)\n\t\tif break_all:\n\t\t\t# print('break_all')\n\t\t\tans = 0\n\t\telse:\n\t\t\tif (even, odd) == (1, 0):\n\t\t\t\tfactor += 1\n\t\t\telse:\n\t\t\t\tans *= pow(2, even, 998244353) + pow(2, odd, 998244353)\n\t\t\t\tans %= 998244353\n\t\twhile assure <= n:\n\t\t\tif flag[assure] == -1:\n\t\t\t\tpart += 1\n\t\t\t\tflag[assure] = 2 * part\n \n\t\t\t\tqueue.append(assure)\n\t\t\t\tbreak\n\t\t\tassure += 1\n\t\tif assure == n + 1:\n\t\t\tbreak\n\tans *= pow(3, factor, 998244353)\n\tans %= 998244353\n\tanss.append(ans)\nprint('\\n'.join(map(str, anss)))\n# print(time.time() - start)","tags":["graphs"],"src_uid":"332340a793eb3ec14131948e2b6bdf2f"}
{"text_full":"[DESCRIPTION]Gargari got bored to play with the bishops and now, after solving the problem about them, he is trying to do math homework. In a math book he have found k permutations. Each of them consists of numbers 1, 2, ..., n in some order. Now he should find the length of the longest common subsequence of these permutations. Can you help Gargari?You can read about longest common subsequence there: https:\/\/en.wikipedia.org\/wiki\/Longest_common_subsequence_problem[SOURCE CODE]#   ==========     \/\/\\\\       \/\/||     ||====\/\/||\n#       ||        \/\/  \\\\        ||     ||   \/\/ ||\n#       ||       \/\/====\\\\       ||     ||  \/\/  ||\n#       ||      \/\/      \\\\      ||     || \/\/   ||\n#   ========== \/\/        \\\\  ========  ||\/\/====|| \n#  code\n\ndef solve():\n    n, k = map(int, input().split())\n    c = [ [-1 for i in range(n + 1)] for i in range(k)]\n    dp = [0 for i in range(n + 1)]\n    a = []\n\n    for i in range(k):\n        b = list(map(int, input().split()))\n        for j, v in enumerate(b):\n            c[i][v] = j\n        a.append(b)\n\n    \n    for i in range(n):\n        curpos = a[0][i]\n        dp[i] = 1\n        for j in range(i):\n            prevpos = a[0][j]\n            ok = True\n            for p in range(k):\n                if c[p][curpos] < c[p][prevpos]:\n                    ok = False\n                    break\n            if ok:\n                dp[i] = max(dp[i], dp[j] + 1)\n    print(max(dp))\n    return\n\ndef main():\n    t = 1\n    # t = int(input())\n    for _ in range(t):\n        solve()\n\nif __name__ == \"__main__\":\n    main()","tags":["graphs"],"src_uid":"de87bb6ffd3c703d8845d4dd301bdbf5"}
{"text_full":"[DESCRIPTION]Vasya decided to pass a very large integer n to Kate. First, he wrote that number as a string, then he appended to the right integer k — the number of digits in n. Magically, all the numbers were shuffled in arbitrary order while this note was passed to Kate. The only thing that Vasya remembers, is a non-empty substring of n (a substring of n is a sequence of consecutive digits of the number n).Vasya knows that there may be more than one way to restore the number n. Your task is to find the smallest possible initial integer n. Note that decimal representation of number n contained no leading zeroes, except the case the integer n was equal to zero itself (in this case a single digit 0 was used).[SOURCE CODE]import sys\n\ndef main():\n    a = sys.stdin.readline().strip()\n    b = sys.stdin.readline().strip()\n\n    if a == \"01\" or a == \"10\":\n        print(\"0\")\n        return\n\n    cnt = [0] * 256\n    for i in map(ord, a):\n        cnt[i] += 1\n    n = sum(cnt)\n\n    l = 0\n    for i in range(1, 8):\n        if i == len(str(n - i)):\n            l = n - i\n            break;\n\n    for s in b, str(l):\n        for i in map(ord, s):\n            cnt[i] -= 1\n\n    res = [\"\".join([b] + [chr(k) * v for k, v in enumerate(cnt) if v > 0 ])] if b[0] > \"0\" else []\n\n    for i in range(ord(\"1\"), ord(\"9\") + 1):\n        if cnt[i] > 0:\n            cnt[i] -= 1\n            others = [chr(k) * v for k, v in enumerate(cnt) if v > 0]\n            others.append(b)\n            res.append(\"\".join([chr(i)] + sorted(others)))\n            break\n\n    print(min(res))\n\nif __name__ == \"__main__\":\n    main()","tags":["strings"],"src_uid":"5c3cec98676675355bb870d818704be6"}
{"text_full":"[DESCRIPTION]Valera's finally decided to go on holiday! He packed up and headed for a ski resort.Valera's fancied a ski trip but he soon realized that he could get lost in this new place. Somebody gave him a useful hint: the resort has n objects (we will consider the objects indexed in some way by integers from 1 to n), each object is either a hotel or a mountain.Valera has also found out that the ski resort had multiple ski tracks. Specifically, for each object v, the resort has at most one object u, such that there is a ski track built from object u to object v. We also know that no hotel has got a ski track leading from the hotel to some object.Valera is afraid of getting lost on the resort. So he wants you to come up with a path he would walk along. The path must consist of objects v1, v2, ..., vk (k ≥ 1) and meet the following conditions:  Objects with numbers v1, v2, ..., vk - 1 are mountains and the object with number vk is the hotel.  For any integer i (1 ≤ i &lt; k), there is exactly one ski track leading from object vi. This track goes to object vi + 1.  The path contains as many objects as possible (k is maximal). Help Valera. Find such path that meets all the criteria of our hero![SOURCE CODE]from collections import Counter\n\nn = input()\nv = [int(i) for i in raw_input().split()]\na = [int(i) for i in raw_input().split()]\n\ncnt = Counter(a)\npf = {}\nhotels = []\n\nfor i in range(len(a)):\n    if v[i] == 1:\n        hotels.append(i+1)\n    if a[i] == 0:\n        continue\n    pf[i+1] = a[i]\n\nmp = []\nfor h in hotels:\n    now = h\n    path = [h]\n    while pf.has_key(now):\n        now = pf[now]\n        if cnt[now] > 1:\n            break\n        path.append(now)\n    if len(path) > len(mp):\n        mp = path\n\nmp.reverse()\n\nprint len(mp)\nprint ' '.join(str(i) for i in mp)","tags":["graphs"],"src_uid":"a704760d5ccd09d08558ea98d6007835"}
{"text_full":"[DESCRIPTION]The rules of Sith Tournament are well known to everyone. n Sith take part in the Tournament. The Tournament starts with the random choice of two Sith who will fight in the first battle. As one of them loses, his place is taken by the next randomly chosen Sith who didn't fight before. Does it need to be said that each battle in the Sith Tournament ends with a death of one of opponents? The Tournament ends when the only Sith remains alive.Jedi Ivan accidentally appeared in the list of the participants in the Sith Tournament. However, his skills in the Light Side of the Force are so strong so he can influence the choice of participants either who start the Tournament or who take the loser's place after each battle. Of course, he won't miss his chance to take advantage of it. Help him to calculate the probability of his victory.[SOURCE CODE]import math\nimport sys\nn=int(raw_input())\nA=[]\n#print \"hi\"\n#sys.stdout.flush()\nfor j in range(n):\n    A+=[[float(x) for x in raw_input().split()]]\n#print \"hi\"\nwhile(True):\n    #print n\n    #print A\n    if n==1:\n        print \"1.0\"\n        break\n    if n==2:\n        print A[0][1]\n        break\n    M=0\n    j0=1\n    for j in range(1,n):\n        if A[0][j]>M:\n            j0=j\n            M=A[0][j]\n    B=[]\n    for i in range(n):\n        if i==j0:\n            continue\n        B+=[[]]\n        for j in range(n):\n            if j==j0:\n                continue\n            if i!=0 and j!=0:\n                B[-1]+=[A[i][j]]\n            elif i==0 and j==0:\n                B[-1]+=[0]\n            elif i==0 and j!=0:\n                B[-1]+=[A[0][j]*A[j][j0]+A[0][j0]*A[j0][j]]\n            elif i!=0 and j==0:\n                B[-1]+=[A[j][0]*A[j][j0]+A[j0][0]*A[j0][j]]\n    A=B\n    n-=1","tags":["probabilities","math"],"src_uid":"9b05933b72dc24d743cb59978f35c8f3"}
{"text_full":"[DESCRIPTION]There are two types of burgers in your restaurant — hamburgers and chicken burgers! To assemble a hamburger you need two buns and a beef patty. To assemble a chicken burger you need two buns and a chicken cutlet. You have $$$b$$$ buns, $$$p$$$ beef patties and $$$f$$$ chicken cutlets in your restaurant. You can sell one hamburger for $$$h$$$ dollars and one chicken burger for $$$c$$$ dollars. Calculate the maximum profit you can achieve.You have to answer $$$t$$$ independent queries.[SOURCE CODE]n = int(input())\nfor i in range(n):\n  b,p,f=map(int,input().split())\n  h,c=map(int,input().split())\n  p1=h*(min(b\/\/2,p))+c*(min(f,max(0,(b-2*p)\/\/2)))\n  p2=c*(min(b\/\/2,f))+h*(min(p,max(0,(b-2*f)\/\/2)))\n  print(max(p1,p2))","tags":["math"],"src_uid":"92bf30e66f4d5ddebb697d2fa4fa0689"}
{"text_full":"[DESCRIPTION]You are given an integer $$$n$$$ ($$$n \\ge 0$$$) represented with $$$k$$$ digits in base (radix) $$$b$$$. So,$$$$$$n = a_1 \\cdot b^{k-1} + a_2 \\cdot b^{k-2} + \\ldots a_{k-1} \\cdot b + a_k.$$$$$$For example, if $$$b=17, k=3$$$ and $$$a=[11, 15, 7]$$$ then $$$n=11\\cdot17^2+15\\cdot17+7=3179+255+7=3441$$$.Determine whether $$$n$$$ is even or odd.[SOURCE CODE]b, k = [int(i) for i in input().split()]\na = [int(i) for i in input().split()]\nn = 0\nfor i in range(0, k - 1):\n    n += a[i] * b\nif a[k - 1] % 2 != 0:\n    n += 1\nif n % 2 == 0:\n    print('even')\nelse:\n    print('odd')","tags":["math"],"src_uid":"ee105b664099808143a94a374d6d5daa"}
{"text_full":"[DESCRIPTION]You are given an array $$$a_1, a_2 \\dots a_n$$$. Calculate the number of tuples $$$(i, j, k, l)$$$ such that:   $$$1 \\le i &lt; j &lt; k &lt; l \\le n$$$;  $$$a_i = a_k$$$ and $$$a_j = a_l$$$;[SOURCE CODE]t = int(input())\nwhile(t):\n    t -= 1\n    n = int(input())\n    arr = list(map(int,input().split()))\n    left = [0]*(n+1)\n    right = [0]*(n+1)\n    ans = 0\n    for j in range(n):\n        for i in range(n+1):\n            right[i] = 0\n        for k in range(n-1,j,-1):\n            ans += left[arr[k]]*right[arr[j]]\n            right[arr[k]] += 1\n        left[arr[j]] += 1\n    print(ans)","tags":["math"],"src_uid":"eef9527a79ecf15a71d7ae4dcbb831e3"}
{"text_full":"[DESCRIPTION]As it's the first of April, Heidi is suspecting that the news she reads today are fake, and she does not want to look silly in front of all the contestants. She knows that a newspiece is fake if it contains heidi as a subsequence. Help Heidi assess whether the given piece is true, but please be discreet about it...[SOURCE CODE]x =[i for i in input()]\n\ndef charpos(c1,arr):\n\tfor i in range(len(arr)):\n\t\tif arr[i] ==c1:\n\t\t\treturn i\n\treturn -1\ntemp=0\nresult =True\nfor i in \"heidi\":\t\n\ttemp = charpos(i,x)\n\tx = x[temp:]\n\tif temp==-1:\n\t\tresult=False\n\t\tbreak\n\t\nif result:\n\tprint(\"YES\")\nelse:\n\tprint(\"NO\")","tags":["strings"],"src_uid":"a457e22fc8ff882c15ac57bca6960657"}
{"text_full":"[DESCRIPTION]Once upon a time there was only one router in the well-known company Bmail. Years went by and over time new routers were purchased. Every time they bought a new router, they connected it to one of the routers bought before it. You are given the values $$$p_i$$$ — the index of the router to which the $$$i$$$-th router was connected after being purchased ($$$p_i &lt; i$$$).There are $$$n$$$ routers in Boogle in total now. Print the sequence of routers on the path from the first to the $$$n$$$-th router.[SOURCE CODE]a=int(input())\nc=[]\nh = raw_input()\nb=(list(map(int,(h.split(' ')))))\nk=a-2\nc.append(a)\ni=1\nwhile k>=0:\n    c.append(b[k])\n    k=c[i]-2\n    i=i+1\nc.reverse()\nm=len(c)\nfor i in range (m):\n    print c[i]","tags":["trees"],"src_uid":"e25efe1020ae64d55b3257ba457f809d"}
{"text_full":"[DESCRIPTION]You are given an integer array $$$a_1, a_2, \\ldots, a_n$$$.The array $$$b$$$ is called to be a subsequence of $$$a$$$ if it is possible to remove some elements from $$$a$$$ to get $$$b$$$.Array $$$b_1, b_2, \\ldots, b_k$$$ is called to be good if it is not empty and for every $$$i$$$ ($$$1 \\le i \\le k$$$) $$$b_i$$$ is divisible by $$$i$$$.Find the number of good subsequences in $$$a$$$ modulo $$$10^9 + 7$$$. Two subsequences are considered different if index sets of numbers included in them are different. That is, the values ​of the elements ​do not matter in the comparison of subsequences. In particular, the array $$$a$$$ has exactly $$$2^n - 1$$$ different subsequences (excluding an empty subsequence).[SOURCE CODE]#!\/usr\/bin\/env python\n\"\"\"\nThis file is part of https:\/\/github.com\/Cheran-Senthil\/PyRival.\n\nCopyright 2018 Cheran Senthilkumar all rights reserved,\nCheran Senthilkumar <hello@cheran.io>\nPermission to use, modify, and distribute this software is given under the\nterms of the MIT License.\n\n\"\"\"\nfrom sys import stdin\n\n\ndef memodict(f):\n    \"\"\" Memoization decorator for a function taking a single argument. \"\"\"\n    class memodict(dict):\n        def __missing__(self, key):\n            ret = self[key] = f(key)\n            return ret\n    return memodict().__getitem__\n\n\n@memodict\ndef all_factors(n):\n    return sorted(set(reduce(list.__add__,\n                      ([i, n\/i] for i in xrange(1, int(n**0.5) + 1, 2 if n % 2 else 1) if n % i == 0))), reverse=True)\n\n\ndiv_cnt = [0] * (int(stdin.readline()) + 1)\n\nres, numb, sign, div_cnt[0] = 0, 0, 1, 1\n\ns = stdin.read()\n\nfor i in xrange(len(s)):\n    if s[i] >= '0':\n        numb = 10 * numb + ord(s[i]) - 48\n    else:\n        if s[i] == '-':\n            sign = -1\n        else:\n            for j in all_factors(sign * numb):\n                try:\n                    res, div_cnt[j] = res + div_cnt[j - 1], div_cnt[j] + div_cnt[j - 1]\n                    if res > 1000000007:\n                        res -= 1000000007\n\n                    if div_cnt[j] > 1000000007:\n                        div_cnt[j] -= 1000000007\n\n                except:\n                    pass\n\n            numb, sign = 0, 1\n\nprint res","tags":["number theory","math"],"src_uid":"587ac3b470aaacaa024a0c6dde134b7c"}
{"text_full":"[DESCRIPTION]Vika has an infinite sheet of squared paper. Initially all squares are white. She introduced a two-dimensional coordinate system on this sheet and drew n black horizontal and vertical segments parallel to the coordinate axes. All segments have width equal to 1 square, that means every segment occupy some set of neighbouring squares situated in one row or one column.Your task is to calculate the number of painted cells. If a cell was painted more than once, it should be calculated exactly once.[SOURCE CODE]from sys import stdin\nfrom itertools import repeat\nfrom collections import defaultdict\ndef main():\n    n = int(stdin.readline())\n    h = defaultdict(list)\n    w = defaultdict(list)\n    for i in range(n):\n        a, b, c, d = map(int, input().split())\n        if a > c:\n            a, c = c, a\n        if b > d:\n            b, d = d, b\n        if a == c:\n            h[a].append((b, d))\n        else:\n            w[b].append((a, c))\n    ans = 0\n    ys = set()\n    es = defaultdict(list)\n    qs = defaultdict(list)\n    for t, l in h.items():\n        l.sort()\n        l.append((1001001001, 1001001001))\n        nl = []\n        p = r = l[0][0]\n        for a, b in l:\n            if a > r:\n                nl.append((p, r))\n                ans += r - p + 1\n                es[p].append((1, t))\n                es[r+1].append((-1, t))\n                p = r = a\n            if r < b:\n                r = b\n        l = nl\n        ys.add(t)\n    for t, l in w.items():\n        l.sort()\n        l.append((1001001001, 1001001001))\n        nl = []\n        p = r = l[0][0]\n        for a, b in l:\n            if a > r:\n                nl.append((p, r))\n                ys.add(p)\n                ys.add(r)\n                es[t].append((2, p, r))\n                ans += r - p + 1\n                p = r = a\n            if r < b:\n                r = b\n        l = nl\n    ys = [-1001001001] + list(ys)\n    ys.sort()\n    d = {v: i for i, v in enumerate(ys)}\n    l = len(ys)\n    bs = [0] * l\n    for x in sorted(es.keys()):\n        for q in sorted(es[x]):\n            if q[0] <= 1:\n                a, b = q[0], d[q[1]]\n                while b < l:\n                    bs[b] += a\n                    b += b - (b & (b - 1))\n            else:\n                a, b = d[q[1]] - 1, d[q[2]]\n                while b > 0:\n                    ans -= bs[b]\n                    b = b & (b - 1)\n                while a > 0:\n                    ans += bs[a]\n                    a = a & (a - 1)\n    print (ans)\nmain()","tags":["geometry"],"src_uid":"6d7accf770d489f746648aa56c90d16d"}
{"text_full":"[DESCRIPTION]Ryouko is an extremely forgetful girl, she could even forget something that has just happened. So in order to remember, she takes a notebook with her, called Ryouko's Memory Note. She writes what she sees and what she hears on the notebook, and the notebook became her memory.Though Ryouko is forgetful, she is also born with superb analyzing abilities. However, analyzing depends greatly on gathered information, in other words, memory. So she has to shuffle through her notebook whenever she needs to analyze, which is tough work.Ryouko's notebook consists of n pages, numbered from 1 to n. To make life (and this problem) easier, we consider that to turn from page x to page y, |x - y| pages should be turned. During analyzing, Ryouko needs m pieces of information, the i-th piece of information is on page ai. Information must be read from the notebook in order, so the total number of pages that Ryouko needs to turn is .Ryouko wants to decrease the number of pages that need to be turned. In order to achieve this, she can merge two pages of her notebook. If Ryouko merges page x to page y, she would copy all the information on page x to y (1 ≤ x, y ≤ n), and consequently, all elements in sequence a that was x would become y. Note that x can be equal to y, in which case no changes take place.Please tell Ryouko the minimum number of pages that she needs to turn. Note she can apply the described operation at most once before the reading. Note that the answer can exceed 32-bit integers.[SOURCE CODE]n, m = map(int, raw_input().split())\na = map(int, raw_input().split())\nb = {}\nfor ai in a:\n    b[ai] = []\namt = 0\nfor i in xrange(1, len(a)):\n    amt += abs(a[i] - a[i-1])\n    if a[i] - a[i-1]:\n        b[a[i]] += [a[i-1]]\n        b[a[i-1]] += [a[i]]\ndiff = 0\nfor bi in b:\n    if b[bi]:\n        center = sorted(b[bi])[len(b[bi])\/2]\n        sum = 0\n        for page in b[bi]:\n            sum += abs(page - center) - abs(page - bi)\n        diff = min(diff, sum)\nprint amt + diff","tags":["math"],"src_uid":"871674fbb434121f41539c9f094432ac"}
{"text_full":"[DESCRIPTION]Patrick likes to play baseball, but sometimes he will spend so many hours hitting home runs that his mind starts to get foggy! Patrick is sure that his scores across $$$n$$$ sessions follow the identity permutation (ie. in the first game he scores $$$1$$$ point, in the second game he scores $$$2$$$ points and so on). However, when he checks back to his record, he sees that all the numbers are mixed up! Define a special exchange as the following: choose any subarray of the scores and permute elements such that no element of subarray gets to the same position as it was before the exchange. For example, performing a special exchange on $$$[1,2,3]$$$ can yield $$$[3,1,2]$$$ but it cannot yield $$$[3,2,1]$$$ since the $$$2$$$ is in the same position. Given a permutation of $$$n$$$ integers, please help Patrick find the minimum number of special exchanges needed to make the permutation sorted! It can be proved that under given constraints this number doesn't exceed $$$10^{18}$$$.An array $$$a$$$ is a subarray of an array $$$b$$$ if $$$a$$$ can be obtained from $$$b$$$ by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.[SOURCE CODE]from math import *\nfrom collections import *\nfrom operator import itemgetter\nimport bisect\nfrom heapq import *\ni = lambda: input()\nii = lambda: int(input())\niia = lambda: list(map(int,input().split()))\nisa = lambda: list(input().split())\nI = lambda:list(map(int,input().split()))\nchrIdx = lambda x: ord(x)-96\nidxChr = lambda x: chr(96+x)\n\n\nt = ii()\n\nfor _ in range(t):\n\tn = ii()\n\ta = iia()\n\tb = [i+1 for i in range(n)]\n\t#print(b)\n\tc = []\n\tfor i in range(n):\n\t\tc.append(a[i]-(i+1))\n\tcnt = 0\n\tnz = 0\n\tnnz = 0\n\tans = 0\n\tj = 0\n\t#print(c)\n\twhile j<n:\n\t\ti = j\n\t\tnz = 0\n\t\tnnz = 0\n\t\tcz = 0\n\t\twhile i<n:\n\t\t\tcnt+=c[i]\n\t\t\tif c[i]==0:\n\t\t\t\tnz+=1\n\t\t\t\tk = i+1\n\t\t\t\twhile k<n:\n\t\t\t\t\tif c[k]==0:\n\t\t\t\t\t\tk+=1\n\t\t\t\t\telse:\n\t\t\t\t\t\tbreak\n\t\t\t\ti = k-1\n\t\t\telse:\n\t\t\t\tnnz+=1\n\t\t\tif cnt==0:\n\t\t\t\tbreak\n\t\t\ti+=1\n\t\tif nnz>0:\n\t\t\tans+=(nz+1)\n\t\tj = i+1 \n\tprint(min(ans,2))","tags":["math"],"src_uid":"a98f67141b341152fcf20d803cbd5409"}
{"text_full":"[DESCRIPTION]There are $$$n$$$ bags with candies, initially the $$$i$$$-th bag contains $$$i$$$ candies. You want all the bags to contain an equal amount of candies in the end. To achieve this, you will: Choose $$$m$$$ such that $$$1 \\le m \\le 1000$$$Perform $$$m$$$ operations. In the $$$j$$$-th operation, you will pick one bag and add $$$j$$$ candies to all bags apart from the chosen one.Your goal is to find a valid sequence of operations after which all the bags will contain an equal amount of candies. It can be proved that for the given constraints such a sequence always exists.You don't have to minimize $$$m$$$.If there are several valid sequences, you can output any.[SOURCE CODE]t = int(input())\ndef solve():\n    n = int(input())\n    print(n)\n    arr = list(range(1, n + 1))\n    arr = [str(i) for i in arr]\n    print(\" \".join(arr))\nfor i in range(t):\n    solve()","tags":["math"],"src_uid":"ac248c83c99d8a2262772816b5f4ac6e"}
{"text_full":"[DESCRIPTION]Alice is playing with some stones.Now there are three numbered heaps of stones. The first of them contains $$$a$$$ stones, the second of them contains $$$b$$$ stones and the third of them contains $$$c$$$ stones.Each time she can do one of two operations:  take one stone from the first heap and two stones from the second heap (this operation can be done only if the first heap contains at least one stone and the second heap contains at least two stones);  take one stone from the second heap and two stones from the third heap (this operation can be done only if the second heap contains at least one stone and the third heap contains at least two stones). She wants to get the maximum number of stones, but she doesn't know what to do. Initially, she has $$$0$$$ stones. Can you help her?[SOURCE CODE]def stones(x,y,s):\n    if(x==0 or y==0):\n        return(s+0,x);\n    else:\n        while(x>0 and y>1):\n           x-=1\n           y-=2\n           s+=3\n        return(s,x)\n\nt=int(input())\nwhile(t>0):\n    sum=0\n    lst=list(map(int,input().split()))[0:3]\n    final,b=stones(lst[1],lst[2],0)\n    sum,c=stones(lst[0],b,final)\n    print(sum)\n    t=t-1","tags":["math"],"src_uid":"14fccd50d5dfb557dd53f2896ed844c3"}
{"text_full":"[DESCRIPTION]While Mike was walking in the subway, all the stuff in his back-bag dropped on the ground. There were several fax messages among them. He concatenated these strings in some order and now he has string s.  He is not sure if this is his own back-bag or someone else's. He remembered that there were exactly k messages in his own bag, each was a palindrome string and all those strings had the same length.He asked you to help him and tell him if he has worn his own back-bag. Check if the given string s is a concatenation of k palindromes of the same length.[SOURCE CODE]st = str(raw_input())\nn = int(raw_input())\nsize = len(st)\/n\ndef is_palindrome(seq):\n    return seq == seq[::-1]\nif n <= len(st):\n cnt = 0\n for i in range(0,len(st),size):\n    if  is_palindrome(st[i:size+i].lower()):\n        cnt += 1\n    else:\n        cnt -=1\n\n if cnt == n:\n    print \"YES\"\n else:\n    print \"NO\"\nelse:\n    print \"NO\"","tags":["strings"],"src_uid":"43bb8fec6b0636d88ce30f23b61be39f"}
{"text_full":"[DESCRIPTION]Although Inzane successfully found his beloved bone, Zane, his owner, has yet to return. To search for Zane, he would need a lot of money, of which he sadly has none. To deal with the problem, he has decided to hack the banks.  There are n banks, numbered from 1 to n. There are also n - 1 wires connecting the banks. All banks are initially online. Each bank also has its initial strength: bank i has initial strength ai.Let us define some keywords before we proceed. Bank i and bank j are neighboring if and only if there exists a wire directly connecting them. Bank i and bank j are semi-neighboring if and only if there exists an online bank k such that bank i and bank k are neighboring and bank k and bank j are neighboring.When a bank is hacked, it becomes offline (and no longer online), and other banks that are neighboring or semi-neighboring to it have their strengths increased by 1.To start his plan, Inzane will choose a bank to hack first. Indeed, the strength of such bank must not exceed the strength of his computer. After this, he will repeatedly choose some bank to hack next until all the banks are hacked, but he can continue to hack bank x if and only if all these conditions are met:  Bank x is online. That is, bank x is not hacked yet.  Bank x is neighboring to some offline bank.  The strength of bank x is less than or equal to the strength of Inzane's computer. Determine the minimum strength of the computer Inzane needs to hack all the banks.[SOURCE CODE]n = int(input())\n\nstrengths = list(map(int, input().split()))\nmax_strength = max(strengths)\n\ncount_max = strengths.count(max_strength)\ncount_second_place = strengths.count(max_strength - 1)\n\nmaxes = [0 for i in range(n)]\nsecond_places = [0 for i in range(n)]\n\nfor i in range(n - 1):\n    a, b = map(int, input().split())\n    a -= 1\n    b -= 1\n    if strengths[a] == max_strength:\n        maxes[b] += 1\n    elif strengths[a] == max_strength - 1:\n        second_places[b] += 1\n\n    if strengths[b] == max_strength:\n        maxes[a] += 1\n    elif strengths[b] == max_strength - 1:\n        second_places[a] += 1\n\ntotal_max = 1000000009\nfor i in range(n):\n    here = 0\n    if strengths[i] < max_strength:\n        if maxes[i] == count_max:\n            here = max_strength + 1\n        else:\n            here = max_strength + 2\n    else:\n        if count_max == 1:\n            if second_places[i] == count_second_place:\n                here = max_strength\n            else:\n                here = max_strength + 1\n        else:\n            if maxes[i] == count_max - 1:\n                here = max_strength + 1\n            else:\n                here = max_strength + 2\n    total_max = min(total_max, here)\n\nprint(total_max)","tags":["trees"],"src_uid":"9d3ab9c33b69c4f8e60454d369704b30"}
{"text_full":"[DESCRIPTION]You are given a rectangular grid of lattice points from (0, 0) to (n, m) inclusive. You have to choose exactly 4 different points to build a polyline possibly with self-intersections and self-touching. This polyline should be as long as possible.A polyline defined by points p1, p2, p3, p4 consists of the line segments p1 p2, p2 p3, p3 p4, and its length is the sum of the lengths of the individual line segments.[SOURCE CODE]import sys\nimport itertools\nfrom math import *\nn, m = map(int, raw_input().split(\" \"))\n\na, b = None, None\nfor i in xrange(0, n + 1):\n    for j in xrange(0, m + 1):\n        if not ((i, j) in [(0, 0), (n, m)]):\n            if a == None and b == None:\n                a = i\n                b = j\n            else:\n                if (0 - i)**2 + (0 - j)**2 > (0 - a)**2 + (0 - b)**2:\n                    a, b = i, j\nv = [(a, b), (0, 0)]\n\nc, d = a, b\na, b = None, None\nfor i in xrange(0, n + 1):\n    for j in xrange(0, m + 1):\n        if not ((i, j) in [(0, 0), (n, m), (c, d)]):\n            if a == None and b == None:\n                a = i\n                b = j\n            else:\n                if (n - i)**2 + (m - j)**2 > (n - a)**2 + (m - b)**2:\n                    a, b = i, j\nv += [(n, m), (a, b)]\n\n#print v\n\ndef d(x):\n    return sqrt((x[1][0] - x[0][0])**2 + (x[1][1] - x[0][1])**2) + sqrt((x[2][0] - x[1][0])**2 + (x[2][1] - x[1][1])**2) + sqrt((x[3][0] - x[2][0])**2 + (x[3][1] - x[2][1])**2)\n\nv = list(itertools.permutations(v))\nif n != 0 and m != 0:\n    v += list(itertools.permutations([(0, 0), (n, m), (n, 0), (0, m)]))\nfor a in sorted(zip(map(d, v), v))[-1][1]:\n    print \"%d %d\" % a","tags":["geometry","trees"],"src_uid":"78d54d76cb113cf74ea89fb77471859b"}
{"text_full":"[DESCRIPTION]Hamed has recently found a string t and suddenly became quite fond of it. He spent several days trying to find all occurrences of t in other strings he had. Finally he became tired and started thinking about the following problem. Given a string s how many ways are there to extract k ≥ 1 non-overlapping substrings from it such that each of them contains string t as a substring? More formally, you need to calculate the number of ways to choose two sequences a1, a2, ..., ak and b1, b2, ..., bk satisfying the following requirements:  k ≥ 1          t is a substring of string saisai + 1... sbi (string s is considered as 1-indexed). As the number of ways can be rather large print it modulo 109 + 7.[SOURCE CODE]s, t = input(), input()\nn, m = len(t), len(s) + 1\n\nd = 1000000007\ng = [1] * m\n\nf = k = 0\nfor i in range(1, m):\n    if s[i - n:i] == t: k = i\n    if k: f = (f + g[k - n]) % d\n    g[i] += (g[i - 1] + f) % d\n\nprint(f)","tags":["strings"],"src_uid":"1e55358988db2fce66b8a53daae50d83"}
{"text_full":"[DESCRIPTION]Emuskald is a well-known illusionist. One of his trademark tricks involves a set of magical boxes. The essence of the trick is in packing the boxes inside other boxes.From the top view each magical box looks like a square with side length equal to 2k (k is an integer, k ≥ 0) units. A magical box v can be put inside a magical box u, if side length of v is strictly less than the side length of u. In particular, Emuskald can put 4 boxes of side length 2k - 1 into one box of side length 2k, or as in the following figure:  Emuskald is about to go on tour performing around the world, and needs to pack his magical boxes for the trip. He has decided that the best way to pack them would be inside another magical box, but magical boxes are quite expensive to make. Help him find the smallest magical box that can fit all his boxes.[SOURCE CODE]import math\nn = int(input())\narr = []\nfor i in range(n):\n    k,a = list(map(int,input().split()))\n    arr.append([k,a])\narr.sort()\nans = 0\nfor i in arr:\n    x = math.log(i[1],4)+i[0]\n    ans = max(ans,math.ceil(x))\n    if i[1]==1:\n        ans = max(ans,i[0]+1)\nprint(ans)","tags":["math"],"src_uid":"15aac7420160f156d5b73059af1fae3b"}
{"text_full":"[DESCRIPTION]Gildong was hiking a mountain, walking by millions of trees. Inspired by them, he suddenly came up with an interesting idea for trees in data structures: What if we add another edge in a tree?Then he found that such tree-like graphs are called 1-trees. Since Gildong was bored of solving too many tree problems, he wanted to see if similar techniques in trees can be used in 1-trees as well. Instead of solving it by himself, he's going to test you by providing queries on 1-trees.First, he'll provide you a tree (not 1-tree) with $$$n$$$ vertices, then he will ask you $$$q$$$ queries. Each query contains $$$5$$$ integers: $$$x$$$, $$$y$$$, $$$a$$$, $$$b$$$, and $$$k$$$. This means you're asked to determine if there exists a path from vertex $$$a$$$ to $$$b$$$ that contains exactly $$$k$$$ edges after adding a bidirectional edge between vertices $$$x$$$ and $$$y$$$. A path can contain the same vertices and same edges multiple times. All queries are independent of each other; i.e. the added edge in a query is removed in the next query.[SOURCE CODE]import sys\n\n# LCA implementation found from:\n# https:\/\/github.com\/cheran-senthil\/PyRival\/blob\/1971590e96b351288cacb09852896f2383862ab6\/pyrival\/graphs\/lca.py\nclass RangeQuery:\n    def __init__(self, data, func=min):\n        self.func = func\n        self._data = _data = [list(data)]\n        i, n = 1, len(_data[0])\n        while 2 * i <= n:\n            prev = _data[-1]\n            _data.append([func(prev[j], prev[j + i]) for j in range(n - 2 * i + 1)])\n            i <<= 1\n\n    def query(self, begin, end):\n        depth = (end - begin).bit_length() - 1\n        return self.func(\n            self._data[depth][begin], self._data[depth][end - (1 << depth)]\n        )\n\n\nclass LCA:\n    def __init__(self, root, graph):\n        self.time = [-1] * len(graph)\n        self.path = []\n        self.depth = [0] * len(graph)  # MODIFIED\n        dfs = [root]\n        while dfs:\n            node = dfs.pop()\n            self.path.append(node)\n            if self.time[node] == -1:\n                self.time[node] = len(self.path) - 1\n                for nei in graph[node]:\n                    if self.time[nei] == -1:\n                        self.depth[nei] = self.depth[node] + 1  # MODIFIED\n                        dfs.append(node)\n                        dfs.append(nei)\n        self.rmq = RangeQuery(self.time[node] for node in self.path)\n\n    def lca(self, a, b):\n        a = self.time[a]\n        b = self.time[b]\n        if a > b:\n            a, b = b, a\n        return self.path[self.rmq.query(a, b + 1)]\n\n\ndef solve(N, edges, queries):\n\n    graph = [[] for i in range(N + 1)]\n    for e in edges:\n        graph[e[0]].append(e[1])\n        graph[e[1]].append(e[0])\n\n    L = LCA(1, graph)\n\n    def lca(u, v):\n        return L.lca(u, v)\n\n    def getDist(u, v):\n        return L.depth[u] + L.depth[v] - 2 * L.depth[lca(u, v)]\n\n    ans = []\n    for x, y, a, b, k in queries:\n        d_ab = getDist(a, b)\n        d_axyb = getDist(a, x) + 1 + getDist(y, b)\n        d_ayxb = getDist(a, y) + 1 + getDist(x, b)\n        if any(d <= k and (k - d) % 2 == 0 for d in [d_ab, d_axyb, d_ayxb]):\n            ans.append(\"YES\")\n        else:\n            ans.append(\"NO\")\n    return \"\\n\".join(ans)\n\n\nif __name__ == \"__main__\":\n    N = int(input())\n    edges = []\n    for i in range(N - 1):\n        edges.append(list(map(int, sys.stdin.readline().split())))\n    Q = int(input())\n    queries = []\n    for i in range(Q):\n        queries.append(list(map(int, sys.stdin.readline().split())))\n    ans = solve(N, edges, queries)\n    print(ans)","tags":["trees"],"src_uid":"c53e3b38a345dcf65bf984e819c289ef"}
{"text_full":"[DESCRIPTION]Jack decides to invite Emma out for a dinner. Jack is a modest student, he doesn't want to go to an expensive restaurant. Emma is a girl with high taste, she prefers elite places.Munhattan consists of n streets and m avenues. There is exactly one restaurant on the intersection of each street and avenue. The streets are numbered with integers from 1 to n and the avenues are numbered with integers from 1 to m. The cost of dinner in the restaurant at the intersection of the i-th street and the j-th avenue is cij.Jack and Emma decide to choose the restaurant in the following way. Firstly Emma chooses the street to dinner and then Jack chooses the avenue. Emma and Jack makes their choice optimally: Emma wants to maximize the cost of the dinner, Jack wants to minimize it. Emma takes into account that Jack wants to minimize the cost of the dinner. Find the cost of the dinner for the couple in love.[SOURCE CODE]s, a = list(map(int, input().rstrip().split()))\nmat = []\nl = []\nfor i in range(s):\n    b = list(map(int, input().rstrip().split()))\n    l += [min(b)]\nprint(max(l))","tags":["games"],"src_uid":"f2142bc2f44e5d8b77f8561c29038a73"}
{"text_full":"[DESCRIPTION]Stepan likes to repeat vowel letters when he writes words. For example, instead of the word \"pobeda\" he can write \"pobeeeedaaaaa\".Sergey does not like such behavior, so he wants to write a program to format the words written by Stepan. This program must combine all consecutive equal vowels to a single vowel. The vowel letters are \"a\", \"e\", \"i\", \"o\", \"u\" and \"y\".There are exceptions: if letters \"e\" or \"o\" repeat in a row exactly 2 times, like in words \"feet\" and \"foot\", the program must skip them and do not transform in one vowel. For example, the word \"iiiimpleeemeentatiioon\" must be converted to the word \"implemeentatioon\".Sergey is very busy and asks you to help him and write the required program.[SOURCE CODE]n = int(input())\nst = input()\nlast = '-'\nans = \"\"\nk = 0\nst += '+';\nfor it in st:\n    if it != last: \n        if last == 'a' or last == 'i' or last == 'u' or last == 'y':\n            ans += last;\n        elif last == 'e' or last == 'o':\n            if k == 2:\n                ans += last + last\n            else:\n                ans += last\n        elif last != '-':\n            for j in range(k):\n                ans += last\n        last = it\n        k = 1\n    else:\n        k += 1\nprint(ans)","tags":["strings"],"src_uid":"8ff1b4cf9875f1301e603b47626d06b4"}
{"text_full":"[DESCRIPTION]Vasya plays The Elder Trolls III: Morrowindows. He has a huge list of items in the inventory, however, there is no limits on the size of things. Vasya does not know the total amount of items but he is sure that are not more than x and not less than 2 items in his inventory. A new patch for the game appeared to view inventory in n different modes. Displaying in mode i is a partition of all inventory items on pages, each of which (except for maybe the last one) shows exactly ai items. In addition, each mode shows how many pages bi is in a complete list. Great! Perhaps this information will be enough for Vasya to find the required number. Moreover, it is very interesting, what is the fewest number of modes in which Vasya can see inventory to determine the number of items in it?Vasya cannot use the information that was received while looking on inventory in some mode for selection of next actions. I. e. Vasya chooses some set of modes first, and then sees all the results and determines the size.Knowing the number of ai, x and assuming that Vasya is very smart, check whether he can uniquely determine the number of items in his inventory, and how many modes he will need to do that if he knows numbers ai, x and he is able to know number bi after viewing items in mode i.[SOURCE CODE]n,x = map(int,raw_input().split())\na = set(map(int,raw_input().split()))\nif 1 in a and x>2: print 1\nelif x>1300000: print -1\nelse:\n    pr = range(x)\n    for i in xrange(2,x):\n        if not pr[i]: continue\n        ii=i*i\n        if ii>x: break\n        pr[ii::i]=[0]*len(pr[ii::i])     \n    pr = set(filter(None,pr)[1:])\n    print -1 if len(pr-a) else len(pr)","tags":["number theory","math"],"src_uid":"0f49b4a5696ee71ebbc8f83d1ec3b901"}
{"text_full":"[DESCRIPTION]Two players decided to play one interesting card game.There is a deck of $$$n$$$ cards, with values from $$$1$$$ to $$$n$$$. The values of cards are pairwise different (this means that no two different cards have equal values). At the beginning of the game, the deck is completely distributed between players such that each player has at least one card. The game goes as follows: on each turn, each player chooses one of their cards (whichever they want) and puts on the table, so that the other player doesn't see which card they chose. After that, both cards are revealed, and the player, value of whose card was larger, takes both cards in his hand. Note that as all cards have different values, one of the cards will be strictly larger than the other one. Every card may be played any amount of times. The player loses if he doesn't have any cards.For example, suppose that $$$n = 5$$$, the first player has cards with values $$$2$$$ and $$$3$$$, and the second player has cards with values $$$1$$$, $$$4$$$, $$$5$$$. Then one possible flow of the game is:The first player chooses the card $$$3$$$. The second player chooses the card $$$1$$$. As $$$3&gt;1$$$, the first player gets both cards. Now the first player has cards $$$1$$$, $$$2$$$, $$$3$$$, the second player has cards $$$4$$$, $$$5$$$.The first player chooses the card $$$3$$$. The second player chooses the card $$$4$$$. As $$$3&lt;4$$$, the second player gets both cards. Now the first player has cards $$$1$$$, $$$2$$$. The second player has cards $$$3$$$, $$$4$$$, $$$5$$$.The first player chooses the card $$$1$$$. The second player chooses the card $$$3$$$. As $$$1&lt;3$$$, the second player gets both cards. Now the first player has only the card $$$2$$$. The second player has cards $$$1$$$, $$$3$$$, $$$4$$$, $$$5$$$.The first player chooses the card $$$2$$$. The second player chooses the card $$$4$$$. As $$$2&lt;4$$$, the second player gets both cards. Now the first player is out of cards and loses. Therefore, the second player wins.Who will win if both players are playing optimally? It can be shown that one of the players has a winning strategy.[SOURCE CODE]t=input()\nfor i in xrange(t):\n    n,k1,k2=map(int, raw_input().split())\n    a=map(int, raw_input().split())\n    b=map(int, raw_input().split())\n    if n in a:\n        print \"YES\"\n    else:\n        print \"NO\"","tags":["games","math"],"src_uid":"3ef23f114be223255bd10131b2375b86"}
{"text_full":"[DESCRIPTION]Innokentiy likes tea very much and today he wants to drink exactly n cups of tea. He would be happy to drink more but he had exactly n tea bags, a of them are green and b are black.Innokentiy doesn't like to drink the same tea (green or black) more than k times in a row. Your task is to determine the order of brewing tea bags so that Innokentiy will be able to drink n cups of tea, without drinking the same tea more than k times in a row, or to inform that it is impossible. Each tea bag has to be used exactly once.[SOURCE CODE]n, k, a, b = [int(x) for x in input().split()]\n\ns = \"NO\"\nif (int(n \/ (k+1)) <= min(a, b)):\n    s = \"\"\n    actual = (a >= b)\n\n    while(a != b):\n        v = int(n \/ (k+1))\n        if (actual):\n            m = max(min(k, a - v), 1)\n            s += \"G\" * m\n            a -= m\n        else:\n            m = max(min(k, b - v), 1)\n            s += \"B\" * m\n            b -= m\n        n -= m\n        actual = not actual\n\n    if actual:\n        s += \"GB\" * a\n    else:\n        s += \"BG\" * a\n\nprint(s)","tags":["math"],"src_uid":"2a14f4a526ad2237b897102bfa298003"}
{"text_full":"[DESCRIPTION]Zookeeper is playing a game. In this game, Zookeeper must use bombs to bomb a string that consists of letters 'A' and 'B'. He can use bombs to bomb a substring which is either \"AB\" or \"BB\". When he bombs such a substring, the substring gets deleted from the string and the remaining parts of the string get concatenated.For example, Zookeeper can use two such operations: AABABBA $$$\\to$$$ AABBA $$$\\to$$$ AAA.Zookeeper wonders what the shortest string he can make is. Can you help him find the length of the shortest string?[SOURCE CODE]from collections import Counter\nimport math\nimport sys\nfrom bisect import bisect,bisect_left,bisect_right\nfrom itertools import permutations\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\ndef mod(): return 10**9+7\n\n\nfor i in range(INT()): \n  #n = INT()\n  s = input()\n  #n1,n2 = MAP()\n  #a = LIST()\n  n = len(s)\n  ans = 0\n  ca = 0\n  cb = 0\n  for i in range(n-1,-1,-1):\n    if s[i] == 'A':\n      ca += 1\n    if s[i] == 'B':\n      cb += 1\n    \n    if ca>cb:\n      ans += 1\n      ca = 0\n      cb = 0\n    else:\n      if ca == cb:\n        ca = 0\n        cb = 0\n      else:\n        cb -= ca\n        ca = 0\n  ans += cb%2\n  print(ans)","tags":["strings"],"src_uid":"ee295fd90ee9283709447481f172c73c"}
{"text_full":"[DESCRIPTION]Three companies decided to order a billboard with pictures of their logos. A billboard is a big square board. A logo of each company is a rectangle of a non-zero area. Advertisers will put up the ad only if it is possible to place all three logos on the billboard so that they do not overlap and the billboard has no empty space left. When you put a logo on the billboard, you should rotate it so that the sides were parallel to the sides of the billboard.Your task is to determine if it is possible to put the logos of all the three companies on some square billboard without breaking any of the described rules.[SOURCE CODE]w1,h1, w2,h2, w3,h3 = map(int, input().split())\nr1, r2, r3 = sorted((w1,h1)), sorted((w2,h2)), sorted((w3,h3))\nfor i in range(3):\n    ra, ca = (r1,r2,r3)[i], \"ABC\"[i]\n    rb, cb = (r1,r2,r3)[(i+1)%3], \"ABC\"[(i+1)%3]\n    rc, cc = (r1,r2,r3)[(i+2)%3], \"ABC\"[(i+2)%3]\n    if ra[0] == ra[1]: continue\n    # solve a ra[1]-ra[0] x ra[1] rectangle with 2 remaining rectangles\n    w, h = ra[1]-ra[0], ra[1]\n    rs = []\n    wtot, whit, ws = 0, 0, []\n    htot, hhit, hs = 0, 0, []\n    for r in (rb, rc):\n        rs.append(r)\n        if r[0] != r[1]:\n            rs.append((r[1], r[0]))\n    for r in rs:\n        if r[0] == w:\n            wtot += r[1]\n            whit += 1\n            ws.append(r[1])\n        if r[0] == h:\n            htot += r[1]\n            hhit += 1\n            hs.append(r[1])\n    if whit == 2 and wtot == h:\n        n = ra[1]\n        xb = rb[0] if rb[1] == w else rb[1]\n        xc = rc[0] if rc[1] == w else rc[1]\n        print(n)\n        print((ca * n + '\\n') * ra[0], end='')\n        print((cb * xb + cc * xc + '\\n') * w, end='')\n        break\n    if hhit == 2 and htot == w:\n        n = ra[1]\n        xb = rb[0] if rb[1] == h else rb[1]\n        xc = rc[0] if rc[1] == h else rc[1]\n        print(n)\n        print((ca * n + '\\n') * ra[0], end='')\n        print((cb * n + '\\n') * xb, end='')\n        print((cc * n + '\\n') * xc, end='')\n        break\nelse:\n    print(-1)","tags":["geometry","math"],"src_uid":"2befe5da2df57d23934601cbe4d4f151"}
{"text_full":"[DESCRIPTION]You have an array $$$a$$$ of length $$$n$$$. For every positive integer $$$x$$$ you are going to perform the following operation during the $$$x$$$-th second:  Select some distinct indices $$$i_{1}, i_{2}, \\ldots, i_{k}$$$ which are between $$$1$$$ and $$$n$$$ inclusive, and add $$$2^{x-1}$$$ to each corresponding position of $$$a$$$. Formally, $$$a_{i_{j}} := a_{i_{j}} + 2^{x-1}$$$ for $$$j = 1, 2, \\ldots, k$$$. Note that you are allowed to not select any indices at all. You have to make $$$a$$$ nondecreasing as fast as possible. Find the smallest number $$$T$$$ such that you can make the array nondecreasing after at most $$$T$$$ seconds.Array $$$a$$$ is nondecreasing if and only if $$$a_{1} \\le a_{2} \\le \\ldots \\le a_{n}$$$.You have to answer $$$t$$$ independent test cases.[SOURCE CODE]#logic#####maintain two pointer that will maintain the maximum difference between\n#two values and values that are not follwing the a<=b condition\ndef powerof2(x):\n    i=0\n    while 2**i<=x:\n        i+=1\n    return i\nfrom sys import stdout\nfor _ in range(int(input())):\n    n=int(input())\n    l=list(map(int,input().split()))\n    maz,miz=l[0],l[0]\n    cnt_max=0\n    for i in range(1,n):\n        cnt=0\n        if l[i]<maz:\n            if l[i]<miz:\n                miz=l[i]\n        else:\n            cnt=powerof2(maz-miz)\n            maz,miz=l[i],l[i]\n            if cnt>cnt_max:\n                cnt_max=cnt\n        if i==n-1 and maz-miz>0:\n            cnt=powerof2(maz-miz)\n            if cnt>cnt_max:\n                cnt_max=cnt\n    stdout.write(str(cnt_max) + \"\\n\")","tags":["math"],"src_uid":"bfc2e7de37db4a0a74cdd55f2124424a"}
{"text_full":"[DESCRIPTION]You are given a tree that consists of $$$n$$$ nodes. You should label each of its $$$n-1$$$ edges with an integer in such way that satisfies the following conditions:   each integer must be greater than $$$0$$$;  the product of all $$$n-1$$$ numbers should be equal to $$$k$$$;  the number of $$$1$$$-s among all $$$n-1$$$ integers must be minimum possible. Let's define $$$f(u,v)$$$ as the sum of the numbers on the simple path from node $$$u$$$ to node $$$v$$$. Also, let $$$\\sum\\limits_{i=1}^{n-1} \\sum\\limits_{j=i+1}^n f(i,j)$$$ be a distribution index of the tree.Find the maximum possible distribution index you can get. Since answer can be too large, print it modulo $$$10^9 + 7$$$.In this problem, since the number $$$k$$$ can be large, the result of the prime factorization of $$$k$$$ is given instead.[SOURCE CODE]import sys\ndef input():\n    return sys.stdin.readline()[:-1]\n\nmod = 10**9 + 7\n\ndef main():\n    t = int(input())\n\n    for i in range(t):\n        n = int(input())\n        e_list = [[] for i in range(n)]\n        for j in range(n-1):\n            a,b = list(map(int,input().split()))\n            a,b = a-1,b-1\n            e_list[a].append(b)\n            e_list[b].append(a)\n        \n        m = int(input())\n        p = list(map(int,input().split()))\n\n        from collections import deque\n        \n        vi = 0  #change\n        INF = float('inf')\n        \n        Q = deque([vi])\n        \n        checked_list = [False]*n\n        checked_list[vi]=True\n        \n        parent_list = [-1]*n\n\n        min_path_list = [INF]*n #change\n        min_path_list[vi] = 0\n        \n        while len(Q)>0:\n            v = Q.pop()\n            for v1 in e_list[v]:\n                if not checked_list[v1]:\n                    checked_list[v1]=True\n                    Q.appendleft(v1)\n                    parent_list[v1] = v\n                    min_path_list[v1] = min_path_list[v]+1\n        \n        memo = [-1]*n\n\n        min_path = [(i,min_path_list[i]) for i in range(n)]\n        min_path.sort(key=lambda x:x[1],reverse=True)\n        for v,d in min_path:\n            if v==0:\n                continue\n            count = 0\n            for v1 in e_list[v]:\n                if v1!=parent_list[v]:\n                    #print(v1)\n                    count+=memo[v1]+1\n            memo[v] = count\n            #print(memo)\n        #print(e_list)\n        memo = [(memo[i]+1)*(n-memo[i]-1) for i in range(1,n)]\n        memo.sort(reverse=True)\n        p.sort(reverse=True)\n        #print(memo)\n        ans = 0\n        if m<=n-1:\n            for i in range(m):\n                ans+=p[i]*memo[i]\n                ans%=mod\n            for i in range(m,n-1):\n                ans+=memo[i]\n                ans%=mod\n        else:\n            a = 1\n            for i in range(m-n+2):\n                a*=p[i]\n                a%=mod\n            ans = a*memo[0]\n            ans%=mod\n            for i in range(1,n-1):\n                ans+=p[i+m-n+1]*memo[i]\n                ans%=mod\n        print(ans)\n\nif __name__ == '__main__':\n    main()","tags":["number theory","math","trees"],"src_uid":"968b3db21bd16bc04bdb355e98079d5d"}
{"text_full":"[DESCRIPTION]Andryusha goes through a park each day. The squares and paths between them look boring to Andryusha, so he decided to decorate them.The park consists of n squares connected with (n - 1) bidirectional paths in such a way that any square is reachable from any other using these paths. Andryusha decided to hang a colored balloon at each of the squares. The baloons' colors are described by positive integers, starting from 1. In order to make the park varicolored, Andryusha wants to choose the colors in a special way. More precisely, he wants to use such colors that if a, b and c are distinct squares that a and b have a direct path between them, and b and c have a direct path between them, then balloon colors on these three squares are distinct.Andryusha wants to use as little different colors as possible. Help him to choose the colors![SOURCE CODE]import sys\nsys.setrecursionlimit(200000)\n\nn = int(input())\narr = [[] for i in range(n)]\nfor i in range(n - 1):\n    a, b = map(int, input().split())\n    arr[a - 1].append(b - 1)\n    arr[b - 1].append(a - 1)\ns = max([len(p) for p in arr]) + 1\nprint(s)\n\ncolored = [0] * n\ndef dfs(v, c, d):\n    colored[v] = p = c\n    for u in arr[v]:\n        if not colored[u]:\n            c = c + 1 if c < s else 1\n            if c == d:\n                c = c + 1 if c < s else 1\n            dfs(u, c, p)\nif s > 3:\n    dfs(0, 1, 0)\nelse:\n    i = 0\n    c = 1\n    while len(arr[i]) != 1:\n        i += 1\n    for j in range(n):\n        colored[i] = c\n        c = c + 1 if c < s else 1\n        if j < n - 1:\n            i = arr[i][0] if not colored[arr[i][0]] else arr[i][1]\nprint(\" \".join(map(str, colored)))","tags":["trees","graphs"],"src_uid":"2aaa31d52d69ff3703f93177b25671a3"}
{"text_full":"[DESCRIPTION]You've got another problem dealing with arrays. Let's consider an arbitrary sequence containing n (not necessarily different) integers a1, a2, ..., an. We are interested in all possible pairs of numbers (ai, aj), (1 ≤ i, j ≤ n). In other words, let's consider all n2 pairs of numbers, picked from the given array.For example, in sequence a = {3, 1, 5} are 9 pairs of numbers: (3, 3), (3, 1), (3, 5), (1, 3), (1, 1), (1, 5), (5, 3), (5, 1), (5, 5).Let's sort all resulting pairs lexicographically by non-decreasing. Let us remind you that pair (p1, q1) is lexicographically less than pair (p2, q2) only if either p1 &lt; p2, or p1 = p2 and q1 &lt; q2.Then the sequence, mentioned above, will be sorted like that: (1, 1), (1, 3), (1, 5), (3, 1), (3, 3), (3, 5), (5, 1), (5, 3), (5, 5)Let's number all the pair in the sorted list from 1 to n2. Your task is formulated like this: you should find the k-th pair in the ordered list of all possible pairs of the array you've been given.[SOURCE CODE]n, k = map(int, input().split())\na = sorted(map(int, input().split()))\nx = a[(k - 1) \/\/ n]\np, c = a.index(x), a.count(x)\ny = ((k - 1) - p * n) \/\/ c\nprint(x, a[y])","tags":["math"],"src_uid":"d3b9ffa76436b957ca959cf9204f9873"}
{"text_full":"[DESCRIPTION]Some time ago Lesha found an entertaining string $$$s$$$ consisting of lowercase English letters. Lesha immediately developed an unique algorithm for this string and shared it with you. The algorithm is as follows.Lesha chooses an arbitrary (possibly zero) number of pairs on positions $$$(i, i + 1)$$$ in such a way that the following conditions are satisfied:   for each pair $$$(i, i + 1)$$$ the inequality $$$0 \\le i &lt; |s| - 1$$$ holds;  for each pair $$$(i, i + 1)$$$ the equality $$$s_i = s_{i + 1}$$$ holds;  there is no index that is contained in more than one pair.  After that Lesha removes all characters on indexes contained in these pairs and the algorithm is over. Lesha is interested in the lexicographically smallest strings he can obtain by applying the algorithm to the suffixes of the given string.[SOURCE CODE]s = input().strip();N = len(s)\nif len(s) == 1:print(1, s[0]);exit()\nX = [s[-1], s[-2]+s[-1] if s[-2]!=s[-1] else \"\"];Y = [1, 2 if s[-2]!=s[-1] else 0]\nfor i in range(N-3, -1, -1):\n    c = s[i];k1 = c+X[-1];ng = Y[-1]+1\n    if ng > 10:k1 = k1[:5] + \"...\" + k1[-2:]\n    if c == s[i+1] and k1 > X[-2]:k1 = X[-2];ng = Y[-2]\n    X.append(k1);Y.append(ng)\nfor i in range(N-1, -1, -1):print(Y[i], X[i])","tags":["strings"],"src_uid":"7d6faccc88a6839822fa0c0ec8c00251"}
{"text_full":"[DESCRIPTION]Momiji has got a rooted tree, consisting of n nodes. The tree nodes are numbered by integers from 1 to n. The root has number 1. Momiji decided to play a game on this tree.The game consists of several steps. On each step, Momiji chooses one of the remaining tree nodes (let's denote it by v) and removes all the subtree nodes with the root in node v from the tree. Node v gets deleted as well. The game finishes when the tree has no nodes left. In other words, the game finishes after the step that chooses the node number 1.Each time Momiji chooses a new node uniformly among all the remaining nodes. Your task is to find the expectation of the number of steps in the described game.[SOURCE CODE]n = input()\nedge = [[] for _ in range(n)]\nfor i in range(n - 1):\n    a, b = map(int, raw_input().split())\n    edge[a - 1].append(b - 1)\n    edge[b - 1].append(a - 1)\nd = [0] * n\nd[0] = 1\np = [0]\nfor u in p:\n    for v in edge[u]:\n        if not d[v]:\n            d[v] = d[u] + 1\n            p.append(v)\nprint sum((1. \/ x for x in d))","tags":["probabilities","trees","math"],"src_uid":"85b78251160db9d7ca1786e90e5d6f21"}
{"text_full":"[DESCRIPTION]You are given a tree consisting of $$$n$$$ nodes. You want to write some labels on the tree's edges such that the following conditions hold:  Every label is an integer between $$$0$$$ and $$$n-2$$$ inclusive.  All the written labels are distinct.  The largest value among $$$MEX(u,v)$$$ over all pairs of nodes $$$(u,v)$$$ is as small as possible. Here, $$$MEX(u,v)$$$ denotes the smallest non-negative integer that isn't written on any edge on the unique simple path from node $$$u$$$ to node $$$v$$$.[SOURCE CODE]data = input().rstrip().split()\nn = int(data[0])\n\nedges = []\n\ng = {i+1: [] for i in range(n)}\n\nleafes = set()\n\nfor _ in range(n-1):\n    data = input().rstrip().split()\n    a, b = int(data[0]), int(data[1])\n    a, b = sorted([a, b])\n    edges.append((a, b))\n    g[a].append(b)\n    g[b].append(a)\n\nfor k, v in g.items():\n    if len(leafes) == 3:\n        break\n\n    if len(v) == 1:\n        e = sorted([k, v[0]])\n        leafes.add(tuple(e))\n\ncounter = len(leafes)\nl_counter = 0\nto_print = []\n\nfor edge in edges:\n    a, b = edge\n\n    if edge in leafes:\n        to_print.append(l_counter)\n        l_counter += 1\n\n    else:\n        to_print.append(counter)\n        counter += 1\n\nfor p in to_print:\n    print(p)","tags":["trees"],"src_uid":"5ef966b7d9fbf27e6197b074eca31b15"}
{"text_full":"[DESCRIPTION]The German University in Cairo (GUC) dorm houses are numbered from 1 to n. Underground water pipes connect these houses together. Each pipe has certain direction (water can flow only in this direction and not vice versa), and diameter (which characterizes the maximal amount of water it can handle).For each house, there is at most one pipe going into it and at most one pipe going out of it. With the new semester starting, GUC student and dorm resident, Lulu, wants to install tanks and taps at the dorms. For every house with an outgoing water pipe and without an incoming water pipe, Lulu should install a water tank at that house. For every house with an incoming water pipe and without an outgoing water pipe, Lulu should install a water tap at that house. Each tank house will convey water to all houses that have a sequence of pipes from the tank to it. Accordingly, each tap house will receive water originating from some tank house.In order to avoid pipes from bursting one week later (like what happened last semester), Lulu also has to consider the diameter of the pipes. The amount of water each tank conveys should not exceed the diameter of the pipes connecting a tank to its corresponding tap. Lulu wants to find the maximal amount of water that can be safely conveyed from each tank to its corresponding tap.[SOURCE CODE]houses, pipes = [int(x) for x in input().strip().split()]\n \nhouseToHouseDict = {}\npipeDict = {}\noutgoingList = []\nincomingList = []\nmaxFlow = 0\ndef DFSmaxPipe(origin):\n\tend = []\n\tlowestDiam = maxFlow\n\twhile (origin in houseToHouseDict):\n\t\tdiam = pipeDict[origin]\n\t\tif diam < lowestDiam:\n\t\t\tlowestDiam = diam\n\t\torigin = houseToHouseDict[origin]\n\tend.append(origin)\n\tend.append(lowestDiam)\n\treturn end\n \n \n \nfor x in range(pipes):\n\tahouse, bhouse, diameter = [int(x) for x in input().strip().split()]\n\tpipeDict[ahouse] = diameter\n\thouseToHouseDict[ahouse] = bhouse\n\toutgoingList.append(ahouse)\n\tincomingList.append(bhouse)\n\tif diameter > maxFlow:\n\t\tmaxFlow = diameter\n \n \nfor pipe in incomingList:\n\ttry:\n\t\toutgoingList.remove(pipe)\n\texcept ValueError:\n\t\tpass\n \noutgoingList.sort()\n \nprint(len(outgoingList))\n \nfor origin in outgoingList:\n\toutString = str(origin)\n\t\n\tendPipe = DFSmaxPipe(origin)\n\toutString += \" \" + str(endPipe[0]) + \" \" + str(endPipe[1])\n\tprint(outString)","tags":["graphs"],"src_uid":"e83a8bfabd7ea096fae66dcc8c243be7"}
{"text_full":"[DESCRIPTION]A long time ago, in a galaxy far far away two giant IT-corporations Pineapple and Gogol continue their fierce competition. Crucial moment is just around the corner: Gogol is ready to release it's new tablet Lastus 3000.This new device is equipped with specially designed artificial intelligence (AI). Employees of Pineapple did their best to postpone the release of Lastus 3000 as long as possible. Finally, they found out, that the name of the new artificial intelligence is similar to the name of the phone, that Pineapple released 200 years ago. As all rights on its name belong to Pineapple, they stand on changing the name of Gogol's artificial intelligence.Pineapple insists, that the name of their phone occurs in the name of AI as a substring. Because the name of technology was already printed on all devices, the Gogol's director decided to replace some characters in AI name with \"#\". As this operation is pretty expensive, you should find the minimum number of characters to replace with \"#\", such that the name of AI doesn't contain the name of the phone as a substring.Substring is a continuous subsequence of a string.[SOURCE CODE]s1=input()\ns2=input()\n\nprint(s1.count(s2))","tags":["strings"],"src_uid":"62a672fcaee8be282700176803c623a7"}
{"text_full":"[DESCRIPTION]Andrey needs one more problem to conduct a programming contest. He has n friends who are always willing to help. He can ask some of them to come up with a contest problem. Andrey knows one value for each of his fiends — the probability that this friend will come up with a problem if Andrey asks him.Help Andrey choose people to ask. As he needs only one problem, Andrey is going to be really upset if no one comes up with a problem or if he gets more than one problem from his friends. You need to choose such a set of people that maximizes the chances of Andrey not getting upset.[SOURCE CODE]def C():\n    n = int(input())\n    tmp = input()\n    tmp = tmp.split()\n    probability = list(map(float,tmp))\n\n    probability.sort()\n    \n    current = probability[n-1]\n    pre = 1 - probability[n-1]\n\n    for i in range(n-2,-1,-1):\n        tmp = current * (1-probability[i]) + pre * (probability[i])\n        if (tmp > current):\n            current = tmp\n            pre = pre * (1-probability[i])\n\n    print(\"%.12f\" % current)\n\nif __name__ == \"__main__\":\n    C()","tags":["probabilities","math"],"src_uid":"b4ac594755951e84001dfd610d420eb5"}
{"text_full":"[DESCRIPTION]You are given a text that consists of lowercase Latin letters, spaces and punctuation marks (dot, comma, exclamation mark and question mark). A word is defined as a sequence of consecutive Latin letters.Your task is to add spaces to the text by the following rules:  if there is no punctuation mark between two words, then they should be separated by exactly one space  there should be no spaces before each punctuation mark  there should be exactly one space after each punctuation mark It is guaranteed that there is at least one word between any two punctuation marks. The text begins and ends with a Latin letter.[SOURCE CODE]x=input()\nm=('.',',','?','!')\nfor i in range(len(x)-1):\n    if x[i] in m and x[i + 1] != ' ':\n        print(x[i] + ' ', end='')\n    elif not(x[i]==' ' and x[i+1]==' ' or x[i]==' ' and x[i+1] in m):\n        print(x[i],end='')\nprint(x[len(x)-1])","tags":["strings"],"src_uid":"8c26daa1eed2078af3b32737da0a0f84"}
{"text_full":"[DESCRIPTION]In the snake exhibition, there are $$$n$$$ rooms (numbered $$$0$$$ to $$$n - 1$$$) arranged in a circle, with a snake in each room. The rooms are connected by $$$n$$$ conveyor belts, and the $$$i$$$-th conveyor belt connects the rooms $$$i$$$ and $$$(i+1) \\bmod n$$$. In the other words, rooms $$$0$$$ and $$$1$$$, $$$1$$$ and $$$2$$$, $$$\\ldots$$$, $$$n-2$$$ and $$$n-1$$$, $$$n-1$$$ and $$$0$$$ are connected with conveyor belts.The $$$i$$$-th conveyor belt is in one of three states:  If it is clockwise, snakes can only go from room $$$i$$$ to $$$(i+1) \\bmod n$$$.  If it is anticlockwise, snakes can only go from room $$$(i+1) \\bmod n$$$ to $$$i$$$.  If it is off, snakes can travel in either direction.   Above is an example with $$$4$$$ rooms, where belts $$$0$$$ and $$$3$$$ are off, $$$1$$$ is clockwise, and $$$2$$$ is anticlockwise.Each snake wants to leave its room and come back to it later. A room is returnable if the snake there can leave the room, and later come back to it using the conveyor belts. How many such returnable rooms are there?[SOURCE CODE]ans = []\nfor i in range(int(input())):\n    n = int(input())\n    s = list(input())\n    if '>' in s and '<' in s:\n        a = 0\n        for i in range(n):\n            if s[i] == '-' or s[i - 1] == '-':\n                a += 1\n        ans.append(a)\n    else:\n        ans.append(n)\nprint('\\n'.join(map(str, ans)))","tags":["graphs"],"src_uid":"f82685f41f4ba1146fea8e1eb0c260dc"}
{"text_full":"[DESCRIPTION]The city administration of IT City decided to fix up a symbol of scientific and technical progress in the city's main square, namely an indicator board that shows the effect of Moore's law in real time.Moore's law is the observation that the number of transistors in a dense integrated circuit doubles approximately every 24 months. The implication of Moore's law is that computer performance as function of time increases exponentially as well.You are to prepare information that will change every second to display on the indicator board. Let's assume that every second the number of transistors increases exactly 1.000000011 times.[SOURCE CODE]s  = input()\nS = s.split()\ntransistors = int(S[0])\nseconds = int(S[1])\na1 = 1\na2 = 1\na3 = 1\nfor i in range(1000):\n    a1 = a1*1.000000011\nfor i in range(1000):\n    a2 = a2*a1\nfor i in range(1000):\n    a3 = a3*a2\n\n\nlocal0 = seconds%1000\nseconds = int((seconds-local0)\/1000)\nlocal1 = seconds%1000\nseconds = int((seconds-local1)\/1000)\nlocal2 = seconds%1000\nseconds = int((seconds-local2)\/1000)\nlocal3 = seconds%1000\nfor i in range(local0):\n    transistors = transistors*1.000000011\nfor i in range(local1):\n    transistors = transistors*a1\nfor i in range(local2):\n    transistors = transistors*a2\nfor i in range(local3):\n    transistors = transistors*a3\nprint(transistors)","tags":["math"],"src_uid":"36ad784f23bd1e8e579052642a6e9244"}
{"text_full":"[DESCRIPTION]Mr. Scrooge, a very busy man, decided to count the time he wastes on all sorts of useless stuff to evaluate the lost profit. He has already counted the time he wastes sleeping and eating. And now Mr. Scrooge wants to count the time he has wasted signing papers.Mr. Scrooge's signature can be represented as a polyline A1A2... An. Scrooge signs like that: first it places a pen at the point A1, then draws a segment from point A1 to point A2, then he draws a segment from point A2 to point A3 and so on to point An, where he stops signing and takes the pen off the paper. At that the resulting line can intersect with itself and partially repeat itself but Scrooge pays no attention to it and never changes his signing style. As Scrooge makes the signature, he never takes the pen off the paper and his writing speed is constant — 50 millimeters per second.Scrooge signed exactly k papers throughout his life and all those signatures look the same.Find the total time Scrooge wasted signing the papers.[SOURCE CODE]inn = list(map(int, input().split(\" \")))\npnts = inn[0]\nmult = inn[1]\ndist = 0\nc = list(map(int, input().split(\" \")))\nfor i in range(1,pnts):\n    s = list(map(int, input().split(\" \")))\n    x1 = c[0]\n    x2 = s[0]\n    y1 = c[1]\n    y2 = s[1]\n    dist += ((((x2 - x1) ** 2) + ((y2 - y1) ** 2)) ** 0.5)\n    c = s\ntt = (dist\/50)*mult\nprint('%.9f'%tt)","tags":["geometry"],"src_uid":"db4a25159067abd9e3dd22bc4b773385"}
{"text_full":"[DESCRIPTION]For god's sake, you're boxes with legs! It is literally your only purpose! Walking onto buttons! How can you not do the one thing you were designed for?Oh, that's funny, is it? Oh it's funny? Because we've been at this for twelve hours and you haven't solved it either, so I don't know why you're laughing. You've got one hour! Solve it!  Wheatley decided to try to make a test chamber. He made a nice test chamber, but there was only one detail absent — cubes.For completing the chamber Wheatley needs $$$n$$$ cubes. $$$i$$$-th cube has a volume $$$a_i$$$.Wheatley has to place cubes in such a way that they would be sorted in a non-decreasing order by their volume. Formally, for each $$$i&gt;1$$$, $$$a_{i-1} \\le a_i$$$ must hold.To achieve his goal, Wheatley can exchange two neighbouring cubes. It means that for any $$$i&gt;1$$$ you can exchange cubes on positions $$$i-1$$$ and $$$i$$$.But there is a problem: Wheatley is very impatient. If Wheatley needs more than $$$\\frac{n \\cdot (n-1)}{2}-1$$$ exchange operations, he won't do this boring work.Wheatly wants to know: can cubes be sorted under this conditions?[SOURCE CODE]t = int(input())\nfor i in range(t):\n    n = int(input())\n    lst = list(map(int, input().split()))\n\n    flag = 0\n    for i in range(n-1):\n        if lst[i] <= lst[i + 1]:\n            flag = 1\n            break\n    if flag == 1:\n        print(\"YES\")\n    else:\n        print(\"NO\")","tags":["math"],"src_uid":"b34f29e6fb586c22fa1b9e559c5a6c50"}
{"text_full":"[DESCRIPTION]You are given an array $$$a$$$ consisting of $$$n$$$ integers.Your task is to determine if $$$a$$$ has some subsequence of length at least $$$3$$$ that is a palindrome.Recall that an array $$$b$$$ is called a subsequence of the array $$$a$$$ if $$$b$$$ can be obtained by removing some (possibly, zero) elements from $$$a$$$ (not necessarily consecutive) without changing the order of remaining elements. For example, $$$[2]$$$, $$$[1, 2, 1, 3]$$$ and $$$[2, 3]$$$ are subsequences of $$$[1, 2, 1, 3]$$$, but $$$[1, 1, 2]$$$ and $$$[4]$$$ are not.Also, recall that a palindrome is an array that reads the same backward as forward. In other words, the array $$$a$$$ of length $$$n$$$ is the palindrome if $$$a_i = a_{n - i - 1}$$$ for all $$$i$$$ from $$$1$$$ to $$$n$$$. For example, arrays $$$[1234]$$$, $$$[1, 2, 1]$$$, $$$[1, 3, 2, 2, 3, 1]$$$ and $$$[10, 100, 10]$$$ are palindromes, but arrays $$$[1, 2]$$$ and $$$[1, 2, 3, 1]$$$ are not.You have to answer $$$t$$$ independent test cases.[SOURCE CODE]for test in range(int(input())):\n    n=int(input())\n    l=list(map(int,input().split()))\n    l.append(10000000009)\n\n    c=0\n    for i in range(n-2):\n        if l[i] in l[i+2:]:\n            print(\"YES\")\n            c=1\n            break\n    if(c==0):\n        print(\"NO\")","tags":["strings"],"src_uid":"5139d222fbbfa70d50e990f5d6c92726"}
{"text_full":"[DESCRIPTION]HDD hard drives group data by sectors. All files are split to fragments and each of them are written in some sector of hard drive. Note the fragments can be written in sectors in arbitrary order.One of the problems of HDD hard drives is the following: the magnetic head should move from one sector to another to read some file.Find the time need to read file split to n fragments. The i-th sector contains the fi-th fragment of the file (1 ≤ fi ≤ n). Note different sectors contains the different fragments. At the start the magnetic head is in the position that contains the first fragment. The file are reading in the following manner: at first the first fragment is read, then the magnetic head moves to the sector that contains the second fragment, then the second fragment is read and so on until the n-th fragment is read. The fragments are read in the order from the first to the n-th.It takes |a - b| time units to move the magnetic head from the sector a to the sector b. Reading a fragment takes no time.[SOURCE CODE]from bisect import bisect\nfrom itertools import permutations,combinations\nn=int(input())\na=list(map(int,input().split()))\n\ncnt=1\nb = []\nfor x in a:\n    b.append([x,cnt])\n    cnt+=1\nb.sort()\nres = 0\nfor i in range(1,n):\n    res+=abs(b[i][1]-b[i-1][1])\nprint(res)","tags":["math"],"src_uid":"54e2b6bea0dc6ee68366405945af50c6"}
{"text_full":"[DESCRIPTION]After a hard day Vitaly got very hungry and he wants to eat his favorite potato pie. But it's not that simple. Vitaly is in the first room of the house with n room located in a line and numbered starting from one from left to right. You can go from the first room to the second room, from the second room to the third room and so on — you can go from the (n - 1)-th room to the n-th room. Thus, you can go to room x only from room x - 1.The potato pie is located in the n-th room and Vitaly needs to go there. Each pair of consecutive rooms has a door between them. In order to go to room x from room x - 1, you need to open the door between the rooms with the corresponding key. In total the house has several types of doors (represented by uppercase Latin letters) and several types of keys (represented by lowercase Latin letters). The key of type t can open the door of type T if and only if t and T are the same letter, written in different cases. For example, key f can open door F.Each of the first n - 1 rooms contains exactly one key of some type that Vitaly can use to get to next rooms. Once the door is open with some key, Vitaly won't get the key from the keyhole but he will immediately run into the next room. In other words, each key can open no more than one door.Vitaly realizes that he may end up in some room without the key that opens the door to the next room. Before the start his run for the potato pie Vitaly can buy any number of keys of any type that is guaranteed to get to room n.Given the plan of the house, Vitaly wants to know what is the minimum number of keys he needs to buy to surely get to the room n, which has a delicious potato pie. Write a program that will help Vitaly find out this number.[SOURCE CODE]from collections import defaultdict\nn = input()\ns = raw_input()\nd = defaultdict(int)\nc = 0\nfor i in range(1,2*n-2+1):\n\tif i%2:\n\t\td[s[i-1]] += 1\n\telif i%2 == 0 and d[s[i-1].lower()] == 0:\n\t\tc += 1\n\telif i%2 ==0 and d[s[i-1].lower()] != 0:\n\t\td[s[i-1].lower()] -= 1\nprint c","tags":["strings"],"src_uid":"80fdb95372c1e8d558b8c8f31c9d0479"}
{"text_full":"[DESCRIPTION]Polycarp has guessed three positive integers $$$a$$$, $$$b$$$ and $$$c$$$. He keeps these numbers in secret, but he writes down four numbers on a board in arbitrary order — their pairwise sums (three numbers) and sum of all three numbers (one number). So, there are four numbers on a board in random order: $$$a+b$$$, $$$a+c$$$, $$$b+c$$$ and $$$a+b+c$$$.You have to guess three numbers $$$a$$$, $$$b$$$ and $$$c$$$ using given numbers. Print three guessed integers in any order.Pay attention that some given numbers $$$a$$$, $$$b$$$ and $$$c$$$ can be equal (it is also possible that $$$a=b=c$$$).[SOURCE CODE]x, y, z, s = map(int, raw_input().strip().split())\nt = x + y + z + s\nS = t \/\/ 3\n\nl = [S - x, S - y, S - z, S - s]\n\nfor num in l:\n    if num != 0: print num,","tags":["math"],"src_uid":"cda949a8fb1f158f3c06109a2d33f084"}
{"text_full":"[DESCRIPTION]After a team finished their training session on Euro football championship, Valeric was commissioned to gather the balls and sort them into baskets. Overall the stadium has n balls and m baskets. The baskets are positioned in a row from left to right and they are numbered with numbers from 1 to m, correspondingly. The balls are numbered with numbers from 1 to n.Valeric decided to sort the balls in the order of increasing of their numbers by the following scheme. He will put each new ball in the basket with the least number of balls. And if he's got several variants, he chooses the basket which stands closer to the middle. That means that he chooses the basket for which  is minimum, where i is the number of the basket. If in this case Valeric still has multiple variants, he chooses the basket with the minimum number.For every ball print the number of the basket where it will go according to Valeric's scheme.Note that the balls are sorted into baskets in the order of increasing numbers, that is, the first ball goes first, then goes the second ball and so on.[SOURCE CODE]n, m = map(int, input().split())\na = []\nt = 1 if m % 2 else -1\nfor i in range(m):\n\ta.append(int(m\/2)+int(m%2)+t*int((i+1)\/2))\n\tt *= -1\nfor i in range(n):\n\tprint(a[int(i%m)])","tags":["math"],"src_uid":"907893a0a78a7444d26bdd793d9c7499"}
{"text_full":"[DESCRIPTION]You are given $$$n$$$ integers $$$a_1, a_2, \\dots, a_n$$$, such that for each $$$1\\le i \\le n$$$ holds $$$i-n\\le a_i\\le i-1$$$.Find some nonempty subset of these integers, whose sum is equal to $$$0$$$. It can be shown that such a subset exists under given constraints. If there are several possible subsets with zero-sum, you can find any of them.[SOURCE CODE]from sys import stdin, stdout\n\nt = input()\ninp = stdin.readlines()\nout = []\n\nfor itr in xrange(t):\n    n = int(inp[itr << 1].strip())\n    a = map(int, inp[itr << 1 | 1].strip().split())\n    \n    found = -1\n    \n    for i in xrange(n):\n        if a[i] == 0:\n            found = i\n            break\n        else:\n            a[i] = i + 1 - a[i]\n\n    if found != -1:\n        out.append(\"1\")\n        out.append(str(found + 1))\n        continue\n\n    vis = [0] * n\n\n    i = 0\n    idxlist = []\n    start = 0\n    while vis[i] == 0:\n        vis[i] = 1\n        \n        i = a[i] - 1\n        if vis[i] == 1: start = i\n\n    idxlist.append(str(start + 1))\n    \n    i = a[start] - 1\n    while i != start:\n        idxlist.append(str(i + 1))\n        i = a[i] - 1\n        \n    out.append(str(len(idxlist)))\n    out.append(\" \".join(idxlist))\n\nstdout.write(\"\\n\".join(out))","tags":["graphs","math"],"src_uid":"61ba68bdc7a1e3c60135cbae30d9e088"}
{"text_full":"[DESCRIPTION]Fifa and Fafa are sharing a flat. Fifa loves video games and wants to download a new soccer game. Unfortunately, Fafa heavily uses the internet which consumes the quota. Fifa can access the internet through his Wi-Fi access point. This access point can be accessed within a range of r meters (this range can be chosen by Fifa) from its position. Fifa must put the access point inside the flat which has a circular shape of radius R. Fifa wants to minimize the area that is not covered by the access point inside the flat without letting Fafa or anyone outside the flat to get access to the internet.The world is represented as an infinite 2D plane. The flat is centered at (x1, y1) and has radius R and Fafa's laptop is located at (x2, y2), not necessarily inside the flat. Find the position and the radius chosen by Fifa for his access point which minimizes the uncovered area.[SOURCE CODE]R,x1,y1,x2,y2=map(int,input().split())\ns=((x1-x2)**2+(y1-y2)**2)**(0.5)\nsin=0\ncos=1\ndef dist(x1,x2,y1,y2):\n    return ((x1-x2)**2+(y1-y2)**2)**(0.5)\nif (s>R):\n    print(x1,y1,R)\nelse:\n    r=(s+R)\/2\n    if s!=0:\n        sin=((y2-y1)\/s)\n        cos=((x2-x1)\/s)\n\n    xpos,ypos=x2+r*cos,y2+r*sin\n    xneg,yneg=x2-r*cos,y2-r*sin\n    dis1=dist(xpos,x1,ypos,y1)\n    dis2=dist(xneg,x1,yneg,y1)\n    if dis1<dis2:\n        print(xpos,ypos,r)\n    else:\n        print(xneg,yneg,r)","tags":["geometry"],"src_uid":"29d4ca13888c0e172dde315b66380fe5"}
{"text_full":"[DESCRIPTION]One important contest will take place on the most famous programming platform (Topforces) very soon!The authors have a pool of $$$n$$$ problems and should choose at most three of them into this contest. The prettiness of the $$$i$$$-th problem is $$$a_i$$$. The authors have to compose the most pretty contest (in other words, the cumulative prettinesses of chosen problems should be maximum possible).But there is one important thing in the contest preparation: because of some superstitions of authors, the prettinesses of problems cannot divide each other. In other words, if the prettinesses of chosen problems are $$$x, y, z$$$, then $$$x$$$ should be divisible by neither $$$y$$$, nor $$$z$$$, $$$y$$$ should be divisible by neither $$$x$$$, nor $$$z$$$ and $$$z$$$ should be divisible by neither $$$x$$$, nor $$$y$$$. If the prettinesses of chosen problems are $$$x$$$ and $$$y$$$ then neither $$$x$$$ should be divisible by $$$y$$$ nor $$$y$$$ should be divisible by $$$x$$$. Any contest composed from one problem is considered good.Your task is to find out the maximum possible total prettiness of the contest composed of at most three problems from the given pool.You have to answer $$$q$$$ independent queries.If you are Python programmer, consider using PyPy instead of Python when you submit your code.[SOURCE CODE]def cal(sorted_list, size):\n    max_sum = 0\n    for k in range(len(sorted_list)):\n        max_sum = max(sorted_list[k], max_sum)\n        for i in range(k+1,size):\n            temp_1 = sorted_list[i]\n            if sorted_list[k]%temp_1 != 0:\n                if i+1 < size and max_sum >= sorted_list[k] + sorted_list[i] + sorted_list[i+1]:\n                    break\n                check_sum = sorted_list[k] + temp_1\n                max_sum = max(max_sum, check_sum)\n                for j in range(i+1, size):\n                    if max_sum >= sorted_list[k] + sorted_list[i] + sorted_list[j]:\n                        break\n                    temp_2 = sorted_list[j]\n                    if sorted_list[k] % temp_2 != 0 and temp_1 % temp_2 != 0:\n                        max_sum =  max(max_sum, check_sum + temp_2)\n                        break\n    return max_sum\n\ndef solve():\n    no_querries = int(input())\n    output = []\n    for i in range(no_querries):\n        size = int(input())\n        alist_raw = input().split()\n        alist = [int(x) for x in alist_raw]\n        alist.sort(reverse=True)\n        alist = unique(alist)\n        output.append(cal(alist, len(alist)))\n    for x in output:\n        print(x)\n\ndef unique(alist):\n    unique = [alist[0]]\n    for i in range(1,len(alist)):\n        if alist[i] < unique[len(unique)-1]:\n            unique.append(alist[i])\n    return unique\n\nsolve()","tags":["math"],"src_uid":"da15eae7831e3eb5e1f2e2e4c5222fbf"}
{"text_full":"[DESCRIPTION]Let's call a string \"s-palindrome\" if it is symmetric about the middle of the string. For example, the string \"oHo\" is \"s-palindrome\", but the string \"aa\" is not. The string \"aa\" is not \"s-palindrome\", because the second half of it is not a mirror reflection of the first half.  English alphabet You are given a string s. Check if the string is \"s-palindrome\".[SOURCE CODE]s = input()\nitself = {'A', 'H', 'I', 'M', 'O', 'o', 'T', 'U', 'V', 'v', 'W', 'w', 'X', 'x', 'Y'}\nd = {'p' : 'q', 'q' : 'p', 'b' : 'd', 'd' : 'b'}\nfor i in itself:\n\td[i] = i\nok = True\nfor i in range(len(s)):\n\tok &= s[i] in d.keys() and s[len(s) - i - 1] == d[s[i]]\nprint(\"TAK\" if ok else \"NIE\")","tags":["strings"],"src_uid":"bec2349631158b7dbfedcaededf65cc2"}
{"text_full":"[DESCRIPTION]Haiku is a genre of Japanese traditional poetry.A haiku poem consists of 17 syllables split into three phrases, containing 5, 7 and 5 syllables correspondingly (the first phrase should contain exactly 5 syllables, the second phrase should contain exactly 7 syllables, and the third phrase should contain exactly 5 syllables). A haiku masterpiece contains a description of a moment in those three phrases. Every word is important in a small poem, which is why haiku are rich with symbols. Each word has a special meaning, a special role. The main principle of haiku is to say much using a few words.To simplify the matter, in the given problem we will consider that the number of syllable in the phrase is equal to the number of vowel letters there. Only the following letters are regarded as vowel letters: \"a\", \"e\", \"i\", \"o\" and \"u\".Three phases from a certain poem are given. Determine whether it is haiku or not.[SOURCE CODE]phr1, phr2, phr3 = raw_input(), raw_input(), raw_input()\nif sum([phr1.count(k) for k in \"aeiou\"]) == 5 and sum([phr2.count(k) for k in \"aeiou\"]) == 7 and sum([phr3.count(k) for k in \"aeiou\"]) == 5:\n    print \"YES\"\nelse:\n    print \"NO\"","tags":["strings"],"src_uid":"46d734178b3acaddf2ee3706f04d603d"}
{"text_full":"[DESCRIPTION]You are given a rooted tree with vertices numerated from $$$1$$$ to $$$n$$$. A tree is a connected graph without cycles. A rooted tree has a special vertex named root.Ancestors of the vertex $$$i$$$ are all vertices on the path from the root to the vertex $$$i$$$, except the vertex $$$i$$$ itself. The parent of the vertex $$$i$$$ is the nearest to the vertex $$$i$$$ ancestor of $$$i$$$. Each vertex is a child of its parent. In the given tree the parent of the vertex $$$i$$$ is the vertex $$$p_i$$$. For the root, the value $$$p_i$$$ is $$$-1$$$.    An example of a tree with $$$n=8$$$, the root is vertex $$$5$$$. The parent of the vertex $$$2$$$ is vertex $$$3$$$, the parent of the vertex $$$1$$$ is vertex $$$5$$$. The ancestors of the vertex $$$6$$$ are vertices $$$4$$$ and $$$5$$$, the ancestors of the vertex $$$7$$$ are vertices $$$8$$$, $$$3$$$ and $$$5$$$ You noticed that some vertices do not respect others. In particular, if $$$c_i = 1$$$, then the vertex $$$i$$$ does not respect any of its ancestors, and if $$$c_i = 0$$$, it respects all of them.You decided to delete vertices from the tree one by one. On each step you select such a non-root vertex that it does not respect its parent and none of its children respects it. If there are several such vertices, you select the one with the smallest number. When you delete this vertex $$$v$$$, all children of $$$v$$$ become connected with the parent of $$$v$$$.    An example of deletion of the vertex $$$7$$$. Once there are no vertices matching the criteria for deletion, you stop the process. Print the order in which you will delete the vertices. Note that this order is unique.[SOURCE CODE]from heapq import *\n\nn = int(input())\npred = [[] for i in range(n + 1)]\ng = [[] for i in range(n + 1)]\nfor i in range(1, n + 1):\n    p, c = map(int, input().split())\n    pred[i] = [p, c]\n    if p != -1:\n        g[p].append([i, c])\nheap = []\nfor i in range(1, n + 1):\n    if pred[i][1] == 1:\n        ok = True\n        for x in g[i]:\n            if x[1] == 0:\n                ok = False\n                break\n        if ok:\n            heappush(heap, i)\nres = []\nwhile heap:\n    v = heappop(heap)\n    res.append(v)\nif not res:\n    print(-1)\nelse:\n    print(' '.join(map(str, res)))","tags":["trees"],"src_uid":"1b975c5a13a2ad528b668a7c68c089f6"}
{"text_full":"[DESCRIPTION]Saitama accidentally destroyed a hotel again. To repay the hotel company, Genos has volunteered to operate an elevator in one of its other hotels. The elevator is special — it starts on the top floor, can only move down, and has infinite capacity. Floors are numbered from 0 to s and elevator initially starts on floor s at time 0.The elevator takes exactly 1 second to move down exactly 1 floor and negligible time to pick up passengers. Genos is given a list detailing when and on which floor passengers arrive. Please determine how long in seconds it will take Genos to bring all passengers to floor 0.[SOURCE CODE]R = lambda : map(int, input().split())\n\nn,s=R()\nm = max([sum(R()) for _ in range(n)])\nprint(max(m,s))","tags":["math"],"src_uid":"5c12573b3964ee30af0349c11c0ced3b"}
{"text_full":"[DESCRIPTION]You are given N points on a plane. Write a program which will find the sum of squares of distances between all pairs of points.[SOURCE CODE]#Code by Sounak, IIESTS\n#------------------------------warmup----------------------------\n\nimport os\nimport sys\nimport math\nfrom io import BytesIO, IOBase\nfrom fractions import Fraction\nimport collections\nfrom itertools import permutations\nfrom collections import defaultdict\nfrom collections import deque\nimport threading\n\n\n\nthreading.stack_size(10**8)\nsys.setrecursionlimit(300000)\n\nBUFSIZE = 8192\n \n \nclass FastIO(IOBase):\n    newlines = 0\n    \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n     \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n  \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n#-------------------game starts now-----------------------------------------------------\nclass Factorial:\n    def __init__(self, MOD):\n        self.MOD = MOD\n        self.factorials = [1, 1]\n        self.invModulos = [0, 1]\n        self.invFactorial_ = [1, 1]\n \n    def calc(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate n!\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        if n < len(self.factorials):\n            return self.factorials[n]\n        nextArr = [0] * (n + 1 - len(self.factorials))\n        initialI = len(self.factorials)\n        prev = self.factorials[-1]\n        m = self.MOD\n        for i in range(initialI, n + 1):\n            prev = nextArr[i - initialI] = prev * i % m\n        self.factorials += nextArr\n        return self.factorials[n]\n \n    def inv(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate n^(-1)\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        p = self.MOD\n        pi = n % p\n        if pi < len(self.invModulos):\n            return self.invModulos[pi]\n        nextArr = [0] * (n + 1 - len(self.invModulos))\n        initialI = len(self.invModulos)\n        for i in range(initialI, min(p, n + 1)):\n            next = -self.invModulos[p % i] * (p \/\/ i) % p\n            self.invModulos.append(next)\n        return self.invModulos[pi]\n \n    def invFactorial(self, n):\n        if n <= -1:\n            print(\"Invalid argument to calculate (n^(-1))!\")\n            print(\"n must be non-negative value. But the argument was \" + str(n))\n            exit()\n        if n < len(self.invFactorial_):\n            return self.invFactorial_[n]\n        self.inv(n)  # To make sure already calculated n^-1\n        nextArr = [0] * (n + 1 - len(self.invFactorial_))\n        initialI = len(self.invFactorial_)\n        prev = self.invFactorial_[-1]\n        p = self.MOD\n        for i in range(initialI, n + 1):\n            prev = nextArr[i - initialI] = (prev * self.invModulos[i % p]) % p\n        self.invFactorial_ += nextArr\n        return self.invFactorial_[n]\n \n \nclass Combination:\n    def __init__(self, MOD):\n        self.MOD = MOD\n        self.factorial = Factorial(MOD)\n \n    def ncr(self, n, k):\n        if k < 0 or n < k:\n            return 0\n        k = min(k, n - k)\n        f = self.factorial\n        return f.calc(n) * f.invFactorial(max(n - k, k)) * f.invFactorial(min(k, n - k)) % self.MOD\n#-------------------------------------------------------------------------\nmod=10**9+7\nn=int(input())\na=list()\nx,y=0,0\nr=0\nfor i in range (n):\n    x1,y1=map(int,input().split())\n    a.append((x1,y1))\n    x+=x1\n    y+=y1\n    r+=(n-1)*(x1*x1+y1*y1)\n#print(r,x,y)\nfor i in range (n):\n    p,q=a[i]\n    r-=(p*(x-p)+q*(y-q))\nprint(r)","tags":["math"],"src_uid":"9bd6fea892857d7c94ebce4d4cd46d30"}
{"text_full":"[DESCRIPTION]Egor is a famous Russian singer, rapper, actor and blogger, and finally he decided to give a concert in the sunny Republic of Dagestan.There are $$$n$$$ cities in the republic, some of them are connected by $$$m$$$ directed roads without any additional conditions. In other words, road system of Dagestan represents an arbitrary directed graph. Egor will arrive to the city $$$1$$$, travel to the city $$$n$$$ by roads along some path, give a concert and fly away.As any famous artist, Egor has lots of haters and too annoying fans, so he can travel only by safe roads. There are two types of the roads in Dagestan, black and white: black roads are safe at night only, and white roads — in the morning. Before the trip Egor's manager's going to make a schedule: for each city he'll specify it's color, black or white, and then if during the trip they visit some city, the only time they can leave it is determined by the city's color: night, if it's black, and morning, if it's white. After creating the schedule Egor chooses an available path from $$$1$$$ to $$$n$$$, and for security reasons it has to be the shortest possible.Egor's manager likes Dagestan very much and wants to stay here as long as possible, so he asks you to make such schedule that there would be no path from $$$1$$$ to $$$n$$$ or the shortest path's length would be greatest possible.A path is one city or a sequence of roads such that for every road (excluding the first one) the city this road goes from is equal to the city previous road goes into. Egor can move only along paths consisting of safe roads only. The path length is equal to the number of roads in it. The shortest path in a graph is a path with smallest length.[SOURCE CODE]import sys\ninput = sys.stdin.readline\nfrom collections import deque\nn, m = map(int, input().split());back = [[] for i in range(n)]\nfor _ in range(m):u, v, w = map(int, input().split());u -= 1;v -= 1;back[v].append((u,w)) \nout = [2] * n;outl = [-1] * n;outl[-1] = 0;q = deque([n - 1])\nwhile q:\n    v = q.popleft()\n    for u, w in back[v]:\n        if out[u] != w:out[u] = 1 - w\n        else:\n            if outl[u] == -1:outl[u] = outl[v] + 1;q.append(u)                \nout = [v if v != 2 else 1 for v in out];print(outl[0]);print(''.join(map(str,out)))","tags":["graphs"],"src_uid":"f26a979dc042ec9564cfecce29e5a1cf"}
{"text_full":"[DESCRIPTION]Anton goes to school, his favorite lessons are arraystudying. He usually solves all the tasks pretty fast, but this time the teacher gave him a complicated one: given two arrays b and c of length n, find array a, such that:where a and b means bitwise AND, while a or b means bitwise OR.Usually Anton is good in arraystudying, but this problem is too hard, so Anton asks you to help.[SOURCE CODE]def f():\n    n, = map(int,raw_input().split())\n    B = map(int,raw_input().split())\n    C = map(int,raw_input().split())\n    D = [B[i]+C[i] for i in xrange(n)]\n    t = sum(D)\n    if n == 1 and B[0] != C[0]:\n        print -1\n        return\n    if t % 2 or t % (n*2):\n        print -1\n        return\n    tA = t \/ (n*2)\n    if any((d-tA)%n for d in D):\n        print -1\n        return\n    A = [(d-tA)\/\/n for d in D]\n    mask = [2**i for i in xrange(32)]\n    c = [0]*32\n    #for i in xrange(32):\n        #c[i] = sum(1 if mask[i]&a else 0 for a in A)\n    for a in A:\n        for i in xrange(32):\n            c[i] += 1 if mask[i]&a else 0\n    if any(B[i] != sum(c[j]<<j if A[i]&mask[j] else 0 for j in xrange(32)) for i in xrange(n)):\n        print -1\n        return\n    #if C[i] != sum(n<<j if a&mask[j] else c[j]<<j for j in xrange(32)):\n    print ' '.join(map(str, A))\n \nf()","tags":["math"],"src_uid":"4a674b93475abb341780241c8e821a62"}
{"text_full":"[DESCRIPTION]You are given a tree, which consists of $$$n$$$ vertices. Recall that a tree is a connected undirected graph without cycles.     Example of a tree. Vertices are numbered from $$$1$$$ to $$$n$$$. All vertices have weights, the weight of the vertex $$$v$$$ is $$$a_v$$$.Recall that the distance between two vertices in the tree is the number of edges on a simple path between them.Your task is to find the subset of vertices with the maximum total weight (the weight of the subset is the sum of weights of all vertices in it) such that there is no pair of vertices with the distance $$$k$$$ or less between them in this subset.[SOURCE CODE]visited = [0]*205\ndp = [[0]*205 for i in range(205)]\ndef dfs(node,g):\n    sons = []\n    for nb in g[node]:\n        if not visited[nb]:\n            visited[nb] = 1\n            dfs(nb,g)\n            sons.append(nb)\n\n    dp[node][0] = ws[node-1]\n    for s in sons:\n        dp[node][0] += dp[s][k]\n\n\n    ls = len(sons)\n    # print node,sons,g[node]\n    for i in range(ls):\n        for j in range(k+1):\n            d2 = max(k-1-j,0)\n            maxd = j+1\n            if d2+1<maxd and ls>1:\n                d2 = j\n            tmp = dp[sons[i]][j]\n            for s in range(ls):\n                if s==i:\n                    continue\n                tmp += dp[sons[s]][d2]\n            dp[node][maxd] = max(dp[node][maxd],tmp)\n\n    for i in range(k)[::-1]:\n        dp[node][i] = max(dp[node][i],dp[node][i+1])\n\n\n\nn,k = map(int,raw_input().split(\" \"))\nws = map(int,raw_input().split(\" \"))\nedges = []\n\ndef add(dic,k,v):\n    if not dic.has_key(k):\n        dic[k] = v\n    else:\n        dic[k] += v\n\ng = {}\nfor i in range(n-1):\n    a,b = map(int,raw_input().split(\" \"))\n    edges.append((a,b))\n    add(g,a,[b])\n    add(g,b,[a])\nroot = 1\nvisited[root] = 1\nif g.has_key(root):\n    dfs(root,g)\n    print dp[root][0]\nelse:\n    print ws[root-1]","tags":["trees"],"src_uid":"8476fd1d794448fb961248cd5afbc92d"}
{"text_full":"[DESCRIPTION]Chef Monocarp has just put $$$n$$$ dishes into an oven. He knows that the $$$i$$$-th dish has its optimal cooking time equal to $$$t_i$$$ minutes.At any positive integer minute $$$T$$$ Monocarp can put no more than one dish out of the oven. If the $$$i$$$-th dish is put out at some minute $$$T$$$, then its unpleasant value is $$$|T - t_i|$$$ — the absolute difference between $$$T$$$ and $$$t_i$$$. Once the dish is out of the oven, it can't go back in.Monocarp should put all the dishes out of the oven. What is the minimum total unpleasant value Monocarp can obtain?[SOURCE CODE]import sys\n\noriginal_stdout = sys.stdout\n\nvar_for_sublime = False \n\n\nif var_for_sublime:\n\tfin = open('input.txt' , 'r')\n\tfout = open('output.txt' , 'w')\n\tsys.stdout = fout\n\tdef give_string():\n\t\treturn fin.readline()\nelse:\n\tfin = sys.stdin \n\tfout = sys.stdout\n\tdef give_string():\n\t\treturn fin.buffer.readline()\n\ndef give_list():\n\treturn list(map(int, give_string().split()))\ndef give_int():\n\treturn int(give_string())\n\n\nMOD = 1e9+ 7\ndef modpow( a , p) :\n\tans = 1 \n\twhile p :\n\t\tif p&1 :\n\t\t\tans *= a \n\t\t\tans %= MOD \n\t\tp >>= 1\n\t\ta *= a\n\t\ta %= MOD\n\treturn ans \t\t\n\n\n\ndef fac_cal(n):\n\tans = 1\n\tfor i in range(1 , n+1):\n\t\tans *= i \n\t\tans %= MOD \n\treturn ans \n\n\n\n\n\ndef solve():\n\tn = give_int() \n\tt=  give_list() \n\tt.sort()\n\t# print(t)\n\tdp = [ [1e9]*(2*n) for i in range(n)]\n\tfor i in range(n):\n\t\tfor j in range(i+1 , 2*n):\n\t\t\tif(i == 0):\n\t\t\t\tdp[i][j] = min(dp[i][j-1] , abs(t[0] - j))\n\t\t\telse:\n\t\t\t\tdp[i][j] = min(dp[i][j-1] , dp[i-1][j-1]+abs(t[i]-j))\n\t\t\t# print(i , j )\n\tans = 1e9\n\t# for li in dp:\n\t# \tprint(li)\n\tfor i in range(2*n):\n\t\tans = min(ans , dp[n-1][i])\n\tprint(ans)\n\n\ndef main():\n\ttry :\n\t\tt = 1 \n\t\tt = give_int()\n\t\tfor i in range(t):\n\t\t\tsolve()\n\tfinally:\n\t\tfin.close()\n\t\tfout.close()\n\t\tsys.stdout = original_stdout\n\n\n\n\n\nif __name__ == '__main__' :\n\tmain()","tags":["math"],"src_uid":"27998621de63e50a7d89cb1c1e30f67c"}
{"text_full":"[DESCRIPTION]Polycarp is very careful. He even types numeric sequences carefully, unlike his classmates. If he sees a sequence without a space after the comma, with two spaces in a row, or when something else does not look neat, he rushes to correct it. For example, number sequence written like \"1,2 ,3,...,   10\" will be corrected to \"1, 2, 3, ..., 10\".In this task you are given a string s, which is composed by a concatination of terms, each of which may be:   a positive integer of an arbitrary length (leading zeroes are not allowed),  a \"comma\" symbol (\",\"),  a \"space\" symbol (\" \"),  \"three dots\" (\"...\", that is, exactly three points written one after another, also known as suspension points). Polycarp wants to add and remove spaces in the string s to ensure the following:   each comma is followed by exactly one space (if the comma is the last character in the string, this rule does not apply to it),  each \"three dots\" term is preceded by exactly one space (if the dots are at the beginning of the string, this rule does not apply to the term),  if two consecutive numbers were separated by spaces only (one or more), then exactly one of them should be left,  there should not be other spaces. Automate Polycarp's work and write a program that will process the given string s.[SOURCE CODE]ans = input()\nwhile \" ,\" in ans:\n    ans = ans.replace(\" ,\", \",\")\nans = ans.replace(\"...\", \" ...\").replace(\",\", \", \")\nwhile \"  \" in ans:\n    ans = ans.replace(\"  \", \" \")\nfor d in \"0123456789\": ans = ans.replace(\". \" + d, \".\" + d)\nprint(ans.strip(), end=\"\")","tags":["strings"],"src_uid":"c7d8c71a1f7e6c7364cce5bddd488a2f"}
{"text_full":"[DESCRIPTION]International Women's Day is coming soon! Polycarp is preparing for the holiday.There are $$$n$$$ candy boxes in the shop for sale. The $$$i$$$-th box contains $$$d_i$$$ candies.Polycarp wants to prepare the maximum number of gifts for $$$k$$$ girls. Each gift will consist of exactly two boxes. The girls should be able to share each gift equally, so the total amount of candies in a gift (in a pair of boxes) should be divisible by $$$k$$$. In other words, two boxes $$$i$$$ and $$$j$$$ ($$$i \\ne j$$$) can be combined as a gift if $$$d_i + d_j$$$ is divisible by $$$k$$$.How many boxes will Polycarp be able to give? Of course, each box can be a part of no more than one gift. Polycarp cannot use boxes \"partially\" or redistribute candies between them.[SOURCE CODE]n, k = map(int, input().split(' '))\ngifts = sorted(list(map(lambda cnd: int(cnd) % k, input().split())))\nequal_classes = [0] * (k)\netalon = gifts[0]\nfor g in gifts:\n    if g == etalon:\n        equal_classes[g] += 1\n    else:\n        etalon = g\n        equal_classes[g] += 1\nans = equal_classes[0] - equal_classes[0] % 2\nif (k - 1) % 2 == 1:\n    equal_classes[k\/\/2] = equal_classes[k\/\/2] - equal_classes[k\/\/2] % 2\nfor i in range(1, k):\n    ans += min(equal_classes[i], equal_classes[k - i])\nprint(ans)","tags":["number theory","math"],"src_uid":"3f3a013cedaaf8cbee0a74a4ed50f09d"}
{"text_full":"[DESCRIPTION]You are given n × m table. Each cell of the table is colored white or black. Find the number of non-empty sets of cells such that:  All cells in a set have the same color.  Every two cells in a set share row or column.[SOURCE CODE]n,m = map(int, raw_input().split(\" \"))\na =[]\nfor i in range(n):\n    b = map(int, raw_input().split(\" \"))\n    a.append(b)\nans=0\nfor i in range(n):\n    d={1:0, 0:0}\n    for j in a[i]:\n        if j==0:\n            d[0]+=1\n        else:\n            d[1]+=1\n    ans+=pow(2,d[0])-1\n    ans+=pow(2,d[1])-1\nc =[[] for i in range(m)]\nfor i in range(m):\n    for j in range(n):\n        c[i].append(a[j][i])\nfor i in range(m):\n    d={1:0, 0:0}\n    for j in c[i]:\n        if j==0:\n            d[0]+=1\n        else:\n            d[1]+=1\n    ans+=pow(2,d[0])-1\n    ans+=pow(2,d[1])-1\nans-=(n*m)\nprint ans","tags":["math"],"src_uid":"3b7cafc280a9b0dba567863c80b978b0"}
{"text_full":"[DESCRIPTION]The letters shop showcase is a string $$$s$$$, consisting of $$$n$$$ lowercase Latin letters. As the name tells, letters are sold in the shop.Letters are sold one by one from the leftmost to the rightmost. Any customer can only buy some prefix of letters from the string $$$s$$$.There are $$$m$$$ friends, the $$$i$$$-th of them is named $$$t_i$$$. Each of them is planning to estimate the following value: how many letters (the length of the shortest prefix) would s\/he need to buy if s\/he wanted to construct her\/his name of bought letters. The name can be constructed if each letter is presented in the equal or greater amount.  For example, for $$$s$$$=\"arrayhead\" and $$$t_i$$$=\"arya\" $$$5$$$ letters have to be bought (\"arrayhead\").  For example, for $$$s$$$=\"arrayhead\" and $$$t_i$$$=\"harry\" $$$6$$$ letters have to be bought (\"arrayhead\").  For example, for $$$s$$$=\"arrayhead\" and $$$t_i$$$=\"ray\" $$$5$$$ letters have to be bought (\"arrayhead\").  For example, for $$$s$$$=\"arrayhead\" and $$$t_i$$$=\"r\" $$$2$$$ letters have to be bought (\"arrayhead\").  For example, for $$$s$$$=\"arrayhead\" and $$$t_i$$$=\"areahydra\" all $$$9$$$ letters have to be bought (\"arrayhead\"). It is guaranteed that every friend can construct her\/his name using the letters from the string $$$s$$$.Note that the values for friends are independent, friends are only estimating them but not actually buying the letters.[SOURCE CODE]n=int(input())\ns=str(input())\nf=int(input())\nd={}\nfor i in range(n):\n\tif s[i] not in d:\n\t\td[s[i]]=[i]\n\telse:\n\t\td[s[i]].append(i)\nfor i in range(f):\n\tc=str(input())\n\th={}\n\tm=0\n\tfor j in range(len(c)):\n\t\tif(c[j] not in h):\n\t\t\th[c[j]]=1\n\t\t\tif(d[c[j]][0]>m):\n\t\t\t\tm=d[c[j]][0]\n\t\telse:\n\t\t\tif(d[c[j]][h[c[j]]]>m):\n\t\t\t\tm=d[c[j]][h[c[j]]]\n\t\t\t\th[c[j]]=h[c[j]]+1\n\t\t\telse:\n\t\t\t\th[c[j]]=h[c[j]]+1\n\tprint(m+1)","tags":["strings"],"src_uid":"8736df815ea0fdf390cc8d500758bf84"}
{"text_full":"[DESCRIPTION]This is an easier version of the problem. In this version, $$$n \\le 2000$$$.There are $$$n$$$ distinct points in three-dimensional space numbered from $$$1$$$ to $$$n$$$. The $$$i$$$-th point has coordinates $$$(x_i, y_i, z_i)$$$. The number of points $$$n$$$ is even.You'd like to remove all $$$n$$$ points using a sequence of $$$\\frac{n}{2}$$$ snaps. In one snap, you can remove any two points $$$a$$$ and $$$b$$$ that have not been removed yet and form a perfectly balanced pair. A pair of points $$$a$$$ and $$$b$$$ is perfectly balanced if no other point $$$c$$$ (that has not been removed yet) lies within the axis-aligned minimum bounding box of points $$$a$$$ and $$$b$$$.Formally, point $$$c$$$ lies within the axis-aligned minimum bounding box of points $$$a$$$ and $$$b$$$ if and only if $$$\\min(x_a, x_b) \\le x_c \\le \\max(x_a, x_b)$$$, $$$\\min(y_a, y_b) \\le y_c \\le \\max(y_a, y_b)$$$, and $$$\\min(z_a, z_b) \\le z_c \\le \\max(z_a, z_b)$$$. Note that the bounding box might be degenerate. Find a way to remove all points in $$$\\frac{n}{2}$$$ snaps.[SOURCE CODE]#from bisect import bisect_left as bl                #c++ lowerbound bl(array,element)\n#from bisect import bisect_right as br               #c++ upperbound br(array,element)\n#from __future__ import print_function, division    #while using python2\n\nimport math\ndef modinv(n,p):\n    return pow(n,p-2,p)\n\ndef dist(x1, y1, z1, x2, y2, z2):\n    # return math.sqrt((x2-x1)**2 + (y2-y1)**2 + (z2-z1)**2)\n    return abs(x2 - x1) + abs(y2 - y1) + abs(z2 - z1)\n\ndef main():\n    #sys.stdin = open('input.txt', 'r')\n    #sys.stdout = open('output.txt', 'w')\n\n    n = int(input())\n    points = []\n    for i in range(n):\n        pts = [int(x) for x in input().split()]\n        pts.append(i)\n        points.append(pts)\n    \n    answers = []\n    visited = [0] * (n+1)\n    # print(points)\n    for i in range(n):\n        if visited[i] == 1:\n            continue\n        min_d = 1e18\n        min_j = -1\n        x1, y1, z1, temp = points[i]\n        for j in range(i+1,n):\n            if visited[j] == 1:\n                continue\n            x2, y2, z2, temp2 = points[j]\n            if dist(x1, y1, z1, x2, y2, z2) < min_d:\n                min_d = dist(x1, y1, z1, x2, y2, z2)\n                min_j = j\n        \n        if min_j != -1:\n            answers.append([points[i][-1], points[min_j][-1]])\n            visited[points[i][-1]] = 1\n            visited[points[min_j][-1]] = 1\n    # print(answers)\n    for p in answers:\n        print(p[0] + 1, p[1] + 1)\n\n#------------------ Python 2 and 3 footer by Pajenegod and c1729-----------------------------------------\npy2 = round(0.5)\nif py2:\n    from future_builtins import ascii, filter, hex, map, oct, zip\n    range = xrange\n\nimport os, sys\nfrom io import IOBase, BytesIO\n\nBUFSIZE = 8192\nclass FastIO(BytesIO):\n    newlines = 0\n    def __init__(self, file):\n        self._file = file\n        self._fd = file.fileno()\n        self.writable = \"x\" in file.mode or \"w\" in file.mode\n        self.write = super(FastIO, self).write if self.writable else None\n\n    def _fill(self):\n        s = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n        self.seek((self.tell(), self.seek(0,2), super(FastIO, self).write(s))[0])\n        return s\n    def read(self):\n        while self._fill(): pass\n        return super(FastIO,self).read()\n\n    def readline(self):\n        while self.newlines == 0:\n            s = self._fill(); self.newlines = s.count(b\"\\n\") + (not s)\n        self.newlines -= 1\n        return super(FastIO, self).readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.getvalue())\n            self.truncate(0), self.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        if py2:\n            self.write = self.buffer.write\n            self.read = self.buffer.read\n            self.readline = self.buffer.readline\n        else:\n            self.write = lambda s:self.buffer.write(s.encode('ascii'))\n            self.read = lambda:self.buffer.read().decode('ascii')\n            self.readline = lambda:self.buffer.readline().decode('ascii')\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n')\n\nif __name__ == '__main__':\n   main()","tags":["geometry"],"src_uid":"47a9d72651f1407de89e28fb4b142367"}
{"text_full":"[DESCRIPTION]You are given string s consists of opening and closing brackets of four kinds &lt;&gt;, {}, [], (). There are two types of brackets: opening and closing. You can replace any bracket by another of the same type. For example, you can replace &lt; by the bracket {, but you can't replace it by ) or &gt;.The following definition of a regular bracket sequence is well-known, so you can be familiar with it.Let's define a regular bracket sequence (RBS). Empty string is RBS. Let s1 and s2 be a RBS then the strings &lt;s1&gt;s2, {s1}s2, [s1]s2, (s1)s2 are also RBS.For example the string \"[[(){}]&lt;&gt;]\" is RBS, but the strings \"[)()\" and \"][()()\" are not.Determine the least number of replaces to make the string s RBS.[SOURCE CODE]k, s = 0, []\n\nfor q in input():\n\n    i = '[{<(]}>)'.find(q)\n\n    if i > 3:\n\n        if not s:\n\n            s = 1\n\n            break\n\n        if s.pop() != i - 4: k += 1\n\n    else: s += [i]\n\nprint('Impossible' if s else k)\n\n\n\n\n# Made By Mostafa_Khaled","tags":["math"],"src_uid":"4147fef7a151c52e92c010915b12c06b"}
{"text_full":"[DESCRIPTION]New Year is coming and you are excited to know how many minutes remain before the New Year. You know that currently the clock shows $$$h$$$ hours and $$$m$$$ minutes, where $$$0 \\le hh &lt; 24$$$ and $$$0 \\le mm &lt; 60$$$. We use 24-hour time format!Your task is to find the number of minutes before the New Year. You know that New Year comes when the clock shows $$$0$$$ hours and $$$0$$$ minutes.You have to answer $$$t$$$ independent test cases.[SOURCE CODE]testCase = int(input())\nOutput = 0\nwhile testCase != 0:\n   H, Min = map(int, input().split())\n   if 0 <= H < 24 and 0 <= Min < 60:\n       Output = ((23-H) * 60) + (60 - Min)\n       print(Output)\n   testCase = testCase - 1","tags":["math"],"src_uid":"f4982de28aca7080342eb1d0ff87734c"}
{"text_full":"[DESCRIPTION]You are playing a game where your character should overcome different obstacles. The current problem is to come down from a cliff. The cliff has height $$$h$$$, and there is a moving platform on each height $$$x$$$ from $$$1$$$ to $$$h$$$.Each platform is either hidden inside the cliff or moved out. At first, there are $$$n$$$ moved out platforms on heights $$$p_1, p_2, \\dots, p_n$$$. The platform on height $$$h$$$ is moved out (and the character is initially standing there).If you character is standing on some moved out platform on height $$$x$$$, then he can pull a special lever, which switches the state of two platforms: on height $$$x$$$ and $$$x - 1$$$. In other words, the platform you are currently standing on will hide in the cliff and the platform one unit below will change it state: it will hide if it was moved out or move out if it was hidden. In the second case, you will safely land on it. Note that this is the only way to move from one platform to another.Your character is quite fragile, so it can safely fall from the height no more than $$$2$$$. In other words falling from the platform $$$x$$$ to platform $$$x - 2$$$ is okay, but falling from $$$x$$$ to $$$x - 3$$$ (or lower) is certain death. Sometimes it's not possible to come down from the cliff, but you can always buy (for donate currency) several magic crystals. Each magic crystal can be used to change the state of any single platform (except platform on height $$$h$$$, which is unaffected by the crystals). After being used, the crystal disappears.What is the minimum number of magic crystal you need to buy to safely land on the $$$0$$$ ground level?[SOURCE CODE]#!\/usr\/bin\/env pypy\nfrom __future__ import division, print_function\nfrom collections import defaultdict, Counter, deque\nfrom future_builtins import ascii, filter, hex, map, oct, zip\nfrom random import randint\nfrom itertools import imap as map, izip as zip, permutations, combinations, combinations_with_replacement\nfrom __builtin__ import xrange as range\nfrom math import ceil\nfrom _continuation import continulet\nfrom cStringIO import StringIO\nfrom io import IOBase\nimport __pypy__\nfrom bisect import bisect, insort, bisect_left, bisect_right\nimport sys\nimport os\nimport re\nsys.setrecursionlimit(9999)\ninf = float('inf')\nmod = int(1e9) + 7\nmod_ = 998244353\nN = 5001\n\n'''\nCheck for special cases (n=1)\nOne wrong submission = 10 mins penalty!\ndo smth instead of nothing and stay organized\n'''\n\n\ndef main():\n\tfor _ in range(int(input())):\n\t\th, n = map(int, input().split())\n\t\tarr = list(set(map(int, input().split())))\n\t\tif n == 1:\n\t\t\tprint(0)\n\t\t\tcontinue\n\t\tcnt = 0\n\t\tind = 0\n\t\twhile arr[ind] > 2:\n\t\t\tgap = arr[ind]-arr[ind+1]\n\t\t\t# if gap == 2:\n\t\t\t# \tind += 1\n\t\t\t# else:\n\t\t\tarr[ind] = arr[ind+1]+1\n\t\t\tif ind+2 > n-1:\n\t\t\t\tif arr[ind] > 2 and arr[ind+1]+1 > 2:\n\t\t\t\t\tcnt += 1\n\t\t\t\tbreak\n\t\t\tif arr[ind]-arr[ind+2] > 2:\n\t\t\t\tarr[ind+1] = arr[ind+2]+1\n\t\t\t\tcnt += 1\n\t\t\t\tind += 1\n\t\t\telse:\n\t\t\t\tind += 2\n\t\t\tif ind+1 > n-1 or arr[ind] <= 2:\n\t\t\t\tbreak\n\t\t# print(arr)\n\t\tprint(cnt)\n\n\n\n\nBUFSIZE = 8192\nclass FastI(IOBase):\n\tdef __init__(self, file):\n\t\tself._fd = file.fileno()\n\t\tself._buffer = StringIO()\n\t\tself.newlines = 0\n \n\tdef read(self):\n\t\twhile True:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tif not b:\n\t\t\t\tbreak\n\t\t\tptr = self.buffer.tell()\n\t\t\tself.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n\t\tself.newlines = 0\n\t\treturn self.buffer.read()\n \n\tdef readline(self):\n\t\twhile self.newlines == 0:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tself.newlines = b.count(\"\\n\") + (not b)\n\t\t\tptr = self._buffer.tell()\n\t\t\tself._buffer.seek(0, 2), self._buffer.write(\n\t\t\t\tb), self._buffer.seek(ptr)\n\t\tself.newlines -= 1\n\t\treturn self._buffer.readline()\nclass FastO(IOBase):\n\tdef __init__(self, file):\n\t\tself._fd = file.fileno()\n\t\tself._buffer = __pypy__.builders.StringBuilder()\n\t\tself.write = lambda s: self._buffer.append(s)\n \n\tdef flush(self):\n\t\tos.write(self._fd, self._buffer.build())\n\t\tself._buffer = __pypy__.builders.StringBuilder()\ndef print(*args, **kwargs):\n\tsep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n\tat_start = True\n\tfor x in args:\n\t\tif not at_start:\n\t\t\tfile.write(sep)\n\t\tfile.write(str(x))\n\t\tat_start = False\n\tfile.write(kwargs.pop(\"end\", \"\\n\"))\n\tif kwargs.pop(\"flush\", False):\n\t\tfile.flush()\ndef gcd(x, y):\n\twhile y:\n\t\tx, y = y, x % y\n\treturn x\nsys.stdin, sys.stdout = FastI(sys.stdin), FastO(sys.stdout)\ndef input(): return sys.stdin.readline().rstrip(\"\\r\\n\")\nif __name__ == \"__main__\":\n\tdef bootstrap(cont):\n\t\tcall, arg = cont.switch()\n\t\twhile True:\n\t\t\tcall, arg = cont.switch(to=continulet(\n\t\t\t\tlambda _, f, args: f(*args), call, arg))\n\tcont = continulet(bootstrap)\n\tcont.switch()\n\tmain()","tags":["math"],"src_uid":"d0c50562764f2008045fe57e5da5de1c"}
{"text_full":"[DESCRIPTION]One day Bob got a letter in an envelope. Bob knows that when Berland's post officers send a letter directly from city «A» to city «B», they stamp it with «A B», or «B A». Unfortunately, often it is impossible to send a letter directly from the city of the sender to the city of the receiver, that's why the letter is sent via some intermediate cities. Post officers never send a letter in such a way that the route of this letter contains some city more than once. Bob is sure that the post officers stamp the letters accurately.There are n stamps on the envelope of Bob's letter. He understands that the possible routes of this letter are only two. But the stamps are numerous, and Bob can't determine himself none of these routes. That's why he asks you to help him. Find one of the possible routes of the letter.[SOURCE CODE]from collections import defaultdict, Counter\n\nclass Solution:\n    def __init__(self):\n        pass\n\n    def solve_and_print(self):\n        d, c = defaultdict(int), []\n        for _ in range(int(input())):\n            x, y = [int(x) for x in input().split()]\n            c += [x, y]\n            d[x] += y\n            d[y] += x\n        a, b = [q for q, k in Counter(c).items() if k == 1]\n        q = 0\n        while a != b:\n            print(a, end=' ')\n            q, a = a, d[a] - q\n        print(a, end=' ')\n\nif __name__ == \"__main__\":\n    Solution().solve_and_print()","tags":["graphs"],"src_uid":"4c9d3e560f1ea152259ec838879b7512"}
{"text_full":"[DESCRIPTION]You are given two integers $$$x$$$ and $$$y$$$ (it is guaranteed that $$$x &gt; y$$$). You may choose any prime integer $$$p$$$ and subtract it any number of times from $$$x$$$. Is it possible to make $$$x$$$ equal to $$$y$$$?Recall that a prime number is a positive integer that has exactly two positive divisors: $$$1$$$ and this integer itself. The sequence of prime numbers starts with $$$2$$$, $$$3$$$, $$$5$$$, $$$7$$$, $$$11$$$.Your program should solve $$$t$$$ independent test cases.[SOURCE CODE]t=int(input())\nfor i in range(t):\n    s=input()\n    s=s.split( )\n    for e in s:\n        s[s.index(e)]=int(e)\n    if s[0]-s[1]<2:\n        print('NO')\n    elif ((s[0]-s[1])%2)==0 :\n        print('YES')\n    elif (s[0]-s[1]-3) >=0:\n        print('YES')\n    else:\n        print('NO')","tags":["number theory","math"],"src_uid":"0671972bc2b6452d51d048329e6e0106"}
{"text_full":"[DESCRIPTION]You are given n points on Cartesian plane. Every point is a lattice point (i. e. both of its coordinates are integers), and all points are distinct.You may draw two straight lines (not necessarily distinct). Is it possible to do this in such a way that every point lies on at least one of these lines?[SOURCE CODE]from __future__ import division\nimport sys\nn = int(raw_input())\nif n <= 4:\n  print \"YES\"\n  sys.exit()\npts = []\nfor i in range(n):\n  pts.append(list(map(int,raw_input().split())))\n\ndef solve(c1, c2):\n  taken = [0 for x in range(n)]\n  ext = []\n  for i in range(n):\n    if (pts[c2][1]-pts[c1][1])*(pts[i][0]-pts[c2][0])==(pts[i][1]-pts[c2][1])*(pts[c2][0]-pts[c1][0]):\n      taken[i] = 1\n    if not taken[i]:\n      ext.append(i)\n  if len(ext) <= 2:\n    return 1\n  c1 = ext[0]\n  c2 = ext[1]\n  for i in range(n):\n    if (pts[c2][1]-pts[c1][1])*(pts[i][0]-pts[c2][0])==(pts[i][1]-pts[c2][1])*(pts[c2][0]-pts[c1][0]):\n      taken[i] = 1\n  if sum(taken)==n:\n    return 1\n  return 0\n\nif solve(0,1) or solve(0,2) or solve(1,2):\n  print \"YES\"\nelse:\n  print \"NO\"","tags":["geometry"],"src_uid":"a9fd2e4bc5528a34f1f1b869cd391d71"}
{"text_full":"[DESCRIPTION]Ashish has an array $$$a$$$ of consisting of $$$2n$$$ positive integers. He wants to compress $$$a$$$ into an array $$$b$$$ of size $$$n-1$$$. To do this, he first discards exactly $$$2$$$ (any two) elements from $$$a$$$. He then performs the following operation until there are no elements left in $$$a$$$:   Remove any two elements from $$$a$$$ and append their sum to $$$b$$$. The compressed array $$$b$$$ has to have a special property. The greatest common divisor ($$$\\mathrm{gcd}$$$) of all its elements should be greater than $$$1$$$.Recall that the $$$\\mathrm{gcd}$$$ of an array of positive integers is the biggest integer that is a divisor of all integers in the array.It can be proven that it is always possible to compress array $$$a$$$ into an array $$$b$$$ of size $$$n-1$$$ such that $$$gcd(b_1, b_2..., b_{n-1}) &gt; 1$$$. Help Ashish find a way to do so.[SOURCE CODE]# cook your dish here\nT=int(input())\nfor _ in range(T):\n    n=int(input())\n    s=list(map(int,input().split()))\n    odd=[]\n    even=[]\n    for i in range(len(s)):\n        if(s[i]%2!=0):\n            odd.append(i+1)\n        else:\n            even.append(i+1)\n   \n    count=0\n    for i in range(0,len(odd)-1,2):\n        if(count<n-1):\n            print(odd[i],odd[i+1])\n            count+=1\n        else:\n            break\n    for i in range(0,len(even)-1,2):\n        if(count<n-1):\n            print(even[i],even[i+1])\n            count+=1\n        else:\n            break","tags":["number theory","math"],"src_uid":"96fac9f9377bf03e144067bf93716d3d"}
{"text_full":"[DESCRIPTION]Given a connected undirected graph with $$$n$$$ vertices and an integer $$$k$$$, you have to either:  either find an independent set that has exactly $$$\\lceil\\frac{k}{2}\\rceil$$$ vertices. or find a simple cycle of length at most $$$k$$$. An independent set is a set of vertices such that no two of them are connected by an edge. A simple cycle is a cycle that doesn't contain any vertex twice. I have a proof that for any input you can always solve at least one of these problems, but it's left as an exercise for the reader.[SOURCE CODE]L=[0]*200005\nO=[0]*200005\nF=[0]*200005\nC=[]\nczy=0\nW=[[] for _ in range(4)]\nP=[[] for _ in range(200005)]\nile=0;\ndef dfs(n,p):\n    stos=[]\n    stos.append((n,p))\n    global czy\n    while len(stos)>0:\n        n,p=stos[-1]\n        stos.pop()\n        if O[n]==1:\n            continue\n        O[n]=1\n        if L[n]<=k-1:\n            W[L[n]%2].append(n)\n        for v in P[n]:\n            #print(n,v,czy,L[n],L[v],O[v],p)\n            if  O[v]==0:\n                L[v]=L[n]+1;\n                F[v]=n\n                stos.append((v,n))\n            elif v!=p and czy==0 and L[n]>L[v] and L[n]-L[v]+1<=k:\n               # print(\"i am here\",n,v)\n                czy=1\n                x=n\n                while x!=v:\n                    C.append(x)\n                    x=F[x]\n                C.append(v)\nn,m,k=map(int,input().split())\nfor i in range(m):\n    a,b=map(int,input().split())\n    P[a].append(b)\n    P[b].append(a)\ndfs(1,0)\nif czy:\n    print(2)\n    print(len(C))\n    print(\" \".join(map(str,C)))\nelse:\n    print(1)\n    A=[]\n    if len(W[0])<len(W[1]):\n        A=W[1]\n    else:\n        A=W[0]\n    x=k\/\/2\n    if k&1:\n        x+=1\n    s=\"\"\n    for i in range(0,x):\n        s+=str(A[i])+\" \"\n    print(s)\n#threading.Thread(target=main).start()","tags":["graphs","trees"],"src_uid":"e87930c6bc4559806376b09c58e00dcc"}
{"text_full":"[DESCRIPTION]Petr likes to come up with problems about randomly generated data. This time problem is about random permutation. He decided to generate a random permutation this way: he takes identity permutation of numbers from $$$1$$$ to $$$n$$$ and then $$$3n$$$ times takes a random pair of different elements and swaps them. Alex envies Petr and tries to imitate him in all kind of things. Alex has also come up with a problem about random permutation. He generates a random permutation just like Petr but swaps elements $$$7n+1$$$ times instead of $$$3n$$$ times. Because it is more random, OK?!You somehow get a test from one of these problems and now you want to know from which one.[SOURCE CODE]n=int(input())\na=[0]+list(map(int,input().split()))\nans=0\nfor i in range(1,len(a)):\n    if a[i]==-1:\n        continue\n    j=i\n    while a[j]!=-1:\n        prev=j\n        j=a[j]\n        a[prev]=-1\n    ans+=1\nif n%2==0:\n    #n even ans also even even number of swaps required\n    #3*n \n    if ans%2==0:\n        print(\"Petr\")\n    else:\n        print(\"Um_nik\")\nelse:\n    #n us odd ans is even odd number of swaps required\n    if ans%2==0:\n        print(\"Petr\")\n    else:\n        print(\"Um_nik\")","tags":["math"],"src_uid":"a9cc20ba7d6e31706ab1743bdde97669"}
{"text_full":"[DESCRIPTION]Sasha is taking part in a programming competition. In one of the problems she should check if some rooted trees are isomorphic or not. She has never seen this problem before, but, being an experienced participant, she guessed that she should match trees to some sequences and then compare these sequences instead of trees. Sasha wants to match each tree with a sequence a0, a1, ..., ah, where h is the height of the tree, and ai equals to the number of vertices that are at distance of i edges from root. Unfortunately, this time Sasha's intuition was wrong, and there could be several trees matching the same sequence. To show it, you need to write a program that, given the sequence ai, builds two non-isomorphic rooted trees that match that sequence, or determines that there is only one such tree.Two rooted trees are isomorphic, if you can reenumerate the vertices of the first one in such a way, that the index of the root becomes equal the index of the root of the second tree, and these two trees become equal.The height of a rooted tree is the maximum number of edges on a path from the root to any other vertex.[SOURCE CODE]#!\/usr\/bin\/env python\nfrom __future__ import division, print_function\n\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\nif sys.version_info[0] < 3:\n    from __builtin__ import xrange as range\n    from future_builtins import ascii, filter, hex, map, oct, zip\n\n\ndef main():\n    h = int(input())\n    a = [int(i) for i in input().split()]\n\n    perfect = True\n    no = True\n    for i in a:\n        if no and i != 1:\n            perfect = False\n            break\n        if no:\n            no = False\n        if i != 1:\n            no = True\n\n    if perfect:\n        print(\"perfect\")\n        return\n\n    sol1 = [-1] * sum(a)\n    curr = 0\n    prev = 0\n\n    for i in a:\n        for j in range(i):\n            sol1[curr + j] = prev\n        prev += i\n        curr += i\n\n    sol2 = [-1] * sum(a)\n    curr = 0\n    prev = 0\n\n    for i in a:\n        for j in range(i):\n            if j == 1:\n                prev = curr\n            sol2[curr + j] = prev\n        prev = curr\n        prev += 1\n        curr += i\n\n    print(\"ambiguous\")\n    print(*sol1)\n    print(*sol2)\n\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\n\nif __name__ == \"__main__\":\n    main()","tags":["trees"],"src_uid":"a186acbdc88a7ed131a7e5f999877fd6"}
{"text_full":"[DESCRIPTION]After learning about polynomial hashing, Heidi decided to learn about shift-xor hashing. In particular, she came across this interesting problem.Given a bitstring $$$y \\in \\{0,1\\}^n$$$ find out the number of different $$$k$$$ ($$$0 \\leq k &lt; n$$$) such that there exists $$$x \\in \\{0,1\\}^n$$$ for which $$$y = x \\oplus \\mbox{shift}^k(x).$$$In the above, $$$\\oplus$$$ is the xor operation and $$$\\mbox{shift}^k$$$ is the operation of shifting a bitstring cyclically to the right $$$k$$$ times. For example, $$$001 \\oplus 111 = 110$$$ and $$$\\mbox{shift}^3(00010010111000) = 00000010010111$$$.[SOURCE CODE]import sys\nrange = xrange\n\nn = int(raw_input())\ny = [int(x) for x in raw_input()]\ndef poss(k):\n    x = [0]*n\n    for i in range(n-k):\n        x[i + k] = x[i] ^ y[i]\n    for i in range(n-k,n):\n        if x[i] ^ x[i + k - n] != y[i]:\n            return 0\n    return 1\npossible = [0]*(n+1)\ni = 1\nwhile i * i < n:\n    if n % i == 0:\n        possible[i] = poss(i)\n        possible[n\/\/i] = poss(n\/\/i)\n    i += 1\nif i * i == n:\n    possible[i] = poss(i)\ndef gcd(a,b):\n    while b:\n        a,b = b,a%b\n    return a\nans = 0\nfor k in range(1, n+1):\n    ans += possible[gcd(n,k)]\nprint(ans)","tags":["number theory"],"src_uid":"cf7cd545a48b050354ae786a263e2847"}
{"text_full":"[DESCRIPTION]You are given an undirected weighted connected graph with $$$n$$$ vertices and $$$m$$$ edges without loops and multiple edges.The $$$i$$$-th edge is $$$e_i = (u_i, v_i, w_i)$$$; the distance between vertices $$$u_i$$$ and $$$v_i$$$ along the edge $$$e_i$$$ is $$$w_i$$$ ($$$1 \\le w_i$$$). The graph is connected, i. e. for any pair of vertices, there is at least one path between them consisting only of edges of the given graph.A minimum spanning tree (MST) in case of positive weights is a subset of the edges of a connected weighted undirected graph that connects all the vertices together and has minimum total cost among all such subsets (total cost is the sum of costs of chosen edges).You can modify the given graph. The only operation you can perform is the following: increase the weight of some edge by $$$1$$$. You can increase the weight of each edge multiple (possibly, zero) times.Suppose that the initial MST cost is $$$k$$$. Your problem is to increase weights of some edges with minimum possible number of operations in such a way that the cost of MST in the obtained graph remains $$$k$$$, but MST is unique (it means that there is only one way to choose MST in the obtained graph).Your problem is to calculate the minimum number of operations required to do it.[SOURCE CODE]import sys\ninput = sys.stdin.readline\n\nn,m=map(int,input().split())\nEDGE=[list(map(int,input().split())) for i in range(m)]\n\nEDGE.sort(key=lambda x:x[2])\n\nWCHANGE=[]\nfor i in range(1,m):\n    if EDGE[i-1][2]!=EDGE[i][2]:\n        WCHANGE.append(i)\n\nWCHANGE.append(m)\n\nGroup=[i for i in range(n+1)]\n\ndef find(x):\n    while Group[x] != x:\n        x=Group[x]\n    return x\n\ndef Union(x,y):\n    if find(x) != find(y):\n        Group[find(y)]=Group[find(x)]=min(find(y),find(x))\n\n\nNOW=0\nnoneed=[0]*m\nANS=0\nfor wc in WCHANGE:\n    for j in range(NOW,wc):\n\n        if find(EDGE[j][0])==find(EDGE[j][1]):\n            noneed[j]=1\n\n    for j in range(NOW,wc):\n        if noneed[j]==1:\n            continue      \n        x,y,w=EDGE[j]\n        if find(x)!=find(y):\n            Union(x,y)\n        else:\n            ANS+=1\n\n    NOW=wc\n\nprint(ANS)","tags":["graphs"],"src_uid":"92afa6f770493109facb1b9ca8d94e0c"}
{"text_full":"[DESCRIPTION]Alyona has a tree with n vertices. The root of the tree is the vertex 1. In each vertex Alyona wrote an positive integer, in the vertex i she wrote ai. Moreover, the girl wrote a positive integer to every edge of the tree (possibly, different integers on different edges).Let's define dist(v, u) as the sum of the integers written on the edges of the simple path from v to u.The vertex v controls the vertex u (v ≠ u) if and only if u is in the subtree of v and dist(v, u) ≤ au.Alyona wants to settle in some vertex. In order to do this, she wants to know for each vertex v what is the number of vertices u such that v controls u.[SOURCE CODE]import sys\nimport threading\nfrom bisect import bisect_left\n\nn   = int(input())\na   = list(map(int, input().split()))\ne   = {}\ng   = [[] for i in range(n)]\nd   = [0]*(n+5)\nans = [0]*n\np   = [0]*(n+5)\n\nfor i in range(n-1):\n        c, w = map(int, input().split())\n        c-= 1\n        g[c].append(i+1)\n        e[i+1] = w\n\ndef dfs(i, h):\n    global ans, a, e, g, d, p\n    p[h]=0\n    for j in g[i]:\n        d[h+1] = d[h]+e[j] \n        dfs(j, h+1)\n    x = bisect_left(d, d[h]-a[i], 0, h+1)\n    #print(x-1, i, h, d[h], d[h], a[i])\n    if x>=0:\n        p[x-1]-=1\n    p[h-1]+=p[h]+1\n    ans[i]=p[h]\n\n\n\ndef solve():  \n    global ans\n    dfs(0, 0)\n    print(' '.join(map(str, ans)))\n\nmax_recur_size = 10**5*2 + 1000\nmax_stack_size = max_recur_size*500\nsys.setrecursionlimit(max_recur_size)\nthreading.stack_size(max_stack_size)\nthread = threading.Thread(target=solve)\nthread.start()","tags":["graphs","trees"],"src_uid":"5a146d9d360228313006d54cd5ca56ec"}
{"text_full":"[DESCRIPTION]Caisa is now at home and his son has a simple task for him.Given a rooted tree with n vertices, numbered from 1 to n (vertex 1 is the root). Each vertex of the tree has a value. You should answer q queries. Each query is one of the following:  Format of the query is \"1 v\". Let's write out the sequence of vertices along the path from the root to vertex v: u1, u2, ..., uk (u1 = 1; uk = v). You need to output such a vertex ui that gcd(value of ui, value of v) &gt; 1 and i &lt; k. If there are several possible vertices ui pick the one with maximum value of i. If there is no such vertex output -1.  Format of the query is \"2 v w\". You must change the value of vertex v to w. You are given all the queries, help Caisa to solve the problem.[SOURCE CODE]from sys import stdin, setrecursionlimit\nsetrecursionlimit(1000000007)\n_data = iter(map(int, stdin.read().split()))\nV = 2100000\nn, q = next(_data), next(_data)\na = [next(_data) for _ in range(n)]\ng = [[] for _ in range(n)]\nfor _ in range(n - 1):\n    u, v = next(_data) - 1, next(_data) - 1\n    g[u].append(v)\n    g[v].append(u)\n\nfss = [[] for _ in range(V)]\ndef factors(k):\n    if fss[k]:\n        return fss[k]\n    i = 2\n    t = []\n    v = k\n    while i * i <= v:\n        if v % i == 0:\n            t.append(i)\n            while v % i == 0:\n                v \/\/= i\n        i += 1\n    if v != 1:\n        t.append(v)\n    fss[k] = t\n    return t\n\ndepth = [0] * n\ndef init_depth():\n    st = [(0, 0, 0)]\n    while st:\n        v, p, d = st.pop()\n        depth[v] = d\n        for u in g[v]:\n            if u != p:\n                st.append((u, v, d + 1))\n    \nans = [-2] * n\nscope = [[] for _ in range(V)]\ndef make():\n    st = [(0, 0)]\n    while st:\n        v, p = st.pop()\n        if v < n:\n            st.append((v + n, -1))\n            r = (-2, -2)\n            for d in factors(a[v]):\n                if scope[d]:\n                    u = scope[d][-1]\n                    r = max(r, (depth[u], u))\n                scope[d].append(v)\n            ans[v] = r[1]\n            for u in g[v]:\n                if u != p:\n                    st.append((u, v))\n        elif v >= n:\n            v -= n\n            for d in factors(a[v]):\n                scope[d].pop()\nbuf = []\ninit_depth()\nmake()\nfor _ in range(q):\n    t = next(_data)\n    if t == 1:\n        v = next(_data) - 1\n        buf.append(ans[v] + 1)\n    elif t == 2:\n        v = next(_data) - 1\n        x = next(_data)\n        a[v] = x\n        make()\n    else:\n        assert False\nprint('\\n'.join(map(str, buf)))","tags":["number theory","math","trees"],"src_uid":"f2988e4961231b9b38ca8fa78373913f"}
{"text_full":"[DESCRIPTION]You are given a Young diagram. Given diagram is a histogram with $$$n$$$ columns of lengths $$$a_1, a_2, \\ldots, a_n$$$ ($$$a_1 \\geq a_2 \\geq \\ldots \\geq a_n \\geq 1$$$).    Young diagram for $$$a=[3,2,2,2,1]$$$. Your goal is to find the largest number of non-overlapping dominos that you can draw inside of this histogram, a domino is a $$$1 \\times 2$$$ or $$$2 \\times 1$$$ rectangle.[SOURCE CODE]from sys import stdin,stdout\n\nn = int(stdin.readline().strip())\nalist = list(map(int,stdin.readline().split()))\nk = max(alist)\ntotal,odd,even = 0,0,0\nfor i,a in enumerate(alist):\n    total += a\/\/2\n    if a%2:\n        if i%2:\n            odd+=1\n        else:\n            even+=1\ntotal+=min(odd,even)\nprint(total)","tags":["math"],"src_uid":"6ac3246ee9cf78d81f96a3ed05b35918"}
{"text_full":"[DESCRIPTION]Tomorrow is a difficult day for Polycarp: he has to attend $$$a$$$ lectures and $$$b$$$ practical classes at the university! Since Polycarp is a diligent student, he is going to attend all of them.While preparing for the university, Polycarp wonders whether he can take enough writing implements to write all of the lectures and draw everything he has to during all of the practical classes. Polycarp writes lectures using a pen (he can't use a pencil to write lectures!); he can write down $$$c$$$ lectures using one pen, and after that it runs out of ink. During practical classes Polycarp draws blueprints with a pencil (he can't use a pen to draw blueprints!); one pencil is enough to draw all blueprints during $$$d$$$ practical classes, after which it is unusable.Polycarp's pencilcase can hold no more than $$$k$$$ writing implements, so if Polycarp wants to take $$$x$$$ pens and $$$y$$$ pencils, they will fit in the pencilcase if and only if $$$x + y \\le k$$$.Now Polycarp wants to know how many pens and pencils should he take. Help him to determine it, or tell that his pencilcase doesn't have enough room for all the implements he needs tomorrow!Note that you don't have to minimize the number of writing implements (though their total number must not exceed $$$k$$$).[SOURCE CODE]n = int(input())\nfor i in range(n):\n  a, b, c, d, k = map(int, input().strip().split())\n  from math import ceil \n  n = ceil(a \/ c)\n  m = ceil(b \/ d)\n  if (n + m <= k):\n    print(n, m)\n  else:\n    print(-1)","tags":["math"],"src_uid":"17cf2d6f59773925b228188b5a47b710"}
{"text_full":"[DESCRIPTION]Today is tuesday, that means there is a dispute in JOHNNY SOLVING team again: they try to understand who is Johnny and who is Solving. That's why guys asked Umnik to help them. Umnik gave guys a connected graph with $$$n$$$ vertices without loops and multiedges, such that a degree of any vertex is at least $$$3$$$, and also he gave a number $$$1 \\leq k \\leq n$$$. Because Johnny is not too smart, he promised to find a simple path with length at least $$$\\frac{n}{k}$$$ in the graph. In reply, Solving promised to find $$$k$$$ simple by vertices cycles with representatives, such that:   Length of each cycle is at least $$$3$$$.  Length of each cycle is not divisible by $$$3$$$.  In each cycle must be a representative - vertex, which belongs only to this cycle among all printed cycles. You need to help guys resolve the dispute, for that you need to find a solution for Johnny: a simple path with length at least $$$\\frac{n}{k}$$$ ($$$n$$$ is not necessarily divided by $$$k$$$), or solution for Solving: $$$k$$$ cycles that satisfy all the conditions above. If there is no any solution - print $$$-1$$$.[SOURCE CODE]import sys\nrange = xrange\ninput = raw_input\n\n# Will extremly quickly convert s into a list of integers.\n# The format of the string is required to be integers (positive or negative)\n# separated with a single character with ascii value <'-', so like a whitespace.\n# It also handles the string ending with an additional character < '-', like a trailing newline.\n\ns = sys.stdin.read()\ninp = []\nnumb = 0\n \nfor i in range(len(s)):\n    if s[i]>='0':\n        numb = 10*numb + ord(s[i])-48\n    else:\n        inp.append(numb)\n        numb = 0\nif s[-1]>='0':\n    inp.append(numb)\n\nii = 0\nn = inp[ii]\nii+=1\nm = inp[ii]\nii+=1\nk = inp[ii]\nii+=1\n\ncoupl = [[] for _ in range(n)]\nfor _ in range(m):\n    u = inp[ii]-1\n    ii += 1\n    v = inp[ii]-1\n    ii += 1\n\n    coupl[u].append(v)\n    coupl[v].append(u)\n\nP = [-1]*n\nD = [1]*n\nfound = [False]*n\n\ncycle_nodes = []\n\nQ = [0]\nwhile Q:\n    node = Q.pop()\n    if found[node]:\n        continue\n    found[node] = True\n    found_any = False\n    for nei in coupl[node]:\n        if not found[nei]:\n            P[nei] = node\n            D[nei] = D[node]+1\n            Q.append(nei)\n            found_any = True\n    if not found_any:\n        cycle_nodes.append(node)\n\ni = max(range(n),key=lambda i:D[i])\nif k*D[i]>=n:\n    print 'PATH'\n    print D[i]\n    out = []\n    while i!=-1:\n        out.append(i)\n        i = P[i]\n    print ' '.join(str(x+1) for x in out)\nelif len(cycle_nodes)>=k:\n    print 'CYCLES'\n    out = []\n    for i in cycle_nodes[:k]:\n        minD = min(D[nei] for nei in coupl[i] if (D[i] - D[nei] + 1)%3!=0) \n        tmp = []\n        if minD == D[i]-1:\n            a,b = [nei for nei in coupl[i] if (D[i] - D[nei] + 1)%3==0][:2]\n            if D[a]<D[b]:\n                a,b = b,a\n            tmp.append(i)\n            while a!=b:\n                tmp.append(a)\n                a = P[a]\n            tmp.append(a)\n        else:\n            while D[i]!=minD:\n                tmp.append(i)\n                i = P[i]\n            tmp.append(i)\n        out.append(str(len(tmp)))\n        out.append(' '.join(str(x+1) for x in tmp))\n    print '\\n'.join(out)\nelse:\n    print -1","tags":["graphs","math"],"src_uid":"2136f0aed9da00c3f991235f5074f71e"}
{"text_full":"[DESCRIPTION]For an array $$$a$$$ of integers let's denote its maximal element as $$$\\max(a)$$$, and minimal as $$$\\min(a)$$$. We will call an array $$$a$$$ of $$$k$$$ integers interesting if $$$\\max(a) - \\min(a) \\ge k$$$. For example, array $$$[1, 3, 4, 3]$$$ isn't interesting as $$$\\max(a) - \\min(a) = 4 - 1 = 3 &lt; 4$$$ while array $$$[7, 3, 0, 4, 3]$$$ is as $$$\\max(a) - \\min(a) = 7 - 0 = 7 \\ge 5$$$.You are given an array $$$a$$$ of $$$n$$$ integers. Find some interesting nonempty subarray of $$$a$$$, or tell that it doesn't exist.An array $$$b$$$ is a subarray of an array $$$a$$$ if $$$b$$$ can be obtained from $$$a$$$ by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end. In particular, an array is a subarray of itself.[SOURCE CODE]t=int(input())\nfor o in range(t):\n    n=int(input()) \n    l=list(map(int,input().split()))  \n    flag=0\n    for i in range(n-1):\n            if abs(l[i]-l[i+1])>=2: \n                print(\"YES\")\n                print(str(i+1)+\" \"+str(i+2)) \n                flag=1 \n                break\n        \n                \n    if(flag==0):\n        print(\"NO\")","tags":["math"],"src_uid":"fa16d33fb9447eea06fcded0026c6e31"}
{"text_full":"[DESCRIPTION]Andrew, Fedor and Alex are inventive guys. Now they invent the game with strings for two players.Given a group of n non-empty strings. During the game two players build the word together, initially the word is empty. The players move in turns. On his step player must add a single letter in the end of the word, the resulting word must be prefix of at least one string from the group. A player loses if he cannot move.Andrew and Alex decided to play this game k times. The player who is the loser of the i-th game makes the first move in the (i + 1)-th game. Guys decided that the winner of all games is the player who wins the last (k-th) game. Andrew and Alex already started the game. Fedor wants to know who wins the game if both players will play optimally. Help him.[SOURCE CODE]N = 100000\nZ = 26\n\n#别用这玩意儿: trie = [[0] * Z] * N 巨坑！https:\/\/www.cnblogs.com\/PyLearn\/p\/7795552.html\n\ntrie = [[0 for i in range(Z)] for j in range(N)]\nn = 0\nk = 0\nnodeNum = 0\n\ndef insertNode():\n\tu = 0\n\tstring = input()\n\tglobal nodeNum\n\t\n\tfor i in range(len(string)):\n\t\tc = ord(string[i]) - ord('a')\n\t\tif trie[u][c] == 0:\n\t\t\tnodeNum += 1\n\t\t\ttrie[u][c] = nodeNum\t\n\t\tu = trie[u][c]\n\t\t# print(u)\n\t\nstateWin = [False for i in range(N)]\t\nstateLose = [False for i in range(N)]\t\n\t\ndef dfs(u):\n\tleaf = True\n\tfor c in range(Z):\n\t\tif (trie[u][c]) != 0:\n\t\t\tleaf = False\n\t\t\tdfs(trie[u][c])\n\t\t\tstateWin[u] |= (not(stateWin[trie[u][c]]))\n\t\t\tstateLose[u] |= (not(stateLose[trie[u][c]]))\n\tif leaf == True:\n\t\tstateWin[u] = False\n\t\tstateLose[u] = True\n\nn,k = map(int,input().split())\n\nfor i in range(n):\n\tinsertNode()\n\ndfs(0)\n\n\n# print(stateWin[0])\n# print(stateLose[0])\n\nif (stateWin[0] and (stateLose[0] or (k % 2 == 1) )):\n\tprint(\"First\")\nelse:\n\tprint(\"Second\")","tags":["games","trees","strings"],"src_uid":"2de867c08946eade5f674a98b377343d"}
{"text_full":"[DESCRIPTION]There are n points marked on the plane. The points are situated in such a way that they form a regular polygon (marked points are its vertices, and they are numbered in counter-clockwise order). You can draw n - 1 segments, each connecting any two marked points, in such a way that all points have to be connected with each other (directly or indirectly).But there are some restrictions. Firstly, some pairs of points cannot be connected directly and have to be connected undirectly. Secondly, the segments you draw must not intersect in any point apart from the marked points (that is, if any two segments intersect and their intersection is not a marked point, then the picture you have drawn is invalid).How many ways are there to connect all vertices with n - 1 segments? Two ways are considered different iff there exist some pair of points such that a segment is drawn between them in the first way of connection, but it is not drawn between these points in the second one. Since the answer might be large, output it modulo 109 + 7.[SOURCE CODE]import sys\nrange = xrange\ninput = raw_input\n\nMOD = 10**9 + 7\nINVMOD = 1.0\/MOD\nimport __pypy__\nmulmod = __pypy__.intop.int_mulmod\nsub = __pypy__.intop.int_sub\nmul = __pypy__.intop.int_mul\n\ndef mo(a,b):\n    return sub(mul(a,b), mul(MOD, int(INVMOD * a * b)))\n\n\nn = int(input())\nA = []\nfor _ in range(n):\n    A.append([int(x) for x in input().split()])\n\n# don't connect ends\nDP0 = [[-1] * n for _ in range(n)]\n# connect ends\nDP1 = [[-1] * n for _ in range(n)]\n\nfor i in range(n):\n    DP0[i][0] = 1\n    DP1[i][0] = 1\n\nfor l in range(1, n):\n    for i in range(n):\n        Ai = A[i]\n        DP0i = DP0[i]\n        DP1i = DP1[i]\n        \n        x = 0.0 + DP1[i + 1 - n][l - 1]\n        for k in range(1, l):\n            if Ai[i + k - n]:\n                x += mo(DP0i[k], DP0[i + k - n][l - k])\n        DP0i[l] = int(int(x) % MOD)\n\n        x = 0.0\n        for k in range(1, l + 1):\n            if Ai[i + k - n]:\n                x += mo(DP0i[k], DP1[i + k - n][l - k])\n        DP1i[l] = int(int(x) % MOD)\n\nprint DP1[0][n - 1]","tags":["graphs"],"src_uid":"1c2a2ad98e7162e89d36940b2848b921"}
{"text_full":"[DESCRIPTION]Ksenia has an array $$$a$$$ consisting of $$$n$$$ positive integers $$$a_1, a_2, \\ldots, a_n$$$. In one operation she can do the following:   choose three distinct indices $$$i$$$, $$$j$$$, $$$k$$$, and then  change all of $$$a_i, a_j, a_k$$$ to $$$a_i \\oplus a_j \\oplus a_k$$$ simultaneously, where $$$\\oplus$$$ denotes the bitwise XOR operation. She wants to make all $$$a_i$$$ equal in at most $$$n$$$ operations, or to determine that it is impossible to do so. She wouldn't ask for your help, but please, help her![SOURCE CODE]# abc means a xor b xor c\n#\n# a b c -> abc abc abc\n#\n#\n# a b c d -> abc abc abc d\n#         -> abc d   d   d    only YES if abc=d (abcd=0)\n#\n#\n# a b c d e -> abc abc abc d e\n#           -> abc abc abcde abcde abcde\n#              ^   ^   ^\n#           -> abcde abcde abcde abcde abcde\n#\n#\n# a b c d e f -> abc abc abc d e f\n#             -> abc abc abc def def def   odd number of abc\n#                                          only YES if abc=def (abcdef=0)\n#\n# a b c d e f g -> abc abc abc d e f g\n#               -> abc abc abc def def def g\n#                  ^           ^           ^\n#               -> abcdefg abc abc abcdefg def def abcdefg\n#                  ^       ^   ^\n#               -> abcdefg abcdefg abcdefg abcdefg def def abcdefg\n#               -> abcdefg abcdefg abcdefg abcdefg abcdefg abcdefg abcdefg\n#\n#\n# a b c d e f g\n# abc abc abc d e f g\n# abc abc abcde abcde abcde f g\n# abc abc abcde abcde abcdefg abcdefg abcdefg\n# abc abc abcdefg abcdefg abcdefg abcdefg abcdefg\n# abcdefg abcdefg abcdefg abcdefg abcdefg abcdefg abcdefg\n#\n# induction: assume true for n-2 and can be done in n-4 steps.\n# for n:\n#     a1 a2 a3 ... an\n#     (1 step, position 012)\n#     a1a2a3 a1a2a3 a1a2a3 a4 a5 ... an\n#                  [         n-2        ]\n#                   (n-4 steps)\n#                   234\n#                   456\n#                   678 ...\n#                   456\n#                   234\n#\n#     a1a2a3 a1a2a3 [a1a2...an   a1a2...an   a1a2...an]\n#     ^      ^       ^\n#     (1 step)\n#     012\n#\n#     Total n-2 steps. induction is correct\n\nn = int(input())\na = list(map(int,input().split()))\nif n % 2 != 0:\n    print('YES')\n    print(n-2)\n    for i in range(n):\n        print(i*2+1,i*2+2,i*2+3) # 123,345,567,...,n-2 n-1 n\n        if i*2+3 == n:\n            break\n    for i in range(2,n):\n        if n-i*2+2 < 3:\n            break\n        print(n-i*2,n-i*2+1,n-i*2+2)\n        # n-4 n-3 n-2, n-6 n-5 n-4, ... , 123\n\n\nelse:\n    xor = 0\n    for num in a:\n        xor = xor ^ num\n    if xor != 0:\n        print('NO')\n    else:\n        n -= 1\n        print('YES')\n        print(n-2)\n        for i in range(n):\n            print(i*2+1,i*2+2,i*2+3) # 123,345,567,...,n-2 n-1 n\n            if i*2+3 == n:\n                break\n        for i in range(2,n):\n            if n-i*2+2 < 3:\n                break\n            print(n-i*2,n-i*2+1,n-i*2+2)\n            # n-4 n-3 n-2, n-6 n-5 n-4, ... , 123","tags":["math"],"src_uid":"623f12b8c5a5c850c7edd9875af56f32"}
{"text_full":"[DESCRIPTION]You are given an array of integers. Vasya can permute (change order) its integers. He wants to do it so that as many as possible integers will become on a place where a smaller integer used to stand. Help Vasya find the maximal number of such integers.For instance, if we are given an array $$$[10, 20, 30, 40]$$$, we can permute it so that it becomes $$$[20, 40, 10, 30]$$$. Then on the first and the second positions the integers became larger ($$$20&gt;10$$$, $$$40&gt;20$$$) and did not on the third and the fourth, so for this permutation, the number that Vasya wants to maximize equals $$$2$$$. Read the note for the first example, there is one more demonstrative test case.Help Vasya to permute integers in such way that the number of positions in a new array, where integers are greater than in the original one, is maximal.[SOURCE CODE]from collections import *\n\nprint( int(input()) - max(Counter(map(int, input().split())).values()) )","tags":["math"],"src_uid":"eaa768dc1024df6449e89773234cc0c3"}
{"text_full":"[DESCRIPTION]'Jeopardy!' is an intellectual game where players answer questions and earn points. Company Q conducts a simplified 'Jeopardy!' tournament among the best IT companies. By a lucky coincidence, the old rivals made it to the finals: company R1 and company R2. The finals will have n questions, m of them are auction questions and n - m of them are regular questions. Each question has a price. The price of the i-th question is ai points. During the game the players chose the questions. At that, if the question is an auction, then the player who chose it can change the price if the number of his current points is strictly larger than the price of the question. The new price of the question cannot be less than the original price and cannot be greater than the current number of points of the player who chose the question. The correct answer brings the player the points equal to the price of the question. The wrong answer to the question reduces the number of the player's points by the value of the question price.The game will go as follows. First, the R2 company selects a question, then the questions are chosen by the one who answered the previous question correctly. If no one answered the question, then the person who chose last chooses again.All R2 employees support their team. They want to calculate what maximum possible number of points the R2 team can get if luck is on their side during the whole game (they will always be the first to correctly answer questions). Perhaps you are not going to be surprised, but this problem was again entrusted for you to solve.[SOURCE CODE]n, m = map(int, input().split())\nprices = list(map(int, input().split()))\nnormal = []\nauct = []\nq = list(map(int, input().split()))\nsum = 0\nfor i in range(n):\n    if i + 1 in q:\n        auct.append(prices[i])\n    else:\n        sum += prices[i]\nauct = sorted(auct, reverse=True)\nfor elem in auct:\n    sum += max(elem, sum)\nprint(sum)","tags":["math"],"src_uid":"913925f7b43ad737809365eba040e8da"}
{"text_full":"[DESCRIPTION]You are given a convex polygon P with n distinct vertices p1, p2, ..., pn. Vertex pi has coordinates (xi, yi) in the 2D plane. These vertices are listed in clockwise order.You can choose a real number D and move each vertex of the polygon a distance of at most D from their original positions.Find the maximum value of D such that no matter how you move the vertices, the polygon does not intersect itself and stays convex.[SOURCE CODE]#!\/usr\/bin\/env python3\n\nfrom decimal import Decimal\n\n\ndef dist(a, b):\n    x1, y1 = a\n    x2, y2 = b\n    return Decimal((x1-x2)**2+(y1-y2)**2).sqrt()\n\n\ndef minh(a, b, c):\n    m = dist(a, b)\n    n = dist(b, c)\n    k = dist(a, c)\n    p = Decimal(m + n + k)\/2\n    sqp = (p*(p-m)*(p-n)*(p-k)).sqrt()\n    hm = (Decimal(2)\/m)*sqp\n    hn = (Decimal(2)\/n)*sqp\n    hk = (Decimal(2)\/k)*sqp\n    return min([hm, hn, hk])\n\n\ndef solve():\n    n = int(input())\n    coords = []\n    for i in range(n):\n        coords.append(tuple(map(int, input().split())))\n    coords += coords\n\n    res = min(\n        minh(coords[i], coords[i+1], coords[i+2])\n        for i in range(n))\n\n    print(res\/2)\n\nif __name__ == '__main__':\n    solve()","tags":["geometry"],"src_uid":"495488223483401ff12ae9c456b4e5fe"}
{"text_full":"[DESCRIPTION]This is an interactive problem.Ayush devised yet another scheme to set the password of his lock. The lock has $$$n$$$ slots where each slot can hold any non-negative integer. The password $$$P$$$ is a sequence of $$$n$$$ integers, $$$i$$$-th element of which goes into the $$$i$$$-th slot of the lock.To set the password, Ayush comes up with an array $$$A$$$ of $$$n$$$ integers each in the range $$$[0, 2^{63}-1]$$$. He then sets the $$$i$$$-th element of $$$P$$$ as the bitwise OR of all integers in the array except $$$A_i$$$.You need to guess the password. To make a query, you can choose a non-empty subset of indices of the array and ask the bitwise OR all elements of the array with index in this subset. You can ask no more than 13 queries.[SOURCE CODE]def subset(n,k,res,bit):\n    while bit<1<<n:res.append(bit);x=bit&-bit;y=bit+x;bit=((bit&~y)\/\/x>>1)|y\n    return res\nn=int(input());bb=subset(13,6,[],63);bb=bb[:n];m=bb[-1].bit_length();xx=[0]*m;ans=[0]*n\nfor k in range(m):\n    cur=[]\n    for i,b in enumerate(bb):\n        if b>>k&1:cur.append(i+1)\n    print(\"?\",len(cur),*cur,flush=True);xx[k]=int(input())\nfor i,b in enumerate(bb):\n    for k in range(m):\n        if b>>k&1==0:ans[i]|=xx[k]\nprint(\"!\",*ans,flush=True)","tags":["math"],"src_uid":"d70b9c132e08cadb760569495f48053c"}
{"text_full":"[DESCRIPTION]You are given two arrays $$$a$$$ and $$$b$$$, each contains $$$n$$$ integers.You want to create a new array $$$c$$$ as follows: choose some real (i.e. not necessarily integer) number $$$d$$$, and then for every $$$i \\in [1, n]$$$ let $$$c_i := d \\cdot a_i + b_i$$$.Your goal is to maximize the number of zeroes in array $$$c$$$. What is the largest possible answer, if you choose $$$d$$$ optimally?[SOURCE CODE]# @-*- coding: utf-8 -*-\n# @Time:   2018-10-21T21:21:26+08:00\n# @Email:  ykaiwan@163.com\n\n\nimport sys\nimport math\nimport bisect\nfrom collections import defaultdict\n\nMOD = int(1e9+7)\n\n\n# n = map(int, raw_input().split())\nn = int(raw_input())\na = map(int, raw_input().split())\nb = map(int, raw_input().split())\nck = defaultdict(int)\ndef gcd(x, y):\n    while (y):\n        x, y = y, x % y\n    return x\ntt = 0\nfor i, j in zip(a,b):\n    if i == 0:\n        if j == 0:\n            tt += 1\n    else:\n        k = gcd(i, j)\n        ck[(i\/k, j\/k)] += 1\nif not ck:\n    print 0+tt\nelse:\n    print max(ck.values())+tt","tags":["number theory","math"],"src_uid":"c083988d20f434d61134f7b376581eb6"}
{"text_full":"[DESCRIPTION]There are $$$n$$$ points on the plane, $$$(x_1,y_1), (x_2,y_2), \\ldots, (x_n,y_n)$$$.You need to place an isosceles triangle with two sides on the coordinate axis to cover all points (a point is covered if it lies inside the triangle or on the side of the triangle). Calculate the minimum length of the shorter side of the triangle.[SOURCE CODE]n = int(input())\ns=0\nm=0\nfor i in range(n):\n    a = [ int(i) for i in input().split() ]\n    s = sum(a)\n    if s>=m:\n       m=s\nprint(m)","tags":["geometry","math"],"src_uid":"7c41fb6212992d1b3b3f89694b579fea"}
{"text_full":"[DESCRIPTION]Two people play the following string game. Initially the players have got some string s. The players move in turns, the player who cannot make a move loses. Before the game began, the string is written on a piece of paper, one letter per cell.  An example of the initial situation at s = \"abacaba\" A player's move is the sequence of actions:  The player chooses one of the available pieces of paper with some string written on it. Let's denote it is t. Note that initially, only one piece of paper is available.  The player chooses in the string t = t1t2... t|t| character in position i (1 ≤ i ≤ |t|) such that for some positive integer l (0 &lt; i - l; i + l ≤ |t|) the following equations hold: ti - 1 = ti + 1, ti - 2 = ti + 2, ..., ti - l = ti + l.  Player cuts the cell with the chosen character. As a result of the operation, he gets three new pieces of paper, the first one will contain string t1t2... ti - 1, the second one will contain a string consisting of a single character ti, the third one contains string ti + 1ti + 2... t|t|.   An example of making action (i = 4) with string s = «abacaba» Your task is to determine the winner provided that both players play optimally well. If the first player wins, find the position of character that is optimal to cut in his first move. If there are multiple positions, print the minimal possible one.[SOURCE CODE]from sys import stdin\n\n\ndef task():\n    value = stdin.readline()\n    games = []\n    counter = 0\n    for i in xrange(1, len(value)-1):\n        if value[i - 1] == value[i + 1]:\n            counter += 1\n        else:\n            if counter > 0:\n                games.append(counter)\n            counter = 0\n    if counter > 0:\n        games.append(counter)\n    max_game = max(games) if games else 0\n\n    grundi = [0, 1, 1]\n    for n in xrange(3, max_game + 1):\n        s = {grundi[i] ^ grundi[n - i - 3] for i in xrange(0, n \/\/ 2 + 1)}\n        s.add(grundi[n - 2])\n        for i in xrange(n):\n            if i not in s:\n                grundi.append(i)\n                break\n\n    g = 0\n    for game in games:\n        g ^= grundi[game]\n    print 'First' if g > 0 else 'Second'\n\n    def check(n, g):\n        if n < 3:\n            return 0 if g == 0 else -1\n        else:\n            if grundi[n - 2] ^ g == 0:\n                return 0\n            for i in xrange(0, n - 2):\n                if g ^ grundi[i] ^ grundi[n - i - 3] == 0:\n                    return i + 1\n            return -1\n\n    cache = set()\n    counter = 0\n    delta = 0\n    if g > 0:\n        for i in xrange(1, len(value)-1):\n            if value[i - 1] == value[i + 1]:\n                if not delta:\n                    delta = i + 1\n                counter += 1\n            else:\n                if counter > 0:\n                    if counter not in cache:\n                        p = check(counter, grundi[counter] ^ g)\n                        if p >= 0:\n                            print delta + p\n                            quit()\n                        cache.add(counter)\n                counter = 0\n                delta = 0\n        print delta + check(counter, grundi[counter] ^ g)\n\ntask()","tags":["games"],"src_uid":"f5d9490dc6e689944649820df5f23657"}
{"text_full":"[DESCRIPTION]You are given two strings $$$A$$$ and $$$B$$$ representing essays of two students who are suspected cheaters. For any two strings $$$C$$$, $$$D$$$ we define their similarity score $$$S(C,D)$$$ as $$$4\\cdot LCS(C,D) - |C| - |D|$$$, where $$$LCS(C,D)$$$ denotes the length of the Longest Common Subsequence of strings $$$C$$$ and $$$D$$$. You believe that only some part of the essays could have been copied, therefore you're interested in their substrings.Calculate the maximal similarity score over all pairs of substrings. More formally, output maximal $$$S(C, D)$$$ over all pairs $$$(C, D)$$$, where $$$C$$$ is some substring of $$$A$$$, and $$$D$$$ is some substring of $$$B$$$. If $$$X$$$ is a string, $$$|X|$$$ denotes its length.A string $$$a$$$ is a substring of a string $$$b$$$ if $$$a$$$ can be obtained from $$$b$$$ by deletion of several (possibly, zero or all) characters from the beginning and several (possibly, zero or all) characters from the end.A string $$$a$$$ is a subsequence of a string $$$b$$$ if $$$a$$$ can be obtained from $$$b$$$ by deletion of several (possibly, zero or all) characters. Pay attention to the difference between the substring and subsequence, as they both appear in the problem statement. You may wish to read the Wikipedia page about the Longest Common Subsequence problem.[SOURCE CODE]n,m = map(int, input().split()) \nA = input() \nB = input() \n\nM = [\n    [0]*(m+1) for _ in range (n+1) \n]\n\nfor i in range (1, n+1): \n    for j in range (1, m+1): \n\n        if (A[i-1] == B[j-1]) : \n            M[i][j] = 2 + M[i-1][j-1] \n        else: \n            M[i][j] = max (M[i-1][j]-1, M[i][j-1]-1, M[i-1][j-1]-2, 0) \n    \nans = -1 \nfor i in range (n+1): \n    for j in range (m+1): \n        ans = max (ans, M[i][j]) \n\nprint (ans)","tags":["strings"],"src_uid":"cce64939977e0956714e06514e6043ff"}
{"text_full":"[DESCRIPTION]Thanks to the Doctor's help, the rebels managed to steal enough gold to launch a full-scale attack on the Empire! However, Darth Vader is looking for revenge and wants to take back his gold.The rebels have hidden the gold in various bases throughout the galaxy. Darth Vader and the Empire are looking to send out their spaceships to attack these bases.The galaxy can be represented as an undirected graph with $$$n$$$ planets (nodes) and $$$m$$$ wormholes (edges), each connecting two planets.A total of $$$s$$$ empire spaceships and $$$b$$$ rebel bases are located at different planets in the galaxy.Each spaceship is given a location $$$x$$$, denoting the index of the planet on which it is located, an attacking strength $$$a$$$, and a certain amount of fuel $$$f$$$.Each base is given a location $$$x$$$, and a defensive strength $$$d$$$.A spaceship can attack a base if both of these conditions hold:   the spaceship's attacking strength is greater or equal than the defensive strength of the base  the spaceship's fuel is greater or equal to the shortest distance, computed as the number of wormholes, between the spaceship's planet and the base's planet Vader is very particular about his attacking formations. He requires that each spaceship is to attack at most one base and that each base is to be attacked by at most one spaceship.Vader knows that the rebels have hidden $$$k$$$ gold in each base, so he will assign the spaceships to attack bases in such a way that maximizes the number of bases attacked.Therefore, for each base that is attacked, the rebels lose $$$k$$$ gold.However, the rebels have the ability to create any number of dummy bases. With the Doctor's help, these bases would exist beyond space and time, so all spaceship can reach them and attack them. Moreover, a dummy base is designed to seem irresistible: that is, it will always be attacked by some spaceship.Of course, dummy bases do not contain any gold, but creating such a dummy base costs $$$h$$$ gold.What is the minimum gold the rebels can lose if they create an optimal number of dummy bases?[SOURCE CODE]def main():\n    inp = readnumbers()\n    ii = 0\n    n = inp[ii]\n    ii += 1\n    m = inp[ii]\n    ii += 1\n    coupl = [[] for _ in range(n)]\n    for _ in range(m):\n        u = inp[ii] - 1\n        ii += 1\n        v = inp[ii] - 1\n        ii += 1\n        coupl[u].append(v)\n        coupl[v].append(u)\n    s = inp[ii]\n    ii += 1\n    b = inp[ii]\n    ii += 1\n    k = inp[ii]\n    ii += 1\n    h = inp[ii]\n    ii += 1\n    ii += 3*s\n    bases = [[] for _ in range(n)]\n    D = []\n    for ind in range(b):\n        x = inp[ii] - 1\n        ii += 1\n        d  = inp[ii]\n        ii += 1\n        D.append(d)\n        bases[x].append(ind)\n    ii -= 2 * b + 3 * s\n    spaces = [[] for _ in range(s)]\n    for ind in range(s):\n        x = inp[ii] - 1\n        ii += 1\n        a = inp[ii]\n        ii += 1\n        f = inp[ii]\n        ii += 1\n        dist = [-1]*n\n        dist[x] = 0\n        bfs = [x]\n        for node in bfs:\n            for bind in bases[node]:\n                if D[bind] <= a:\n                    spaces[ind].append(bind)\n            d = dist[node]\n            if d < f:\n                for nei in coupl[node]:\n                    if dist[nei] == -1:\n                        bfs.append(nei)\n                        dist[nei] = d + 1\n    source = s + b\n    sink = s + b + 1\n    U = []\n    V = []\n    C = []\n    coupl = [[] for _ in range(s+b+2)]\n    for ind in range(s):\n        for bases in spaces[ind]:\n            coupl[ind].append(len(U))\n            U.append(ind)\n            V.append(s + bases)\n            C.append(1)\n        coupl[source].append(len(U))\n        U.append(source)\n        V.append(ind)           \n        C.append(1)\n    for bases in range(b):\n        coupl[bases + s].append(len(U))\n        U.append(bases + s)\n        V.append(sink)           \n        C.append(1)\n    maxflow, flows = dinics_maxflow(coupl, U, V, C, source, sink, lim = 1, directed = True)\n    bestcost = 10**18\n    matched = maxflow\n    unused = s - matched\n    fake = 0\n    while fake <= s:\n        bestcost = min(bestcost, k * matched + h * fake)\n        if unused:\n            unused -= 1\n        elif matched:\n            matched -= 1\n        fake += 1\n    print bestcost\ndef dinics_maxflow(_coupl, _U, _V, _C, s, t, lim = 1, directed = False):\n    assert(len(_U) == len(_V) == len(_C))\n    n = len(_coupl)\n    m = len(_U)\n    total_flow = 0\n    coupl = [[2*i for i in c] for c in _coupl]\n    V = []\n    for i in range(m):\n        V.append(_V[i])\n        V.append(_U[i])\n    C = []\n    if directed:\n        for i in range(m):\n            C.append(_C[i])\n            C.append(0)\n    else:\n        for i in range(m):\n            C.append(_C[i])\n            C.append(_C[i])\n    for i in range(m):\n        coupl[V[2*i]].append(2*i^1) \n    inf = sum(C[e] for e in coupl[s] if V[e^1]==s)\n    ptr_copy = [len(coupl[i]) - 1 for i in range(n)]\n    while True:\n        # Calculate distance from source using all edges with cap >= lim\n        dist_to_source = [0]*n\n        dist_to_source[s] = 1\n        bfs = [s]\n        for node in bfs:\n            if dist_to_source[t]:\n                break\n            my_dist_plus_1 = dist_to_source[node] + 1\n            for e in coupl[node]:\n                if not dist_to_source[V[e]] and C[e] >= lim:\n                    dist_to_source[V[e]] = my_dist_plus_1\n                    bfs.append(V[e])\n        if not dist_to_source[t]:\n            lim \/\/= 2\n            if lim == 0:\n                break\n            continue\n        ptr = ptr_copy[:]\n        stack = [0]*(2*n+1)\n        stack[0] = s\n        stack[1] = inf\n        stack[2] = s\n        ii = 1\n        while ptr[s] >= 0:\n            cap = stack[ii]\n            node = stack[ii + 1]\n            if node == t:\n                total_flow += cap\n                for node in stack[2:ii:2]:\n                    e = coupl[node][ptr[node]]\n                    C[e] -= cap\n                    C[e^1] += cap\n                ii = 1\n                continue\n            edges = coupl[node]\n            count = ptr[node]\n            mydist_plus_1 = dist_to_source[node] + 1\n            while count >= 0:\n                e = edges[count]\n                if dist_to_source[V[e]] == mydist_plus_1 and C[e] > 0:\n                    ii += 2\n                    stack[ii] = C[e] if C[e] < cap else cap\n                    stack[ii+1] = V[e]\n                    break\n                count -= 1\n            else:\n                ii -= 2\n                ptr[stack[ii + 1]] -= 1\n            ptr[node] = count\n    if directed:\n        flows = C[1::2]\n    else:\n        flows = []\n        for i in range(m):\n            flows.append((C[2*i^1] - C[2*i])\/\/2)\n    maxflow = total_flow\n    return maxflow, flows\npy2 = round(0.5)\nif py2:\n    from future_builtins import ascii, filter, hex, map, oct, zip\n    range = xrange\nimport os, sys\nfrom io import*\nBUFSIZE = 8192\nclass FastIO(BytesIO):\n    newlines = 0\n    def __init__(self, file):\n        self._file = file\n        self._fd = file.fileno()\n        self.writable = \"x\" in file.mode or \"w\" in file.mode\n        self.write = super(FastIO, self).write if self.writable else None\n    def _fill(self):\n        s = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n        self.seek((self.tell(), self.seek(0,2), super(FastIO, self).write(s))[0])\n        return s\n    def read(self):\n        while self._fill(): pass\n        return super(FastIO,self).read()\n    def readline(self):\n        while self.newlines == 0:\n            s = self._fill(); self.newlines = s.count(b\"\\n\") + (not s)\n        self.newlines -= 1\n        return super(FastIO, self).readline()\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.getvalue())\n            self.truncate(0), self.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        if py2:\n            self.write = self.buffer.write\n            self.read = self.buffer.read\n            self.readline = self.buffer.readline\n        else:\n            self.write = lambda s:self.buffer.write(s.encode('ascii'))\n            self.read = lambda:self.buffer.read().decode('ascii')\n            self.readline = lambda:self.buffer.readline().decode('ascii')\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n')\nimport sys\nclass ostream:\n    def __lshift__(self,a):\n        sys.stdout.write(str(a))\n        return self\ncout = ostream()\nendl = '\\n'\ndef readnumbers(zero = 0):\n    conv = ord if py2 else lambda x:x\n    A = []; numb = zero; sign = 1; i = 0; s = sys.stdin.buffer.read()\n    try:\n        while True:\n            if s[i] >= b'0' [0]:\n                numb = 10 * numb + conv(s[i]) - 48\n            elif s[i] == b'-' [0]: sign = -1\n            elif s[i] != b'\\r' [0]:\n                A.append(sign*numb)\n                numb = zero; sign = 1\n            i += 1\n    except:pass\n    if s and s[-1] >= b'0' [0]:\n        A.append(sign*numb)\n    return A\nif __name__== \"__main__\":\n  main()","tags":["graphs"],"src_uid":"7d14a2b5908e520f696d74317454c22c"}
{"text_full":"[DESCRIPTION]You are given array a with n elements and the number m. Consider some subsequence of a and the value of least common multiple (LCM) of its elements. Denote LCM as l. Find any longest subsequence of a with the value l ≤ m.A subsequence of a is an array we can get by erasing some elements of a. It is allowed to erase zero or all elements.The LCM of an empty array equals 1.[SOURCE CODE]import sys\nrange = xrange\ninput = raw_input\n \nn,m = [int(x) for x in input().split()]\nA = [int(x) for x in input().split()]\ncounter = [0]*(m+1)\nfor a in A:\n    if a <= m:\n        counter[a] += 1\n \nlcm = [0]*(m+1)\nfor d in range(1,m+1):\n    for j in range(d,m+1,d):\n        lcm[j] += counter[d]\n \nlcm = max(range(1, m+1), key = lcm.__getitem__)\nout = []\nfor i,a in enumerate(A):\n    if lcm != 0 and lcm%a == 0:\n        out.append(i)\nprint lcm, len(out)\nprint ' '.join(str(x+1) for x in out)","tags":["number theory","math"],"src_uid":"26e1afd54da6506a349e652a40997109"}
{"text_full":"[DESCRIPTION]One day in the IT lesson Anna and Maria learned about the lexicographic order.String x is lexicographically less than string y, if either x is a prefix of y (and x ≠ y), or there exists such i (1 ≤ i ≤ min(|x|, |y|)), that xi &lt; yi, and for any j (1 ≤ j &lt; i) xj = yj. Here |a| denotes the length of the string a. The lexicographic comparison of strings is implemented by operator &lt; in modern programming languages​​.The teacher gave Anna and Maria homework. She gave them a string of length n. They should write out all substrings of the given string, including the whole initial string, and the equal substrings (for example, one should write out the following substrings from the string \"aab\": \"a\", \"a\", \"aa\", \"ab\", \"aab\", \"b\"). The resulting strings should be sorted in the lexicographical order. The cunning teacher doesn't want to check all these strings. That's why she said to find only the k-th string from the list. Help Anna and Maria do the homework.[SOURCE CODE]# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Sat May  7 16:53:11 2016\n\n@author: Alex\n\"\"\"\nfrom heapq import heappush,heappop,heapify\nstring = input()\nl = len(string)\nk = int(input())\nA = l*(l+1)\/2\nif A<k:\n    print(\"No such line.\")\nelse:\n    heap = [(string[i],i+1) for i in range(l)]\n    heapify(heap)\n    cnt = 0\n    while cnt<k:\n        now,nextp = heappop(heap)\n        cnt+=1\n        if nextp<l:\n            heappush(heap,(now+string[nextp],nextp+1))\n    print(now)","tags":["strings"],"src_uid":"161f3f76bfe141899ad0773545b38c03"}
{"text_full":"[DESCRIPTION]The Bad Luck Island is inhabited by three kinds of species: r rocks, s scissors and p papers. At some moments of time two random individuals meet (all pairs of individuals can meet equiprobably), and if they belong to different species, then one individual kills the other one: a rock kills scissors, scissors kill paper, and paper kills a rock. Your task is to determine for each species what is the probability that this species will be the only one to inhabit this island after a long enough period of time.[SOURCE CODE]from collections import defaultdict\ndef main():\n    r, s, p = map(int, raw_input().split())\n    ans = [0.0] * 3\n    d = defaultdict(float)\n    nd = defaultdict(float)\n    d[r,s,p] = 1.0\n    for i in xrange(r + s + p):\n        for t, v in d.viewitems():\n            r, s, p = t\n            if not r and not s:\n                ans[2] += v\n            elif not s and not p:\n                ans[0] += v\n            elif not p and not r:\n                ans[1] += v\n            else:\n                k = 1.0 \/ (r * s + s * p + p * r)\n                if p and r:\n                    nd[r-1,s,p] += v * r * p * k\n                if r and s:\n                    nd[r,s-1,p] += v * r * s * k\n                if s and p:\n                    nd[r,s,p-1] += v * s * p * k\n        d, nd = nd, d\n        nd.clear()\n    print \"%.12f %.12f %.12f\" % (ans[0], ans[1], ans[2])\nmain()","tags":["probabilities"],"src_uid":"35736970c6d629c2764eaf23299e0356"}
{"text_full":"[DESCRIPTION]Little Mishka is a great traveller and she visited many countries. After thinking about where to travel this time, she chose XXX — beautiful, but little-known northern country.Here are some interesting facts about XXX:  XXX consists of n cities, k of whose (just imagine!) are capital cities.  All of cities in the country are beautiful, but each is beautiful in its own way. Beauty value of i-th city equals to ci.  All the cities are consecutively connected by the roads, including 1-st and n-th city, forming a cyclic route 1 — 2 — ... — n — 1. Formally, for every 1 ≤ i &lt; n there is a road between i-th and i + 1-th city, and another one between 1-st and n-th city.  Each capital city is connected with each other city directly by the roads. Formally, if city x is a capital city, then for every 1 ≤ i ≤ n,  i ≠ x, there is a road between cities x and i.  There is at most one road between any two cities.  Price of passing a road directly depends on beauty values of cities it connects. Thus if there is a road between cities i and j, price of passing it equals ci·cj.Mishka started to gather her things for a trip, but didn't still decide which route to follow and thus she asked you to help her determine summary price of passing each of the roads in XXX. Formally, for every pair of cities a and b (a &lt; b), such that there is a road between a and b you are to find sum of products ca·cb. Will you help her?[SOURCE CODE]n, k = [int(x) for x in input().split()]\nc = [int(x) for x in input().split()]\nids = [(int(x)-1) for x in input().split()]\n\ns = sum(c)\nans = 0\nfor i in range(n):\n  ans += (c[i] * c[(i+1)%n])\nfor i in range(k):\n  if (abs(ids[i] - ids[(i+1)%k]) == 1) or (ids[i] == n-1 and ids[0] == 0):\n    ans += c[ids[i]]*c[ids[(i+1)%k]]\ntemp = 0\nfor i in range(k):\n  ans += c[ids[i]] * (s - c[(ids[i]-1)%n] - c[(ids[i]+1)%n] - c[ids[i]])\n  ans -= c[ids[i]]*temp\n  temp += c[ids[i]]\n  \n\nprint(repr(ans))","tags":["math"],"src_uid":"bc6b8fda79c257e6c4e280d7929ed8a1"}
{"text_full":"[DESCRIPTION]Nauuo is a girl who loves drawing circles.One day she has drawn a circle and wanted to draw a tree on it.The tree is a connected undirected graph consisting of $$$n$$$ nodes and $$$n-1$$$ edges. The nodes are numbered from $$$1$$$ to $$$n$$$.Nauuo wants to draw a tree on the circle, the nodes of the tree should be in $$$n$$$ distinct points on the circle, and the edges should be straight without crossing each other.\"Without crossing each other\" means that every two edges have no common point or the only common point is an endpoint of both edges.Nauuo wants to draw the tree using a permutation of $$$n$$$ elements. A permutation of $$$n$$$ elements is a sequence of integers $$$p_1,p_2,\\ldots,p_n$$$ in which every integer from $$$1$$$ to $$$n$$$ appears exactly once.After a permutation is chosen Nauuo draws the $$$i$$$-th node in the $$$p_i$$$-th point on the circle, then draws the edges connecting the nodes.The tree is given, Nauuo wants to know how many permutations are there so that the tree drawn satisfies the rule (the edges are straight without crossing each other). She only wants to know the answer modulo $$$998244353$$$, can you help her?It is obvious that whether a permutation is valid or not does not depend on which $$$n$$$ points on the circle are chosen.[SOURCE CODE]#import sys\n#sys.stdin = open('inD', 'r')\nn = int(input())\n#a = [int(x) for x in input().split()]\n#n,m = map(int, input().split())\nans = n\nmod = 998244353\nd = [0]*(n+1)\nfor i in range(n-1):\n    u,v = map(int, input().split())\n    d[u] += 1\n    d[v] += 1\n    ans = (ans * d[u] % mod) * d[v] % mod\nprint(ans)","tags":["geometry","trees"],"src_uid":"03bfe285856fa74b89de7a1bebb14bca"}
{"text_full":"[DESCRIPTION]Note that girls in Arpa’s land are really attractive.Arpa loves overnight parties. In the middle of one of these parties Mehrdad suddenly appeared. He saw n pairs of friends sitting around a table. i-th pair consisted of a boy, sitting on the ai-th chair, and his girlfriend, sitting on the bi-th chair. The chairs were numbered 1 through 2n in clockwise direction. There was exactly one person sitting on each chair.  There were two types of food: Kooft and Zahre-mar. Now Mehrdad wonders, was there any way to serve food for the guests such that:   Each person had exactly one type of food,  No boy had the same type of food as his girlfriend,  Among any three guests sitting on consecutive chairs, there was two of them who had different type of food. Note that chairs 2n and 1 are considered consecutive. Find the answer for the Mehrdad question. If it was possible, find some arrangement of food types that satisfies the conditions.[SOURCE CODE]n=int(raw_input())\ng=[[]for i in range(n+n)]\nc=[-1 for i in range(n+n)]\ne=[]\nfor i in range(n):\n    u,v=map(int,raw_input().split())\n    u-=1\n    v-=1\n    e.append([u,v])\n    g[u].append(v)\n    g[v].append(u)\nfor i in range(n):\n    g[2*i].append(2*i+1)\n    g[2*i+1].append(2*i)\nq=[-1 for i in range(2*n)]\nfor i in range(2*n):\n    if c[i]!=-1:continue\n    h,t=0,1\n    q[0]=i\n    c[i]=0\n    while h<t:\n        u=q[h]\n        h+=1\n        for v in g[u]:\n            if c[v]==-1:\n                c[v]=c[u]^1\n                q[t]=v\n                t+=1\nfor x in e: print \"{0} {1}\".format(c[x[0]]+1,c[x[1]]+1)","tags":["graphs"],"src_uid":"49a78893ea2849aa59647846b4eaba7c"}
{"text_full":"[DESCRIPTION]Monocarp had a tree which consisted of $$$n$$$ vertices and was rooted at vertex $$$1$$$. He decided to study BFS (Breadth-first search), so he ran BFS on his tree, starting from the root. BFS can be described by the following pseudocode:a = [] # the order in which vertices were processedq = Queue()q.put(1) # place the root at the end of the queuewhile not q.empty():    k = q.pop() # retrieve the first vertex from the queue    a.append(k) # append k to the end of the sequence in which vertices were visited    for y in g[k]: # g[k] is the list of all children of vertex k, sorted in ascending order        q.put(y)Monocarp was fascinated by BFS so much that, in the end, he lost his tree. Fortunately, he still has a sequence of vertices, in which order vertices were visited by the BFS algorithm (the array a from the pseudocode). Monocarp knows that each vertex was visited exactly once (since they were put and taken from the queue exactly once). Also, he knows that all children of each vertex were viewed in ascending order.Monocarp knows that there are many trees (in the general case) with the same visiting order $$$a$$$, so he doesn't hope to restore his tree. Monocarp is okay with any tree that has minimum height.The height of a tree is the maximum depth of the tree's vertices, and the depth of a vertex is the number of edges in the path from the root to it. For example, the depth of vertex $$$1$$$ is $$$0$$$, since it's the root, and the depth of all root's children are $$$1$$$.Help Monocarp to find any tree with given visiting order $$$a$$$ and minimum height.[SOURCE CODE]for _ in range(int(input())):\n\tn = int(input())\n\tl = list(map(int, input().split()))\n\td,c = [0]*n,0\n\tfor i in range(1,n):\n\t\tif l[i-1] > l[i]:\n\t\t\tc += 1\n\t\td[i] = d[c] + 1\n\tprint(d[n-1])\n'''\n5\n\n1 2 5 4 3\n\n'''","tags":["graphs","trees"],"src_uid":"16c4160d1436206412ce51315cb6140b"}
{"text_full":"[DESCRIPTION]Let's call the roundness of the number the number of zeros to which it ends.You have an array of n numbers. You need to choose a subset of exactly k numbers so that the roundness of the product of the selected numbers will be maximum possible.[SOURCE CODE]from decimal import Decimal\n\n\ndef calc(c):\n    d = 0\n    p = 0\n    while c % 2 == 0:\n        c \/= 2\n        d += 1\n    while c % 5 == 0:\n        c \/= 5\n        p += 1\n    return d, p\n\n\nn, k = map(int, raw_input().split())\na = list(map(int, raw_input().split()))\ndp = [[-1] * 5050 for i in range(k+1)]\nfor i in range(n):\n    d, p = calc(Decimal(a[i]))\n    for i in range(k - 2, -1, -1):\n        for j in range(5000):\n            if dp[i][j] != -1:\n                dp[i + 1][j + p] = max(dp[i + 1][j + p], dp[i][j] + d)\n    dp[0][p] = max(dp[0][p], d)\n\n\nans = 0\nfor j in range(5050):\n    if dp[k-1][j] != -1:\n        ans = max(ans, min(j, dp[k-1][j]))\n\nprint(ans)","tags":["math"],"src_uid":"ea0de6955a0ddf56980cb1ac7216e8b7"}
{"text_full":"[DESCRIPTION]Andrew was very excited to participate in Olympiad of Metropolises. Days flew by quickly, and Andrew is already at the airport, ready to go home. He has $$$n$$$ rubles left, and would like to exchange them to euro and dollar bills. Andrew can mix dollar bills and euro bills in whatever way he wants. The price of one dollar is $$$d$$$ rubles, and one euro costs $$$e$$$ rubles.Recall that there exist the following dollar bills: $$$1$$$, $$$2$$$, $$$5$$$, $$$10$$$, $$$20$$$, $$$50$$$, $$$100$$$, and the following euro bills — $$$5$$$, $$$10$$$, $$$20$$$, $$$50$$$, $$$100$$$, $$$200$$$ (note that, in this problem we do not consider the $$$500$$$ euro bill, it is hard to find such bills in the currency exchange points). Andrew can buy any combination of bills, and his goal is to minimize the total number of rubles he will have after the exchange.Help him — write a program that given integers $$$n$$$, $$$e$$$ and $$$d$$$, finds the minimum number of rubles Andrew can get after buying dollar and euro bills.[SOURCE CODE]n = int(input())\nd = int(input())\ne = int(input())\n\ndollar = 1*d\neuro = 5*e\n\n# using_dollar = n%dollar\n# using_euro = n%euro\n# using_dollar_euro = using_dollar % euro\n# using_euro_dollar = using_euro % dollar\n\n# print(min(using_dollar, using_euro, using_dollar_euro, using_euro_dollar))\n\nans = 1e15\ntemp = 0\nwhile (temp<=n):\n    ans = min(ans, (n-temp)%dollar)\n    temp += euro\nprint(ans)","tags":["math"],"src_uid":"8c5d9b4fd297706fac3be83fc85028a0"}
{"text_full":"[DESCRIPTION]You've got a undirected graph G, consisting of n nodes. We will consider the nodes of the graph indexed by integers from 1 to n. We know that each node of graph G is connected by edges with at least k other nodes of this graph. Your task is to find in the given graph a simple cycle of length of at least k + 1.A simple cycle of length d (d &gt; 1) in graph G is a sequence of distinct graph nodes v1, v2, ..., vd such, that nodes v1 and vd are connected by an edge of the graph, also for any integer i (1 ≤ i &lt; d) nodes vi and vi + 1 are connected by an edge of the graph.[SOURCE CODE]r = lambda: map(int, raw_input().split())\n\nn, m, k = r()\ne = [[] for _ in xrange(n + 1)]\nfor _ in xrange(m):\n    a, b = r()\n    e[a].append(b)\n    e[b].append(a)\nflag = [-1] * (n + 1)\npath = []\n\nx, l = 1, 0\nwhile True:\n    path.append(x)\n    flag[x] = l\n    l += 1\n    for y in e[x]:\n        if flag[y] == -1:\n            x = y\n            break\n    else:\n        id = path.index(min(e[x], key = lambda s: flag[s]))\n        print len(path) - id\n        print ' '.join(map(str, path[id:]))\n        break","tags":["graphs"],"src_uid":"250c0e647d0f2ff6d86db01675192c9f"}
{"text_full":"[DESCRIPTION]On Children's Day, the child got a toy from Delayyy as a present. However, the child is so naughty that he can't wait to destroy the toy.The toy consists of n parts and m ropes. Each rope links two parts, but every pair of parts is linked by at most one rope. To split the toy, the child must remove all its parts. The child can remove a single part at a time, and each remove consume an energy. Let's define an energy value of part i as vi. The child spend vf1 + vf2 + ... + vfk energy for removing part i where f1, f2, ..., fk are the parts that are directly connected to the i-th and haven't been removed.Help the child to find out, what is the minimum total energy he should spend to remove all n parts.[SOURCE CODE]'''\nCreated on ٠١‏\/٠١‏\/٢٠١٥\n\n@author: mohamed265\n'''\nt = input().split()\nn = int(t[0])\nm = int(t[1])\nslon = 0\nnum = [int(x) for x in input().split()]\nfor i in range(m):\n    t = input().split()\n    slon += min(num[int(t[0])-1] , num[int(t[1])-1])\nprint(slon)","tags":["graphs"],"src_uid":"2e6bf9154d9da6ac134b52144d5322ca"}
{"text_full":"[DESCRIPTION]Mike wants to prepare for IMO but he doesn't know geometry, so his teacher gave him an interesting geometry problem. Let's define f([l, r]) = r - l + 1 to be the number of integer points in the segment [l, r] with l ≤ r (say that ). You are given two integers n and k and n closed intervals [li, ri] on OX axis and you have to find:  In other words, you should find the sum of the number of integer points in the intersection of any k of the segments. As the answer may be very large, output it modulo 1000000007 (109 + 7).Mike can't solve this problem so he needs your help. You will help him, won't you?[SOURCE CODE]from sys import stdin\nfrom itertools import repeat\ndef main():\n    n, k = map(int, stdin.readline().split())\n    mod = 10 ** 9 + 7\n    f = [1] * (n + 1)\n    inv = [1] * (n + 1)\n    invf = [1] * (n + 1)\n    for i in xrange(2, n + 1):\n        f[i] = f[i-1] * i % mod\n        inv[i] = mod - mod \/ i * inv[mod%i] % mod\n        invf[i] = invf[i-1] * inv[i] % mod\n    dat = map(int, stdin.read().split(), repeat(10, 2 * n))\n    for i in xrange(1, 2 * n, 2):\n        dat[i] += 1\n    s = list(set(dat))\n    s.sort()\n    d = {x: i for i, x in enumerate(s)}\n    l = len(d)\n    ev = [0 for _ in xrange(l)]\n    for i in xrange(n):\n        x, y = dat[i*2], dat[i*2+1]\n        ev[d[x]] += 1\n        ev[d[y]] -= 1\n    p = s[0]\n    t = ev[0]\n    ans = 0\n    def comb(a, b):\n        return f[a] * invf[b] * invf[a-b] % mod\n    for i in xrange(1, l):\n        q = s[i]\n        if t >= k:\n            ans += (q - p) * comb(t, k)\n            ans %= mod\n        t += ev[i]\n        p = q\n    print ans\nmain()","tags":["geometry"],"src_uid":"900c85e25d457eb8092624b1d42be2a2"}
{"text_full":"[DESCRIPTION]Vova and Marina love offering puzzles to each other. Today Marina offered Vova to cope with the following task.Vova has a non-directed graph consisting of n vertices and m edges without loops and multiple edges. Let's define the operation of contraction two vertices a and b that are not connected by an edge. As a result of this operation vertices a and b are deleted and instead of them a new vertex x is added into the graph, and also edges are drawn from it to all vertices that were connected with a or with b (specifically, if the vertex was connected with both a and b, then also exactly one edge is added from x to it). Thus, as a result of contraction again a non-directed graph is formed, it contains no loops nor multiple edges, and it contains (n - 1) vertices.Vova must perform the contraction an arbitrary number of times to transform the given graph into a chain of the maximum length. A chain of length k (k ≥ 0) is a connected graph whose vertices can be numbered with integers from 1 to k + 1 so that the edges of the graph connect all pairs of vertices (i, i + 1) (1 ≤ i ≤ k) and only them. Specifically, the graph that consists of one vertex is a chain of length 0. The vertices that are formed as a result of the contraction are allowed to be used in the following operations of contraction.    The picture illustrates the contraction of two vertices marked by red. Help Vova cope with his girlfriend's task. Find the maximum length of the chain that can be obtained from the resulting graph or else determine that it is impossible to obtain the chain.[SOURCE CODE]# lista doble enlazada o(1) operaciones en los bordes es mejor que si se implementa en el propio lenguaje\nfrom collections import deque\n\n\ndef solve():\n    n, m = input().split()\n    n = int(n)\n    m = int(m)\n    global maxValue\n    maxValue = n*2\n    graph = [[] for _ in range(0, n)]\n    for _ in range(0, m):\n        u, v = input().split()\n        u = int(u)-1\n        v = int(v)-1\n        graph[u].append(v)\n        graph[v].append(u)\n\n    diameters = []\n    distance = [maxValue]*n\n    cc = [0]*n # los a lo sumo n-1 vertices en la misma componente conexa de i\n    innerCc = [0]*n # los a lo sumo n-1 vertices en la misma componente conexa de i en distinto orden\n    for i in range(0, n):\n        if distance[i] == maxValue:\n            ccLen = bfs_2k(graph, i, distance,cc)\n            if(ccLen==None):\n                print(-1)\n                return\n            diameters.append(distance[cc[ccLen-1]] if ccLen > 0 else 0)\n            for v in range(0,ccLen):\n                innerDist = [maxValue]*n\n                bfs_2k(graph, cc[v], innerDist,innerCc)\n                diameters[-1] = max(diameters[-1], innerDist[innerCc[ccLen-1]])\n    print(sum(diameters))\n\n\ndef bfs_2k(graph, initVertex, dist,cc):\n    queue = deque()\n    queue.append(initVertex)\n    dist[initVertex] = 0\n    ccLen = 0\n    while queue:\n        u = queue.popleft()\n        for v in graph[u]:\n            if(dist[v] == maxValue):\n                dist[v] = dist[u] + 1\n                queue.append(v)\n                cc[ccLen]=v\n                ccLen+=1\n            if (dist[u] - dist[v]) % 2 == 0:\n                return None\n    return ccLen\n\n\nsolve()","tags":["graphs"],"src_uid":"a746bd2a212167ea85d00ffebd73fd9c"}
{"text_full":"[DESCRIPTION]Giant chess is quite common in Geraldion. We will not delve into the rules of the game, we'll just say that the game takes place on an h × w field, and it is painted in two colors, but not like in chess. Almost all cells of the field are white and only some of them are black. Currently Gerald is finishing a game of giant chess against his friend Pollard. Gerald has almost won, and the only thing he needs to win is to bring the pawn from the upper left corner of the board, where it is now standing, to the lower right corner. Gerald is so confident of victory that he became interested, in how many ways can he win?The pawn, which Gerald has got left can go in two ways: one cell down or one cell to the right. In addition, it can not go to the black cells, otherwise the Gerald still loses. There are no other pawns or pieces left on the field, so that, according to the rules of giant chess Gerald moves his pawn until the game is over, and Pollard is just watching this process.[SOURCE CODE]#from sys import setrecursionlimit as srl\nimport sys\nif sys.subversion[0] == \"PyPy\":\n    import io, atexit\n    sys.stdout = io.BytesIO()\n    atexit.register(lambda: sys.__stdout__.write(sys.stdout.getvalue()))\n    \n    sys.stdin = io.BytesIO(sys.stdin.read())\n    input = lambda: sys.stdin.readline().rstrip()\n \nRS = raw_input\nRI = lambda x=int: map(x,RS().split())\nRN = lambda x=int: x(RS())\n''' ...................................................................... '''\nmod = 10**9+7\n\nn,m,k = RI()\ngrid = [RI() for i in xrange(k)]\ngrid.sort()\ngrid.append([n,m])\ndp = [0]*(k+1)\n\nN = 2*max(n,m)\nfact = [1]*N\ninv = [1]*N\n\nfor i in xrange(1,N):\n    fact[i] = (fact[i-1]*i) % mod\n    inv[i] = (inv[i-1]*pow(i,mod-2,mod))%mod\n\ndef fun(x1,y1,x2,y2):\n    dx = x1-x2\n    dy = y1-y2\n    return (fact[dx+dy]*inv[dx]*inv[dy])%mod\n\nfor i in xrange(k+1):\n    x,y = grid[i]\n    tot = fun(x,y,1,1)\n    for j in xrange(i):\n        if grid[j][0]<=x and grid[j][1]<=y:\n            rem = (dp[j]*fun(x,y,grid[j][0],grid[j][1]))%mod\n            tot = (tot-rem)%mod\n    dp[i] = tot\nprint dp[k]","tags":["number theory","math"],"src_uid":"91749edcc396819d4172d06e2744b20b"}
{"text_full":"[DESCRIPTION]There are $$$n$$$ people sitting in a circle, numbered from $$$1$$$ to $$$n$$$ in the order in which they are seated. That is, for all $$$i$$$ from $$$1$$$ to $$$n-1$$$, the people with id $$$i$$$ and $$$i+1$$$ are adjacent. People with id $$$n$$$ and $$$1$$$ are adjacent as well.The person with id $$$1$$$ initially has a ball. He picks a positive integer $$$k$$$ at most $$$n$$$, and passes the ball to his $$$k$$$-th neighbour in the direction of increasing ids, that person passes the ball to his $$$k$$$-th neighbour in the same direction, and so on until the person with the id $$$1$$$ gets the ball back. When he gets it back, people do not pass the ball any more.For instance, if $$$n = 6$$$ and $$$k = 4$$$, the ball is passed in order $$$[1, 5, 3, 1]$$$. Consider the set of all people that touched the ball. The fun value of the game is the sum of the ids of people that touched it. In the above example, the fun value would be $$$1 + 5 + 3 = 9$$$.Find and report the set of possible fun values for all choices of positive integer $$$k$$$. It can be shown that under the constraints of the problem, the ball always gets back to the $$$1$$$-st player after finitely many steps, and there are no more than $$$10^5$$$ possible fun values for given $$$n$$$.[SOURCE CODE]from collections import Counter,defaultdict,deque\n#alph = 'abcdefghijklmnopqrstuvwxyz'\n#from math import factorial as fact\n#import math\n\n#tt = 1#int(input())\n#total=0\n#n = int(input())\n#n,m,k = [int(x) for x in input().split()]\n#n = int(input())\n#n,m = [int(x) for x in input().split()]\ndef divisors(n):\n   i = 1\n   divs = []\n   while i*i<=n:\n      if n%i==0:\n         divs.append(i)\n         if i*i!=n:\n            divs.append(n\/\/i)\n      i+=1\n   return divs\n\n\nn = int(input())\np = divisors(n)\nres = []\nfor el in p:\n    a = n\/\/el\n    k = (1+n-el+1)*a\/\/2\n    res.append(k)\nres.sort()\nprint(*res)","tags":["number theory","math"],"src_uid":"2ae1a4d4f2e58b359c898d1ff38edb9e"}
{"text_full":"[DESCRIPTION]You are given a set of $$$n\\ge 2$$$ pairwise different points with integer coordinates. Your task is to partition these points into two nonempty groups $$$A$$$ and $$$B$$$, such that the following condition holds:For every two points $$$P$$$ and $$$Q$$$, write the Euclidean distance between them on the blackboard: if they belong to the same group — with a yellow pen, and if they belong to different groups — with a blue pen. Then no yellow number is equal to any blue number.It is guaranteed that such a partition exists for any possible input. If there exist multiple partitions, you are allowed to output any of them.[SOURCE CODE]from sys import stdin\ndef rl():\n    return [int(w) for w in stdin.readline().split()]\n\nn, = rl()\n\nx0,y0 = rl()\nd = [0]\nfor i in range(n-1):\n    x,y = rl()\n    d.append((x-x0)**2 + (y-y0)**2)\n\nwhile not any(x&1 for x in d):\n    for i in range(n):\n        d[i] >>= 1\n\nA = [i+1 for i in range(n) if d[i]&1]\n\nprint(len(A))\nprint(*A)","tags":["geometry","math"],"src_uid":"d6dc1895a58e13cdac98377819f6ec68"}
{"text_full":"[DESCRIPTION]Ayrat has number n, represented as it's prime factorization pi of size m, i.e. n = p1·p2·...·pm. Ayrat got secret information that that the product of all divisors of n taken modulo 109 + 7 is the password to the secret data base. Now he wants to calculate this value.[SOURCE CODE]from collections import Counter\nfrom operator import __mul__\nmod = 10 ** 9 + 7\n\n\n\n\nn = input()\np = map(int, raw_input().split())\np = Counter(p)\n\nprod = 1\nexp = 1\nperfsq=1\nfl=0\n\nfor x,a in p.items():\n    if(a%2==1):\n        fl=1\n\n\nif(fl):\n    for x,a in p.items():\n        exp*=(a+1)\n        prod *= pow(x,(a),mod)\n        prod%=mod\n    print pow(prod,exp\/2,mod)\n\n\nelse:\n    for x,a in p.items():\n        exp*=(a+1)\n        prod *= pow(x,a\/2,mod)\n        prod%=mod\n\n    print pow(prod,exp,mod)","tags":["number theory","math"],"src_uid":"9a5bd9f937da55c3d26d5ecde6e50280"}
{"text_full":"[DESCRIPTION]You are given a directed graph of $$$n$$$ vertices and $$$m$$$ edges. Vertices are numbered from $$$1$$$ to $$$n$$$. There is a token in vertex $$$1$$$.The following actions are allowed:   Token movement. To move the token from vertex $$$u$$$ to vertex $$$v$$$ if there is an edge $$$u \\to v$$$ in the graph. This action takes $$$1$$$ second.  Graph transposition. To transpose all the edges in the graph: replace each edge $$$u \\to v$$$ by an edge $$$v \\to u$$$. This action takes increasingly more time: $$$k$$$-th transposition takes $$$2^{k-1}$$$ seconds, i.e. the first transposition takes $$$1$$$ second, the second one takes $$$2$$$ seconds, the third one takes $$$4$$$ seconds, and so on. The goal is to move the token from vertex $$$1$$$ to vertex $$$n$$$ in the shortest possible time. Print this time modulo $$$998\\,244\\,353$$$.[SOURCE CODE]from heapq import heappush, heappop;mod = 998244353;N, M = map(int, input().split());E1 = [[] for _ in range(N)];E2 = [[] for _ in range(N)]\nfor _ in range(M):u, v = map(int, input().split());u -= 1;v -= 1;E1[u].append(v);E2[v].append(u)\nmask1 = (1<<23) - 1;mask2 = (1<<18) - 1;inf = 1<<62;dist = [inf] * (1<<23);start = 0;dist[start] = 0;q = [start]\nwhile q:\n    v = heappop(q);  dist_v = v >> 23;    v &= mask1; n_trans = v >> 18; v_node = v & mask2\n    if v_node == N-1:  print(dist_v % mod);   exit()\n    if n_trans > 20:        break\n    if dist[v] != dist_v:        continue\n    for u_node in (E1[v_node] if n_trans&1==0 else E2[v_node]):\n        u = n_trans<<18 | u_node;    dist_u = dist_v + 1\n        if dist_u < dist[u]:            dist[u] = dist_u;       heappush(q, dist_u<<23 | u)\n    u = n_trans+1<<18 | v_node;   dist_u = dist_v + (1<<n_trans)\n    if dist_u < dist[u]:        dist[u] = dist_u;        heappush(q, dist_u<<23 | u)\nmask1 = (1<<37) - 1;mask2 = (1<<19) - 1;mask3 = (1<<18)-1;REV = 1<<18;dist = [inf] * (1<<19);start = 0;dist[start] = 0;q = [start]\nwhile q:\n    v = heappop(q);dist_v = v >> 19;n_trans = dist_v >> 18;v &= mask2;v_node = v & mask3\n    if v_node == N-1:ans = pow(2, n_trans, mod) - 1 + (dist_v&mask3);print(ans);exit()\n    rev = v & REV\n    if dist[v] != dist_v:        continue\n    for u_node in (E1[v_node] if n_trans&1==0 else E2[v_node]):\n        u = rev | u_node;  dist_u = dist_v + 1\n        if dist_u < dist[u]:       dist[u] = dist_u;          heappush(q, dist_u<<19 | u)\n    u = v ^ REV; dist_u = dist_v + (1<<18)\n    if dist_u < dist[u]:  dist[u] = dist_u;   heappush(q, dist_u<<19 | u)\nassert False","tags":["graphs"],"src_uid":"3b42ca8bf066e9c5b6f5ff822cdc9214"}
{"text_full":"[DESCRIPTION]You are given a string $$$t$$$ and $$$n$$$ strings $$$s_1, s_2, \\dots, s_n$$$. All strings consist of lowercase Latin letters.Let $$$f(t, s)$$$ be the number of occurences of string $$$s$$$ in string $$$t$$$. For example, $$$f('\\text{aaabacaa}', '\\text{aa}') = 3$$$, and $$$f('\\text{ababa}', '\\text{aba}') = 2$$$.Calculate the value of $$$\\sum\\limits_{i=1}^{n} \\sum\\limits_{j=1}^{n} f(t, s_i + s_j)$$$, where $$$s + t$$$ is the concatenation of strings $$$s$$$ and $$$t$$$. Note that if there are two pairs $$$i_1$$$, $$$j_1$$$ and $$$i_2$$$, $$$j_2$$$ such that $$$s_{i_1} + s_{j_1} = s_{i_2} + s_{j_2}$$$, you should include both $$$f(t, s_{i_1} + s_{j_1})$$$ and $$$f(t, s_{i_2} + s_{j_2})$$$ in answer.[SOURCE CODE]from __future__ import division, print_function\n\nfrom collections import deque\nclass Node:\n    def __init__(self, c, nxt, fail, o):\n        self.c = c\n        self.nxt = nxt\n        self.fail = fail\n        self.o = o\n\nroot = Node('', {}, Node, 0)\nroot.fail = root\n\ndef new_node(par, c):\n    node = Node(c, {}, root, 0)\n    par.nxt[c] = node\n    return node\n\ndef go(n, c):\n    while True:\n        try:\n            return n.nxt[c]\n        except KeyError:\n            if n != root:\n                n = n.fail\n            else:\n                return root\n\ndef build(ps):\n    for i, p in enumerate(ps):\n        n = root\n        for c in p:\n            try:\n                n = n.nxt[c]\n            except KeyError:\n                n = new_node(n, c)\n        n.o += 1\n\n    q = deque([root])\n    while q:\n        n = q.popleft()\n        for c, cn in n.nxt.iteritems():\n            q.append(cn)\n            if n == root:\n                cn.fail = root\n            else:\n                cn.fail = go(n.fail, c)\n            cn.o += cn.fail.o\n\ndef query(s, ar):\n    n = root\n    for i, c in enumerate(s):\n        n = go(n, c)\n        ar[i] += n.o\n\ndef main():\n    s = input()\n    ps = [input() for _ in range(int(input()))]\n\n    build(ps)\n    far = array_of(int, len(s))\n    query(s, far)\n\n    root.nxt = {}\n    root.o = 0\n\n    rps = [list(reversed(ss)) for ss in ps]\n    rs = list(reversed(s))\n\n    build(rps)\n    bar = array_of(int, len(rs))\n    query(rs, bar)\n\n    ans = 0\n    for i in range(len(s)-1):\n        ans += bar[i] * far[len(s)-2-i]\n    print(ans)\n \nINF = float('inf')\nMOD = 10**9 + 7\n \nimport os, sys\nfrom atexit import register\nfrom io import BytesIO\nimport itertools\n \nif sys.version_info[0] < 3:\n    input = raw_input\n    range = xrange\n \n    filter = itertools.ifilter\n    map = itertools.imap\n    zip = itertools.izip\n \nif 0:\n    debug_print = print\nelse:\n    sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))\n    sys.stdout = BytesIO()\n    register(lambda: os.write(1, sys.stdout.getvalue()))\n \n    input = lambda: sys.stdin.readline().rstrip('\\r\\n')\n    debug_print = lambda *x, **y: None\n \n \ndef input_as_list():\n    return list(map(int, input().split()))\n \ndef array_of(f, *dim):\n    return [array_of(f, *dim[1:]) for _ in range(dim[0])] if dim else f()\n \nmain()","tags":["strings"],"src_uid":"752c583a1773847504bf0d50b72a9dda"}
{"text_full":"[DESCRIPTION]Let's define a function $$$f(x)$$$ ($$$x$$$ is a positive integer) as follows: write all digits of the decimal representation of $$$x$$$ backwards, then get rid of the leading zeroes. For example, $$$f(321) = 123$$$, $$$f(120) = 21$$$, $$$f(1000000) = 1$$$, $$$f(111) = 111$$$.Let's define another function $$$g(x) = \\dfrac{x}{f(f(x))}$$$ ($$$x$$$ is a positive integer as well).Your task is the following: for the given positive integer $$$n$$$, calculate the number of different values of $$$g(x)$$$ among all numbers $$$x$$$ such that $$$1 \\le x \\le n$$$.[SOURCE CODE]from sys import stdin, stdout\nreadline, writeline = stdin.readline, stdout.write\n\n\ndef iint():\n    return int(readline().strip())\n\n\nfor _ in range(iint()):\n    n = readline().strip()\n    writeline(\"{}\\n\".format(len(n)))","tags":["number theory","math"],"src_uid":"ea011f93837fdf985f7eaa7a43e22cc8"}
{"text_full":"[DESCRIPTION]Igor is a post-graduate student of chemistry faculty in Berland State University (BerSU). He needs to conduct a complicated experiment to write his thesis, but laboratory of BerSU doesn't contain all the materials required for this experiment.Fortunately, chemical laws allow material transformations (yes, chemistry in Berland differs from ours). But the rules of transformation are a bit strange.Berland chemists are aware of n materials, numbered in the order they were discovered. Each material can be transformed into some other material (or vice versa). Formally, for each i (2 ≤ i ≤ n) there exist two numbers xi and ki that denote a possible transformation: ki kilograms of material xi can be transformed into 1 kilogram of material i, and 1 kilogram of material i can be transformed into 1 kilogram of material xi. Chemical processing equipment in BerSU allows only such transformation that the amount of resulting material is always an integer number of kilograms.For each i (1 ≤ i ≤ n) Igor knows that the experiment requires ai kilograms of material i, and the laboratory contains bi kilograms of this material. Is it possible to conduct an experiment after transforming some materials (or none)?[SOURCE CODE]import sys\n\n# @profile\ndef main():\n    f = sys.stdin\n    # f = open('input.txt', 'r')\n    # fo = open('log.txt', 'w')\n    n = int(f.readline())\n    # b = []\n    # for i in range(n):\n    #    b.append()\n    b = list(map(int, f.readline().strip().split(' ')))\n    a = list(map(int, f.readline().strip().split(' ')))\n    # return\n    b = [b[i] - a[i] for i in range(n)]\n    c = [[0, 0]]\n    for i in range(n - 1):\n        line = f.readline().strip().split(' ')\n        c.append([int(line[0]), int(line[1])])\n    # print(c)\n    for i in range(n - 1, 0, -1):\n        # print(i)\n        fa = c[i][0] - 1\n        if b[i] >= 0:\n            b[fa] += b[i]\n        else:\n            b[fa] += b[i] * c[i][1]\n            if b[fa] < -1e17:\n                print('NO')\n                return 0\n    # for x in b:\n    #    fo.write(str(x) + '\\n')\n    if b[0] >= 0:\n        print('YES')\n    else:\n        print('NO')\n\nmain()","tags":["trees"],"src_uid":"159f163dd6da4668f01a66ddf746eb93"}
{"text_full":"[DESCRIPTION]During a normal walk in the forest, Katie has stumbled upon a mysterious code! However, the mysterious code had some characters unreadable. She has written down this code as a string $$$c$$$ consisting of lowercase English characters and asterisks (\"*\"), where each of the asterisks denotes an unreadable character. Excited with her discovery, Katie has decided to recover the unreadable characters by replacing each asterisk with arbitrary lowercase English letter (different asterisks might be replaced with different letters).Katie has a favorite string $$$s$$$ and a not-so-favorite string $$$t$$$ and she would love to recover the mysterious code so that it has as many occurrences of $$$s$$$ as possible and as little occurrences of $$$t$$$ as possible. Formally, let's denote $$$f(x, y)$$$ as the number of occurrences of $$$y$$$ in $$$x$$$ (for example, $$$f(aababa, ab) = 2$$$). Katie wants to recover the code $$$c'$$$ conforming to the original $$$c$$$, such that $$$f(c', s) - f(c', t)$$$ is largest possible. However, Katie is not very good at recovering codes in general, so she would like you to help her out.[SOURCE CODE]import sys\nrange = xrange\ninput = raw_input\n\ndef partial(s):\n    g, pi = 0, [0] * len(s)\n    for i in range(1, len(s)):\n        while g and (s[g] != s[i]):\n            g = pi[g - 1]\n        pi[i] = g = g + (s[g] == s[i])\n\n    return pi\n\nA = input()\nB = input()\nC = input()\n\nA = [ord(c) - 97 if c != '*' else -1 for c in A]\nB = [ord(c) - 97 for c in B]\nC = [ord(c) - 97 for c in C]\n\nn = len(A)\nBB = partial(B)\nCC = partial(C)\nm = len(B)\nk = len(C)\n\ninf = 10**9\nDP = [[[-inf]*(k + 1) for i in range(m + 1)] for i in range(n + 1)]\nDP[0][0][0] = 0\nfor i in range(1, n + 1):\n    DPi = DP[i]\n    DPim1 = DP[i - 1]\n    for c in (range(0, 26) if A[i - 1] < 0 else (A[i - 1],)):\n        for a in range(m + 1):\n            newa = a\n            if newa == m:\n                newa = BB[newa - 1]\n            while newa and B[newa] != c:\n                newa = BB[newa - 1]\n            newa += B[newa] == c\n            \n            DPinewa = DPi[newa]\n            DPim1a = DPim1[a]\n            for b in range(k + 1):\n                newb = b\n                if newb == k:\n                    newb = CC[newb - 1]\n                while newb and C[newb] != c:\n                    newb = CC[newb - 1]\n                newb += C[newb] == c\n                \n                DPinewa[newb] = max(DPinewa[newb],  DPim1a[b] + (newa == m) - (newb == k))\nprint max([max(d) for d in DP[n]])","tags":["strings"],"src_uid":"ff0d972460443cc13156ede0d4a16f52"}
{"text_full":"[DESCRIPTION]Valera takes part in the Berland Marathon. The marathon race starts at the stadium that can be represented on the plane as a square whose lower left corner is located at point with coordinates (0, 0) and the length of the side equals a meters. The sides of the square are parallel to coordinate axes.As the length of the marathon race is very long, Valera needs to have extra drink during the race. The coach gives Valera a bottle of drink each d meters of the path. We know that Valera starts at the point with coordinates (0, 0) and runs counter-clockwise. That is, when Valera covers a meters, he reaches the point with coordinates (a, 0). We also know that the length of the marathon race equals nd + 0.5 meters. Help Valera's coach determine where he should be located to help Valera. Specifically, determine the coordinates of Valera's positions when he covers d, 2·d, ..., n·d meters.[SOURCE CODE]a, d = [float(el) for el in input().split()]\nn = int(input())\n\nfor i in range(1, n+1):\n    k = i*d % (4*a)\n    m = k \/\/ a\n    if m == 0:\n        x, y = k % a, 0\n    elif m == 1:\n        x, y = a , k % a\n    elif m == 2:\n        x, y = a - k % a, a\n    elif m == 3: \n        x, y = 0, a - k % a \n    print('%s %s' % (x, y))","tags":["math"],"src_uid":"d00b8423c3c52b19fec25bc63e4d4c1c"}
{"text_full":"[DESCRIPTION]Vasya became interested in bioinformatics. He's going to write an article about similar cyclic DNA sequences, so he invented a new method for determining the similarity of cyclic sequences.Let's assume that strings s and t have the same length n, then the function h(s, t) is defined as the number of positions in which the respective symbols of s and t are the same. Function h(s, t) can be used to define the function of Vasya distance ρ(s, t):  where  is obtained from string s, by applying left circular shift i times. For example, ρ(\"AGC\", \"CGT\") =  h(\"AGC\", \"CGT\") + h(\"AGC\", \"GTC\") + h(\"AGC\", \"TCG\") +  h(\"GCA\", \"CGT\") + h(\"GCA\", \"GTC\") + h(\"GCA\", \"TCG\") +  h(\"CAG\", \"CGT\") + h(\"CAG\", \"GTC\") + h(\"CAG\", \"TCG\") =  1 + 1 + 0 + 0 + 1 + 1 + 1 + 0 + 1 = 6Vasya found a string s of length n on the Internet. Now he wants to count how many strings t there are such that the Vasya distance from the string s attains maximum possible value. Formally speaking, t must satisfy the equation: .Vasya could not try all possible strings to find an answer, so he needs your help. As the answer may be very large, count the number of such strings modulo 109 + 7.[SOURCE CODE]a=int(input())\nb=input().lower()\nka=b.count('a')\nkb=b.count('c')\nkt=b.count('t')\nkg=b.count('g')\nans=0\nif ka>=kb and ka>=kt and ka>=kg:\n    km=ka\nelse:\n    if kb>=ka and kb>=kt and kb>=kg:\n        km=kb\n    else:\n        if kt>=ka and kt>=kb and kt>=kg:\n            km=kt\n        else:\n            km=kg\nif ka==km:\n    ans+=1\nif kb==km:\n    ans+=1\nif kt==km:\n    ans+=1\nif kg==km:\n    ans+=1\nif ans==1 or a==1:\n    print('1')\nelse:\n    print(str((ans**a)%(10**9+7)))","tags":["math","strings"],"src_uid":"f35c042f23747988f65c5b5e8d5ddacd"}
{"text_full":"[DESCRIPTION]You are given string s. Let's call word any largest sequence of consecutive symbols without symbols ',' (comma) and ';' (semicolon). For example, there are four words in string \"aba,123;1a;0\": \"aba\", \"123\", \"1a\", \"0\". A word can be empty: for example, the string s=\";;\" contains three empty words separated by ';'.You should find all words in the given string that are nonnegative INTEGER numbers without leading zeroes and build by them new string a. String a should contain all words that are numbers separating them by ',' (the order of numbers should remain the same as in the string s). By all other words you should build string b in the same way (the order of numbers should remain the same as in the string s).Here strings \"101\", \"0\" are INTEGER numbers, but \"01\" and \"1.0\" are not.For example, for the string aba,123;1a;0 the string a would be equal to \"123,0\" and string b would be equal to \"aba,1a\".[SOURCE CODE]s = input()\na = s.replace(';', ',').split(',')\nc, d = [], []\n\nfor elem in a:\n    if elem.isdigit() and (elem[0] != '0' or len(elem) == 1):\n        c.append(elem)\n    else:\n        d.append(elem)\nif (len(c) == 0):\n    print('-')\n    #print('\"' + ','.join(c) + '\"')\n    print('\"' + ','.join(d) + '\"')    \nelif (len(d) == 0):\n    print('\"' + ','.join(c) + '\"')\n    #print('\"' + ','.join(d) + '\"')    \n    print('-')\nelse:\n    print('\"' + ','.join(c) + '\"')\n    print('\"' + ','.join(d) + '\"')","tags":["strings"],"src_uid":"ad02cead427d0765eb642203d13d3b99"}
{"text_full":"[DESCRIPTION]Barney lives in country USC (United States of Charzeh). USC has n cities numbered from 1 through n and n - 1 roads between them. Cities and roads of USC form a rooted tree (Barney's not sure why it is rooted). Root of the tree is the city number 1. Thus if one will start his journey from city 1, he can visit any city he wants by following roads.  Some girl has stolen Barney's heart, and Barney wants to find her. He starts looking for in the root of the tree and (since he is Barney Stinson not a random guy), he uses a random DFS to search in the cities. A pseudo code of this algorithm is as follows:let starting_time be an array of length ncurrent_time = 0dfs(v):\tcurrent_time = current_time + 1\tstarting_time[v] = current_time\tshuffle children[v] randomly (each permutation with equal possibility)\t\/\/ children[v] is vector of children cities of city v\tfor u in children[v]:\t\tdfs(u)As told before, Barney will start his journey in the root of the tree (equivalent to call dfs(1)).Now Barney needs to pack a backpack and so he wants to know more about his upcoming journey: for every city i, Barney wants to know the expected value of starting_time[i]. He's a friend of Jon Snow and knows nothing, that's why he asked for your help.[SOURCE CODE]n = int(input())\nif n ==1:\n    print(1)\n    exit(0)\nl = list(map(int,input().split()))\nw = [[]for i in range(n)]\nsz = [1]*n\nfor i in range(n-1):\n    w[l[i]-1].append(i+1)\nfor i in range(n-1,-1,-1):\n    for j in range(len(w[i])):\n        sz[i]+=sz[w[i][j]]\nans = [0]*n\nfor i in range(n):\n    for j in range(len(w[i])):\n        ans[w[i][j]] = ans[i]+1+(sz[i]-1-sz[w[i][j]])\/2\nfor i in range(n):\n    print(ans[i]+1,end = \" \")","tags":["probabilities","trees","math"],"src_uid":"750e1d9e43f916699537705c11d64d29"}
{"text_full":"[DESCRIPTION]Old timers of Summer Informatics School can remember previous camps in which each student was given a drink of his choice on the vechorka (late-evening meal). Or may be the story was more complicated?There are $$$n$$$ students living in a building, and for each of them the favorite drink $$$a_i$$$ is known. So you know $$$n$$$ integers $$$a_1, a_2, \\dots, a_n$$$, where $$$a_i$$$ ($$$1 \\le a_i \\le k$$$) is the type of the favorite drink of the $$$i$$$-th student. The drink types are numbered from $$$1$$$ to $$$k$$$.There are infinite number of drink sets. Each set consists of exactly two portions of the same drink. In other words, there are $$$k$$$ types of drink sets, the $$$j$$$-th type contains two portions of the drink $$$j$$$. The available number of sets of each of the $$$k$$$ types is infinite.You know that students will receive the minimum possible number of sets to give all students exactly one drink. Obviously, the number of sets will be exactly $$$\\lceil \\frac{n}{2} \\rceil$$$, where $$$\\lceil x \\rceil$$$ is $$$x$$$ rounded up.After students receive the sets, they will distribute their portions by their choice: each student will get exactly one portion. Note, that if $$$n$$$ is odd then one portion will remain unused and the students' teacher will drink it.What is the maximum number of students that can get their favorite drink if $$$\\lceil \\frac{n}{2} \\rceil$$$ sets will be chosen optimally and students will distribute portions between themselves optimally?[SOURCE CODE]import math\nn, k = map(int, input().split())\na = [0] * k\nfor i in range(n):\n    temp = int(input())\n    a[temp-1] += 1\nnSet = math.ceil(n\/2)\n\nans = 0\n# First deal with situation where a[i] > 1\nfor i in range(k):\n    while a[i] > 1 and nSet > 0:\n        ans += 2\n        nSet -= 1\n        a[i] -= 2\n# Then deal with only one left situation for each drink\nfor i in range(k):\n    while a[i] > 0 and nSet > 0:\n        ans += 1\n        nSet -= 1\n        a[i] -= 1\nprint(ans)","tags":["math"],"src_uid":"dceeb739a56bb799550138aa8c127996"}
{"text_full":"[DESCRIPTION]Three friends are going to meet each other. Initially, the first friend stays at the position $$$x = a$$$, the second friend stays at the position $$$x = b$$$ and the third friend stays at the position $$$x = c$$$ on the coordinate axis $$$Ox$$$.In one minute each friend independently from other friends can change the position $$$x$$$ by $$$1$$$ to the left or by $$$1$$$ to the right (i.e. set $$$x := x - 1$$$ or $$$x := x + 1$$$) or even don't change it.Let's introduce the total pairwise distance — the sum of distances between each pair of friends. Let $$$a'$$$, $$$b'$$$ and $$$c'$$$ be the final positions of the first, the second and the third friend, correspondingly. Then the total pairwise distance is $$$|a' - b'| + |a' - c'| + |b' - c'|$$$, where $$$|x|$$$ is the absolute value of $$$x$$$.Friends are interested in the minimum total pairwise distance they can reach if they will move optimally. Each friend will move no more than once. So, more formally, they want to know the minimum total pairwise distance they can reach after one minute.You have to answer $$$q$$$ independent test cases.[SOURCE CODE]for _ in range(int(input())):\n    a, b, c = map(int, input().split())\n    x = abs(a - b) + abs(a - c) + abs(b - c)\n    print(max(0, x - 4))","tags":["math"],"src_uid":"18f2e54e4147e8887da737d5b6639473"}
{"text_full":"[DESCRIPTION]You have given tree consist of $$$n$$$ vertices. Select a vertex as root vertex that satisfies the condition below.  For all vertices $$$v_{1}$$$ and $$$v_{2}$$$, if $$$distance$$$($$$root$$$, $$$v_{1}$$$) $$$= distance$$$($$$root$$$, $$$v_{2})$$$ then $$$degree$$$($$$v_{1}$$$) $$$= degree$$$($$$v_{2}$$$), where $$$degree$$$ means the number of vertices connected to that vertex, and $$$distance$$$ means the number of edges between two vertices. Determine and find if there is such root vertex in the tree. If there are multiple answers, find any of them.[SOURCE CODE]#!\/usr\/bin\/env python\ndef longest_path():\n    try:\n        d = [-1 for _ in range(n)]\n        d[0] = 0; q = [0]\n        for i in range(n):\n            f = q[i]\n            for t in g[f]:\n                if d[t] == -1:\n                    q.append(t)\n                    d[t] = d[f] + 1\n        u = q[-1]\n        d = [-1 for _ in range(n)]\n        p = [-1 for _ in range(n)]\n        d[u] = 0; q = [u]\n        for i in range(n):\n            f = q[i]\n            for t in g[f]:\n                if d[t] == -1:\n                    q.append(t)\n                    d[t] = d[f] + 1\n                    p[t] = f\n        v = q[-1]\n        ld = d[v]\n        w = v\n        if ld & 1:\n            return u, v, None\n        while d[w] != (ld >> 1):\n            w = p[w]\n        return u, v, w\n    except:\n        print(f'Error raised in longest_path()')\n\n\ndef top(u):\n    try:\n        if u is None:\n            return False\n        dist = [-1 for _ in range(n)]\n        deg = [-1 for _ in range(n)]\n        dist[u] = 0; q = [u]\n        for i in range(n):\n            f = q[i]\n            if deg[dist[f]] == -1:\n                deg[dist[f]] = len(g[f])\n            elif len(g[f]) != deg[dist[f]]:\n                return False\n            for t in g[f]:\n                if dist[t] == -1:\n                    q.append(t)\n                    dist[t] = dist[f] + 1\n        return True\n    except:\n        print(f'Error raised in top({u})')\n\n\ndef semitop(w):\n    try:\n        if w is None:\n            return False, None\n        d = [-1 for _ in range(n)]\n        d[w] = 0; q = [w]; i = 0\n        while i < len(q):\n            f = q[i]\n            for t in g[f]:\n                if d[t] == -1:\n                    if len(g[t]) != 2:\n                        d[t] = 100_500\n                        if top(t):\n                            return True, t\n                    else:\n                        d[t] = d[f] + 1\n                        q.append(t)\n            i += 1\n        return False, None\n    except:\n        print(f'Error raised in semitop({w})')\n\n\ntry:\n    n = int(input())\n    g = [[] for _ in range(n)]\n    for _ in range(n - 1):\n        u, v = map(lambda _: int(_) - 1, input().split())\n        g[u].append(v); g[v].append(u)\n    u, v, w = longest_path()\n\n    if top(u):\n        print(u + 1)\n    elif top(v):\n        print(v + 1)\n    elif top(w):\n        print(w + 1)\n    else:\n        k, t = semitop(w)\n        if k:\n            print(t + 1)\n        else:\n            print(-1)\nexcept:\n    print(f'Error raised in main')","tags":["trees"],"src_uid":"0372790cbc07605c7e618dc14196fc67"}
{"text_full":"[DESCRIPTION]User ainta loves to play with cards. He has a cards containing letter \"o\" and b cards containing letter \"x\". He arranges the cards in a row, and calculates the score of the deck by the formula below.  At first, the score is 0.  For each block of contiguous \"o\"s with length x the score increases by x2.  For each block of contiguous \"x\"s with length y the score decreases by y2.   For example, if a = 6, b = 3 and ainta have arranged the cards in the order, that is described by string \"ooxoooxxo\", the score of the deck equals 22 - 12 + 32 - 22 + 12 = 9. That is because the deck has 5 blocks in total: \"oo\", \"x\", \"ooo\", \"xx\", \"o\".User ainta likes big numbers, so he wants to maximize the score with the given cards. Help ainta make the score as big as possible. Note, that he has to arrange all his cards.[SOURCE CODE]a, b = map(int, input().split())\nsx = lambda p: (a - p + 1) ** 2 + p - 1\nsy = lambda q: (b % q) * (1 + b \/\/ q) ** 2 + (b \/\/ q) ** 2 * (q - b % q)\nn = min(a, b)\n\nif a == 0:\n    print( -b ** 2)\n    print( b * \"x\" )\n\nelif b <= 1:\n    print( a ** 2 - b ** 2 )\n    print ( a * \"o\" + b * \"x\" )\n\nelse:\n    res = - (a + b) ** 2\n    for p in range(1, n + 1):\n        for q in range(p-1, p+2):\n            if(1 <= q <= b):\n                pos = sx( p )\n                neg = sy( q )\n                if res < pos - neg:\n                    res = pos - neg\n                    res_p = p\n                    res_q = q\n    print( res )\n\n    s = \"\"\n    if res_p >= res_q:\n        for i in range(res_p):\n            wl = 1 if i > 0 else a - (res_p-1)\n            s += wl * \"x\"\n            ll = b \/\/ res_q + 1 if i < b % res_q else b \/\/ res_q\n            if i < res_q: s += ll * \"o\"\n    else:\n        for i in range(res_q):\n            ll = b \/\/ res_q + 1 if i < b % res_q else b \/\/ res_q;\n            s += ll * \"x\"\n            wl = 1 if i > 0 else a - (res_p-1)\n            if i < res_p: s+= wl * \"o\"\n    print( s )","tags":["number theory"],"src_uid":"c9785cd72988c80b72c3d09691e8db6c"}
{"text_full":"[DESCRIPTION]Polycarp wants to buy exactly $$$n$$$ shovels. The shop sells packages with shovels. The store has $$$k$$$ types of packages: the package of the $$$i$$$-th type consists of exactly $$$i$$$ shovels ($$$1 \\le i \\le k$$$). The store has an infinite number of packages of each type.Polycarp wants to choose one type of packages and then buy several (one or more) packages of this type. What is the smallest number of packages Polycarp will have to buy to get exactly $$$n$$$ shovels?For example, if $$$n=8$$$ and $$$k=7$$$, then Polycarp will buy $$$2$$$ packages of $$$4$$$ shovels.Help Polycarp find the minimum number of packages that he needs to buy, given that he:   will buy exactly $$$n$$$ shovels in total;  the sizes of all packages he will buy are all the same and the number of shovels in each package is an integer from $$$1$$$ to $$$k$$$, inclusive.[SOURCE CODE]for _ in range(int(input())):\n    n,k=map(int,input().split())\n    i=2\n    c=[]\n    s=int(n**0.5)+1\n    while i<=k and i<s:\n        if n%i==0:\n            c.append(i)\n            if n\/\/i<=k:\n                c.append(n\/\/i)\n        i+=1\n    if k>=n:\n        print(1)\n    elif n%k==0:\n        print(n\/\/k)\n    elif len(c)>0:\n        print(n\/\/max(c))\n    else:\n        print(n)","tags":["number theory","math"],"src_uid":"f00eb0452f5933103f1f77ef06473c6a"}
{"text_full":"[DESCRIPTION]It's Petya's birthday party and his friends have presented him a brand new \"Electrician-$$$n$$$\" construction set, which they are sure he will enjoy as he always does with weird puzzles they give him.Construction set \"Electrician-$$$n$$$\" consists of $$$2n - 1$$$ wires and $$$2n$$$ light bulbs. Each bulb has its own unique index that is an integer from $$$1$$$ to $$$2n$$$, while all wires look the same and are indistinguishable. In order to complete this construction set one has to use each of the wires to connect two distinct bulbs. We define a chain in a completed construction set as a sequence of distinct bulbs of length at least two, such that every two consecutive bulbs in this sequence are directly connected by a wire. Completed construction set configuration is said to be correct if a resulting network of bulbs and wires has a tree structure, i.e. any two distinct bulbs are the endpoints of some chain.Petya was assembling different configurations for several days, and he noticed that sometimes some of the bulbs turn on. After a series of experiments he came up with a conclusion that bulbs indexed $$$2i$$$ and $$$2i - 1$$$ turn on if the chain connecting them consists of exactly $$$d_i$$$ wires. Moreover, the following important condition holds: the value of $$$d_i$$$ is never greater than $$$n$$$.Petya did his best but was not able to find a configuration that makes all bulbs to turn on, so he seeks your assistance. Please, find out a configuration that makes all bulbs shine. It is guaranteed that such configuration always exists.[SOURCE CODE]# https:\/\/codeforces.com\/contest\/1214\/problem\/E\nn = int(input())\nd = map(int, input().split())\n\nd = [[2*i+1, di] for i, di in enumerate(d)]\nd = sorted(d, key=lambda x:x[1], reverse = True)\n\nedge = []\narr  = [x[0] for x in d]\n\nfor i, [x, d_] in enumerate(d):\n    if i + d_ - 1 == len(arr) - 1:\n        arr.append(x+1)\n    edge.append([arr[i + d_ - 1], x+1])    \n    \nfor u, v in zip(d[:-1], d[1:]):\n    edge.append([u[0], v[0]])\n    \nans = '\\n'.join([str(u)+' '+str(v) for u, v in edge])\nprint(ans)","tags":["graphs","math","trees"],"src_uid":"61bb5f2b315eddf2e658e3f54d8f43b8"}
{"text_full":"[DESCRIPTION]Seryozha has a very changeable character. This time he refused to leave the room to Dima and his girlfriend (her hame is Inna, by the way). However, the two lovebirds can always find a way to communicate. Today they are writing text messages to each other.Dima and Inna are using a secret code in their text messages. When Dima wants to send Inna some sentence, he writes out all words, inserting a heart before each word and after the last word. A heart is a sequence of two characters: the \"less\" characters (&lt;) and the digit three (3). After applying the code, a test message looks like that: &lt;3word1&lt;3word2&lt;3 ... wordn&lt;3.Encoding doesn't end here. Then Dima inserts a random number of small English characters, digits, signs \"more\" and \"less\" into any places of the message.Inna knows Dima perfectly well, so she knows what phrase Dima is going to send her beforehand. Inna has just got a text message. Help her find out if Dima encoded the message correctly. In other words, find out if a text message could have been received by encoding in the manner that is described above.[SOURCE CODE]s=list('<3'+'<3'.join(raw_input() for _ in range(input()))+'<3')\nt=list(raw_input())\nwhile s and t:\n    if s[-1]==t[-1]:s.pop()\n    t.pop()\nprint 'no' if s else 'yes'","tags":["strings"],"src_uid":"36fb3a01860ef0cc2a1065d78e4efbd5"}
{"text_full":"[DESCRIPTION]Dreamoon likes sequences very much. So he created a problem about the sequence that you can't find in OEIS: You are given two integers $$$d, m$$$, find the number of arrays $$$a$$$, satisfying the following constraints:  The length of $$$a$$$ is $$$n$$$, $$$n \\ge 1$$$  $$$1 \\le a_1 &lt; a_2 &lt; \\dots &lt; a_n \\le d$$$  Define an array $$$b$$$ of length $$$n$$$ as follows: $$$b_1 = a_1$$$, $$$\\forall i &gt; 1, b_i = b_{i - 1} \\oplus a_i$$$, where $$$\\oplus$$$ is the bitwise exclusive-or (xor). After constructing an array $$$b$$$, the constraint $$$b_1 &lt; b_2 &lt; \\dots &lt; b_{n - 1} &lt; b_n$$$ should hold. Since the number of possible arrays may be too large, you need to find the answer modulo $$$m$$$.[SOURCE CODE]t=int(input())\nfor q in range(t):\n    n,m=map(int,input().split())\n    st=1\n    ans=1\n    while st<=n:\n        ans*=min(st*2-st+1,n-st+2)\n        st*=2\n    print((ans-1)%m)","tags":["math"],"src_uid":"12157ec4a71f0763a898172b38ff1ef2"}
{"text_full":"[DESCRIPTION]You are given two strings $$$s$$$ and $$$t$$$ consisting of lowercase Latin letters. Also you have a string $$$z$$$ which is initially empty. You want string $$$z$$$ to be equal to string $$$t$$$. You can perform the following operation to achieve this: append any subsequence of $$$s$$$ at the end of string $$$z$$$. A subsequence is a sequence that can be derived from the given sequence by deleting zero or more elements without changing the order of the remaining elements. For example, if $$$z = ac$$$, $$$s = abcde$$$, you may turn $$$z$$$ into following strings in one operation:   $$$z = acace$$$ (if we choose subsequence $$$ace$$$);  $$$z = acbcd$$$ (if we choose subsequence $$$bcd$$$);  $$$z = acbce$$$ (if we choose subsequence $$$bce$$$). Note that after this operation string $$$s$$$ doesn't change.Calculate the minimum number of such operations to turn string $$$z$$$ into string $$$t$$$.[SOURCE CODE]#!\/usr\/bin\/env pypy\nfrom __future__ import division, print_function\nfrom collections import defaultdict, Counter, deque\nfrom future_builtins import ascii, filter, hex, map, oct, zip\nfrom itertools import imap as map, izip as zip, permutations, combinations, combinations_with_replacement\nfrom __builtin__ import xrange as range\nfrom math import ceil, factorial\nfrom _continuation import continulet\nfrom cStringIO import StringIO\nfrom io import IOBase\nimport __pypy__\nfrom bisect import bisect, insort, bisect_left, bisect_right\nfrom fractions import Fraction\nfrom functools import reduce\nimport sys\nimport os\nimport re\ninf = float('inf')\nmod_ = int(1e9) + 7\nmod = 998244353\n\n\ndef main():\n\tfor _ in range(int(input())):\n\t\ts = input()\n\t\tt = input()\n\t\tposition = defaultdict(list)\n\t\tfor i in range(len(s)):\n\t\t\tposition[s[i]].append(i)\n\n\t\tans, tind, sind = 1, 0, 0\n\t\tfor tind in range(len(t)):\n\t\t\tif t[tind] not in position:\n\t\t\t\tprint(-1)\n\t\t\t\tbreak\n\t\t\tcind = bisect_left(position[t[tind]], sind)\n\t\t\tif cind == len(position[t[tind]]):\n\t\t\t\tsind = position[t[tind]][0] + 1\n\t\t\t\tans += 1\n\t\t\telse:\n\t\t\t\tsind = position[t[tind]][cind] + 1\n\t\telse:\n\t\t\tprint(ans)\n\n\nBUFSIZE = 8192\nclass FastI(IOBase):\n\tdef __init__(self, file):\n\t\tself._fd = file.fileno()\n\t\tself._buffer = StringIO()\n\t\tself.newlines = 0\n\n\tdef read(self):\n\t\twhile True:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tif not b:\n\t\t\t\tbreak\n\t\t\tptr = self.buffer.tell()\n\t\t\tself.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n\t\tself.newlines = 0\n\t\treturn self.buffer.read()\n\n\tdef readline(self):\n\t\twhile self.newlines == 0:\n\t\t\tb = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n\t\t\tself.newlines = b.count(\"\\n\") + (not b)\n\t\t\tptr = self._buffer.tell()\n\t\t\tself._buffer.seek(0, 2), self._buffer.write(\n\t\t\t\tb), self._buffer.seek(ptr)\n\t\tself.newlines -= 1\n\t\treturn self._buffer.readline()\nclass FastO(IOBase):\n\tdef __init__(self, file):\n\t\tself._fd = file.fileno()\n\t\tself._buffer = __pypy__.builders.StringBuilder()\n\t\tself.write = lambda s: self._buffer.append(s)\n\n\tdef flush(self):\n\t\tos.write(self._fd, self._buffer.build())\n\t\tself._buffer = __pypy__.builders.StringBuilder()\ndef print(*args, **kwargs):\n\tsep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n\tat_start = True\n\tfor x in args:\n\t\tif not at_start:\n\t\t\tfile.write(sep)\n\t\tfile.write(str(x))\n\t\tat_start = False\n\tfile.write(kwargs.pop(\"end\", \"\\n\"))\n\tif kwargs.pop(\"flush\", False):\n\t\tfile.flush()\ndef gcd(x, y):\n\twhile y:\n\t\tx, y = y, x % y\n\treturn x\nsys.stdin, sys.stdout = FastI(sys.stdin), FastO(sys.stdout)\ndef input(): return sys.stdin.readline().rstrip(\"\\r\\n\")\nif __name__ == \"__main__\":\n\tdef bootstrap(cont):\n\t\tcall, arg = cont.switch()\n\t\twhile True:\n\t\t\tcall, arg = cont.switch(to=continulet(\n\t\t\t\tlambda _, f, args: f(*args), call, arg))\n\tcont = continulet(bootstrap)\n\tcont.switch()\n\tmain()","tags":["strings"],"src_uid":"d132158607bbd0541f2232a300e4a1b1"}
{"text_full":"[DESCRIPTION]The only difference between easy and hard versions is constraints.If you write a solution in Python, then prefer to send it in PyPy to speed up execution time.A session has begun at Beland State University. Many students are taking exams.Polygraph Poligrafovich is going to examine a group of $$$n$$$ students. Students will take the exam one-by-one in order from $$$1$$$-th to $$$n$$$-th. Rules of the exam are following:  The $$$i$$$-th student randomly chooses a ticket.  if this ticket is too hard to the student, he doesn't answer and goes home immediately (this process is so fast that it's considered no time elapses). This student fails the exam.  if the student finds the ticket easy, he spends exactly $$$t_i$$$ minutes to pass the exam. After it, he immediately gets a mark and goes home. Students take the exam in the fixed order, one-by-one, without any interruption. At any moment of time, Polygraph Poligrafovich takes the answer from one student.The duration of the whole exam for all students is $$$M$$$ minutes ($$$\\max t_i \\le M$$$), so students at the end of the list have a greater possibility to run out of time to pass the exam.For each student $$$i$$$, you should count the minimum possible number of students who need to fail the exam so the $$$i$$$-th student has enough time to pass the exam.For each student $$$i$$$, find the answer independently. That is, if when finding the answer for the student $$$i_1$$$ some student $$$j$$$ should leave, then while finding the answer for $$$i_2$$$ ($$$i_2&gt;i_1$$$) the student $$$j$$$ student does not have to go home.[SOURCE CODE]from sys import stdin,stdout\nn,m = [int(x) for x in stdin.readline().split()] \na = [int(x) for x in stdin.readline().split()] \nA = []\nd ={}\nfor i in range(1,101):\n\td[i] = 0\nfor j in range(n):\n\tans = 0\n\tsm = a[j]\n\t# print sm\n\tfor i in range(1,101):\n\t\tif (sm + (i * d[i]) > m):\n\t\t\tans += (m - sm) \/ i;\n\t\t\tbreak\n\t\telse:\n\t\t\tsm += (d[i] * i);\n\t\t\tans += d[i];\n\td[a[j]]+=1\n\t# print \"40:\",d[40]\n\tstdout.write(str(j-ans)+\" \"),","tags":["math"],"src_uid":"fe3a6f0d33b1b5b8018e1810ba8ebdd6"}
{"text_full":"[DESCRIPTION]There are $$$n$$$ lamps on a line, numbered from $$$1$$$ to $$$n$$$. Each one has an initial state off ($$$0$$$) or on ($$$1$$$).You're given $$$k$$$ subsets $$$A_1, \\ldots, A_k$$$ of $$$\\{1, 2, \\dots, n\\}$$$, such that the intersection of any three subsets is empty. In other words, for all $$$1 \\le i_1 &lt; i_2 &lt; i_3 \\le k$$$, $$$A_{i_1} \\cap A_{i_2} \\cap A_{i_3} = \\varnothing$$$.In one operation, you can choose one of these $$$k$$$ subsets and switch the state of all lamps in it. It is guaranteed that, with the given subsets, it's possible to make all lamps be simultaneously on using this type of operation.Let $$$m_i$$$ be the minimum number of operations you have to do in order to make the $$$i$$$ first lamps be simultaneously on. Note that there is no condition upon the state of other lamps (between $$$i+1$$$ and $$$n$$$), they can be either off or on.You have to compute $$$m_i$$$ for all $$$1 \\le i \\le n$$$.[SOURCE CODE]import sys\nrange = xrange\ninput = raw_input\n \nn, k = [int(x) for x in input().split()]\nA = [+(c == '0') for c in input()]\ninp = [int(x) for x in sys.stdin.read().split()]; ii = 0\n\nB = []\nfor _ in range(k):\n    m = inp[ii]; ii += 1\n    B.append([a - 1 for a in inp[ii: ii + m]]); ii += m\n\nbuckets = [[] for _ in range(n)]\nfor j in range(k):\n    for a in B[j]:\n        buckets[a].append(j)\n\n#####################\nparent = list(range(2 * k))\nsize = [1] * (2 * k)\nstate = [0] * (2 * k)\ntrue = [1] * k + [0] * k\ncost = 0\n\n\ndef find(a):\n    acopy = a\n    while a != parent[a]:\n        a = parent[a]\n    while acopy != a:\n        parent[acopy], acopy = a, parent[acopy]\n    return a\n\ndef calcer(a):\n    a = find(a)\n    b = find((a + k) % (2 * k))\n    if state[a] == 0:\n        return min(true[a], true[b])\n    elif state[a] == 1:\n        return true[b]\n    else:\n        return true[a]\n\ndef union(a, b):\n    a, b = find(a), find(b)\n    if a != b:\n        if size[a] < size[b]:\n            a, b = b, a\n\n        parent[b] = a\n        size[a] += size[b]\n        state[a] |= state[b]\n        true[a] += true[b]\n\ndef on(a):\n    global cost\n    a = find(a)\n    if state[a] == 0:\n        b = find((a + k) % (2 * k))\n        cost -= calcer(a)\n        state[a] = 1\n        state[b] = 2 \n        cost += calcer(a)\n\ndef same(a, b):\n    global cost\n    a = find(a)\n    b = find(b)\n    if a != b:\n        cost -= calcer(a)\n        cost -= calcer(b)\n        union(a, b)\n        union((a + k) % (2 * k), (b + k) % (2 * k))\n        cost += calcer(a)\n\n######\n\nout = []\nfor i in range(n):\n    bucket = buckets[i]\n    if not bucket:\n        pass\n    elif len(bucket) == 1:\n        j = bucket[0]\n        if not A[i]:\n            on(j)\n        else:\n            on(j + k)\n    else:\n        j1, j2 = bucket\n        if not A[i]:\n            same(j1, j2)\n        else:\n            same(j1, j2 + k)\n    out.append(cost)\nprint '\\n'.join(str(x) for x in out)","tags":["graphs"],"src_uid":"10e6b62d5b1abf8e1ba964a38dc6a9e8"}
{"text_full":"[DESCRIPTION]Breaking Good is a new video game which a lot of gamers want to have. There is a certain level in the game that is really difficult even for experienced gamers.Walter William, the main character of the game, wants to join a gang called Los Hermanos (The Brothers). The gang controls the whole country which consists of n cities with m bidirectional roads connecting them. There is no road is connecting a city to itself and for any two cities there is at most one road between them. The country is connected, in the other words, it is possible to reach any city from any other city using the given roads. The roads aren't all working. There are some roads which need some more work to be performed to be completely functioning.The gang is going to rob a bank! The bank is located in city 1. As usual, the hardest part is to escape to their headquarters where the police can't get them. The gang's headquarters is in city n. To gain the gang's trust, Walter is in charge of this operation, so he came up with a smart plan.First of all the path which they are going to use on their way back from city 1 to their headquarters n must be as short as possible, since it is important to finish operation as fast as possible.Then, gang has to blow up all other roads in country that don't lay on this path, in order to prevent any police reinforcements. In case of non-working road, they don't have to blow up it as it is already malfunctional. If the chosen path has some roads that doesn't work they'll have to repair those roads before the operation.Walter discovered that there was a lot of paths that satisfied the condition of being shortest possible so he decided to choose among them a path that minimizes the total number of affected roads (both roads that have to be blown up and roads to be repaired).Can you help Walter complete his task and gain the gang's trust?[SOURCE CODE]from sys import *\nfrom collections import *\ns = stdin.read().split()\nd = list(map(int, s))\nn, m = d[:2]\ng = [[] for i in range(n + 1)]\nfor j in range(m):\n    i = 3 * j + 2\n    g[d[i]].append((d[i + 1], d[i + 2], j))\n    g[d[i + 1]].append((d[i], d[i + 2], j))\nu, v = [-1] * n + [0], [1e9] * n + [0]\nx, y = [0] * (n + 1), [0] * (n + 1)\nq = deque([n])\nwhile q:\n    a = q.popleft()\n    for b, k, i in g[a]:\n        if v[b] == 1e9: q.append(b)\n        if v[b] > v[a] and u[b] < u[a] + k:\n            v[b] = v[a] + 1\n            u[b] = u[a] + k\n            x[b], y[b] = a, i\na, t = 1, [0] * m\nwhile a != n: t[y[a]], a = 1, x[a]\nl = []\nfor j in range(m):\n    i = 3 * j + 2\n    if d[i + 2] != t[j]:\n        l.append(' '.join([s[i], s[i + 1], str(t[j])]))\nprint(len(l))\nprint('\\n'.join(l))","tags":["graphs"],"src_uid":"a7d3548c4bc356b4bcd40fca7fe839b2"}
{"text_full":"[DESCRIPTION]Dwarfs have planted a very interesting plant, which is a triangle directed \"upwards\". This plant has an amusing feature. After one year a triangle plant directed \"upwards\" divides into four triangle plants: three of them will point \"upwards\" and one will point \"downwards\". After another year, each triangle plant divides into four triangle plants: three of them will be directed in the same direction as the parent plant, and one of them will be directed in the opposite direction. Then each year the process repeats. The figure below illustrates this process.  Help the dwarfs find out how many triangle plants that point \"upwards\" will be in n years.[SOURCE CODE]n = int(input())\n\nmod = 10**9 +7\n\ndef power_2_k(k):\n    if k == 0:\n        return 1\n    if k % 2 == 0:\n        lower = power_2_k(k \/\/ 2)\n        return (lower * lower) % mod\n    else:\n        k -= 1\n        lower = power_2_k(k \/\/ 2)\n        return (((lower * lower) % mod) * 2) % mod\n\np = power_2_k(n)\nprint((p * (p + 1) \/\/ 2) % mod)","tags":["math"],"src_uid":"782b819eb0bfc86d6f96f15ac09d5085"}
{"text_full":"[DESCRIPTION]Inna and Dima decided to surprise Sereja. They brought a really huge candy matrix, it's big even for Sereja! Let's number the rows of the giant matrix from 1 to n from top to bottom and the columns — from 1 to m, from left to right. We'll represent the cell on the intersection of the i-th row and j-th column as (i, j). Just as is expected, some cells of the giant candy matrix contain candies. Overall the matrix has p candies: the k-th candy is at cell (xk, yk).The time moved closer to dinner and Inna was already going to eat p of her favourite sweets from the matrix, when suddenly Sereja (for the reason he didn't share with anyone) rotated the matrix x times clockwise by 90 degrees. Then he performed the horizontal rotate of the matrix y times. And then he rotated the matrix z times counterclockwise by 90 degrees. The figure below shows how the rotates of the matrix looks like.  Inna got really upset, but Duma suddenly understood two things: the candies didn't get damaged and he remembered which cells contained Inna's favourite sweets before Sereja's strange actions. Help guys to find the new coordinates in the candy matrix after the transformation Sereja made![SOURCE CODE]a=raw_input().split()\nn=int(a[0])\nm=int(a[1])\nx=int(a[2])\ny=int(a[3])\nz=int(a[4])\np=int(a[5])\nlis=[]\nfor i in range(p):\n    b=raw_input().split()\n    c=int(b[0])\n    d=int(b[1])\n    lis.append((c,d))\ndef flip(lis,y,p,m):\n    for i in range(y%2):\n        for k in range(p):\n            lis[k]=(lis[k][0],m+1-lis[k][1])\ndef ro(lis,rot,p,n,m):\n    if rot==1:\n        for k in range(p):\n            lis[k]=(lis[k][1],n+1-lis[k][0])\n    if rot==2:\n        for k in range(p):\n            lis[k]=(n+1-lis[k][0],m+1-lis[k][1])\n    if rot==3:\n        for k in range(p):\n            lis[k]=(m+1-lis[k][1],lis[k][0])\nro(lis,x%4,p,n,m)\nif x%2==1:\n    n,m=m,n\nflip(lis,y,p,m)\nro(lis,(0-z)%4,p,n,m)\nfor i in lis:\n    print i[0], i[1]","tags":["math"],"src_uid":"14a56443e48c52c118788bd5c0031b0c"}
{"text_full":"[DESCRIPTION]Sensation, sensation in the two-dimensional kingdom! The police have caught a highly dangerous outlaw, member of the notorious \"Pihters\" gang. The law department states that the outlaw was driving from the gang's headquarters in his car when he crashed into an ice cream stall. The stall, the car, and the headquarters each occupies exactly one point on the two-dimensional kingdom.The outlaw's car was equipped with a GPS transmitter. The transmitter showed that the car made exactly n movements on its way from the headquarters to the stall. A movement can move the car from point (x, y) to one of these four points: to point (x - 1, y) which we will mark by letter \"L\", to point (x + 1, y) — \"R\", to point (x, y - 1) — \"D\", to point (x, y + 1) — \"U\".The GPS transmitter is very inaccurate and it doesn't preserve the exact sequence of the car's movements. Instead, it keeps records of the car's possible movements. Each record is a string of one of these types: \"UL\", \"UR\", \"DL\", \"DR\" or \"ULDR\". Each such string means that the car made a single movement corresponding to one of the characters of the string. For example, string \"UL\" means that the car moved either \"U\", or \"L\".You've received the journal with the outlaw's possible movements from the headquarters to the stall. The journal records are given in a chronological order. Given that the ice-cream stall is located at point (0, 0), your task is to print the number of different points that can contain the gang headquarters (that is, the number of different possible locations of the car's origin).[SOURCE CODE]#!\/usr\/local\/bin\/python3\n\nn = int(input())\n\nw = 1\nh = 1\n\nfor _ in range(n):\n    s = input()\n    if s == 'ULDR':\n        w += 1\n        h += 1\n        continue\n    if s == 'UR' or s == 'DL':\n        w += 1\n        continue\n    h += 1\n\nprint(w * h)","tags":["math"],"src_uid":"566b91c278449e8eb3c724a6f00797e8"}
{"text_full":"[DESCRIPTION]The length of the longest common prefix of two strings $$$s = s_1 s_2 \\ldots s_n$$$ and $$$t = t_1 t_2 \\ldots t_m$$$ is defined as the maximum integer $$$k$$$ ($$$0 \\le k \\le min(n,m)$$$) such that $$$s_1 s_2 \\ldots s_k$$$ equals $$$t_1 t_2 \\ldots t_k$$$.Koa the Koala initially has $$$n+1$$$ strings $$$s_1, s_2, \\dots, s_{n+1}$$$.For each $$$i$$$ ($$$1 \\le i \\le n$$$) she calculated $$$a_i$$$ — the length of the longest common prefix of $$$s_i$$$ and $$$s_{i+1}$$$.Several days later Koa found these numbers, but she couldn't remember the strings.So Koa would like to find some strings $$$s_1, s_2, \\dots, s_{n+1}$$$ which would have generated numbers $$$a_1, a_2, \\dots, a_n$$$. Can you help her?If there are many answers print any. We can show that answer always exists for the given constraints.[SOURCE CODE]def listtostring(L):\n\tt=''\n\tfor i in range(0,len(L)):\n\t\tt+=L[i]\n\treturn t\n\nt=int(input())\nfor i in range(0,t):\n\tn=int(input())\n\tL=list(map(int,input().split()))\n\tif(max(L)==0):\n\t\tprint(\"a\")\n\t\tfor i in range(0,n):\n\t\t\tprint(chr(97+(i+1)%26))\n\telse:\n\t\t\n\t\tM=['a' for j in range (1+max(L))]\n\t\tprint(listtostring(M))\n\t\tk=0\n\t\tfor i in range(0,n):\n\t\t\tif(M[L[i]]=='a'):\n\t\t\t\tM[L[i]]='b'\n\t\t\telse:\n\t\t\t\tM[L[i]]='a'\n\n\t\t\n\t\t\t\n\t\t\tprint(listtostring(M))","tags":["strings"],"src_uid":"6983823efdc512f8759203460cd6bb4c"}
{"text_full":"[DESCRIPTION]Polycarp has decided to decorate his room because the New Year is soon. One of the main decorations that Polycarp will install is the garland he is going to solder himself.Simple garlands consisting of several lamps connected by one wire are too boring for Polycarp. He is going to solder a garland consisting of $$$n$$$ lamps and $$$n - 1$$$ wires. Exactly one lamp will be connected to power grid, and power will be transmitted from it to other lamps by the wires. Each wire connectes exactly two lamps; one lamp is called the main lamp for this wire (the one that gets power from some other wire and transmits it to this wire), the other one is called the auxiliary lamp (the one that gets power from this wire). Obviously, each lamp has at most one wire that brings power to it (and this lamp is the auxiliary lamp for this wire, and the main lamp for all other wires connected directly to it).Each lamp has a brightness value associated with it, the $$$i$$$-th lamp has brightness $$$2^i$$$. We define the importance of the wire as the sum of brightness values over all lamps that become disconnected from the grid if the wire is cut (and all other wires are still working).Polycarp has drawn the scheme of the garland he wants to make (the scheme depicts all $$$n$$$ lamp and $$$n - 1$$$ wires, and the lamp that will be connected directly to the grid is marked; the wires are placed in such a way that the power can be transmitted to each lamp). After that, Polycarp calculated the importance of each wire, enumerated them from $$$1$$$ to $$$n - 1$$$ in descending order of their importance, and then wrote the index of the main lamp for each wire (in the order from the first wire to the last one).The following day Polycarp bought all required components of the garland and decided to solder it — but he could not find the scheme. Fortunately, Polycarp found the list of indices of main lamps for all wires. Can you help him restore the original scheme?[SOURCE CODE]n = int(input())\n \na = list(map(int,input().split()))\n \ndic = {}\nuexmax = n\nans = []\n \nfor i in range(n-1):\n \n    if i == 0:\n        dic[a[i]] = 1\n \n    else:\n \n        if a[i] in dic:\n            dic[uexmax] = 1\n            ans.append([ a[i-1] , uexmax ])\n        else:\n            dic[a[i]] = 1\n            ans.append([ a[i-1] , a[i] ])\n \n    while uexmax in dic:\n        uexmax -= 1\n \nans.append ( [a[-1] , uexmax] )\n \nprint (a[0])\n \nfor i in range(n-1):\n    print (\" \".join(map(str,ans[i])))","tags":["trees"],"src_uid":"6a4e5b549514814a6c72d3b1e211a7f6"}
{"text_full":"[DESCRIPTION]A tree is a connected graph that doesn't contain any cycles.The distance between two vertices of a tree is the length (in edges) of the shortest path between these vertices.You are given a tree with n vertices and a positive number k. Find the number of distinct pairs of the vertices which have a distance of exactly k between them. Note that pairs (v, u) and (u, v) are considered to be the same pair.[SOURCE CODE]n, k = map(int, input().split())\nt, q = [[] for i in range(n + 1)], [1]\n \nfor j in range(n - 1):\n    a, b = map(int, input().split())\n    t[a].append(b)\n    t[b].append(a)\nfor x in q:\n    for y in t[x]: t[y].remove(x)\n    q.extend(t[x])\nq.reverse()\n \na, s = {}, 0\nfor x in q:\n    a[x] = [1]\n    u = len(a[x])\n    for y in t[x]:\n        v = len(a[y])\n        for d in range(max(0, k - u), v): s += a[y][d] * a[x][k - d - 1]\n        if v >= u:\n            for d in range(u - 1): a[x][d + 1] += a[y][d]\n            a[x] += a[y][u - 1: ]\n            u = v + 1\n        else:\n            for d in range(0, v): a[x][d + 1] += a[y][d]\n    if u > k: a[x].pop()\nprint(s)","tags":["trees"],"src_uid":"2fc19c3c9604e746a17a63758060c5d7"}
{"text_full":"[DESCRIPTION]PolandBall lives in a forest with his family. There are some trees in the forest. Trees are undirected acyclic graphs with k vertices and k - 1 edges, where k is some integer. Note that one vertex is a valid tree.There is exactly one relative living in each vertex of each tree, they have unique ids from 1 to n. For each Ball i we know the id of its most distant relative living on the same tree. If there are several such vertices, we only know the value of the one with smallest id among those.How many trees are there in the forest?[SOURCE CODE]import sys\nsys.setrecursionlimit(10000000)\n\nnBalls = int(raw_input())\nedge = [None] + map(int, raw_input().split())\ngroup = [0] * (nBalls + 1)\n\ndef dfs(ball):\n    if not group[ball]:\n        group[ball] = groupNum\n        dfs(edge[ball])\n\ngroupNum = 0\nfor ball in xrange(1, nBalls + 1):\n    if not group[ball]:\n        if group[edge[ball]]:\n            group[ball] = group[edge[ball]]\n        else:\n            groupNum += 1\n            dfs(ball)\nprint groupNum","tags":["graphs","trees"],"src_uid":"6d940cb4b54f63a7aaa82f21e4c5b994"}
{"text_full":"[DESCRIPTION]Little girl Margarita is a big fan of competitive programming. She especially loves problems about arrays and queries on them.Recently, she was presented with an array $$$a$$$ of the size of $$$10^9$$$ elements that is filled as follows:   $$$a_1 = -1$$$  $$$a_2 = 2$$$  $$$a_3 = -3$$$  $$$a_4 = 4$$$  $$$a_5 = -5$$$  And so on ... That is, the value of the $$$i$$$-th element of the array $$$a$$$ is calculated using the formula $$$a_i = i \\cdot (-1)^i$$$.She immediately came up with $$$q$$$ queries on this array. Each query is described with two numbers: $$$l$$$ and $$$r$$$. The answer to a query is the sum of all the elements of the array at positions from $$$l$$$ to $$$r$$$ inclusive.Margarita really wants to know the answer to each of the requests. She doesn't want to count all this manually, but unfortunately, she couldn't write the program that solves the problem either. She has turned to you — the best programmer.Help her find the answers![SOURCE CODE]from __future__ import division\nfrom sys import stdin, stdout\n\n\ndef write(x):\n    stdout.write(str(x) + \"\\n\")\n\n\nq = int(stdin.readline())\nfor _ in xrange(q):\n    l, r = map(int, stdin.readline().split())\n    elements = r - l + 1\n    if elements % 2 == 0:\n        res = elements \/\/ 2\n        if l % 2 == 0:\n            write(-res)\n        else:\n            write(res)\n    else:\n        res = elements \/\/ 2\n        if l % 2 == 0:\n            write(-res + r)\n        else:\n            write(res - r)","tags":["math"],"src_uid":"7eae40835f6e9580b985d636d5730e2d"}
{"text_full":"[DESCRIPTION]You are given an array $$$a$$$ of length $$$2n$$$. Consider a partition of array $$$a$$$ into two subsequences $$$p$$$ and $$$q$$$ of length $$$n$$$ each (each element of array $$$a$$$ should be in exactly one subsequence: either in $$$p$$$ or in $$$q$$$).Let's sort $$$p$$$ in non-decreasing order, and $$$q$$$ in non-increasing order, we can denote the sorted versions by $$$x$$$ and $$$y$$$, respectively. Then the cost of a partition is defined as $$$f(p, q) = \\sum_{i = 1}^n |x_i - y_i|$$$.Find the sum of $$$f(p, q)$$$ over all correct partitions of array $$$a$$$. Since the answer might be too big, print its remainder modulo $$$998244353$$$.[SOURCE CODE]'''Author- Akshit Monga'''\nfrom sys import stdin,stdout\ninput=stdin.readline\nm=998244353\ndef ncr(n, r, p):\n    num = den = 1\n    for i in range(r):\n        num = (num * (n - i)) % p\n        den = (den * (i + 1)) % p\n    return (num * pow(den,\n            p - 2, p)) % p\nt =1\nfor _ in range(t):\n    n=int(input())\n    arr=[int(x) for x in input().split()]\n    arr=sorted(arr)\n    ans=((abs(sum(arr[0:n])-sum(arr[n:])))%m*ncr(2*n,n,m))%m\n    print(ans)","tags":["math"],"src_uid":"0ff34aebe5e06774b1ad0eadad022ace"}
{"text_full":"[DESCRIPTION]Little X has met the following problem recently. Let's define f(x) as the sum of digits in decimal representation of number x (for example, f(1234) = 1 + 2 + 3 + 4). You are to calculate Of course Little X has solved this problem quickly, has locked it, and then has tried to hack others. He has seen the following C++ code:     ans = solve(l, r) % a;    if (ans &lt;= 0)      ans += a; This code will fail only on the test with . You are given number a, help Little X to find a proper test for hack.[SOURCE CODE]a=int(input())\nd=10**100-1;\nx=a-100*45*10**99%a\nprint(x,x+d)","tags":["math"],"src_uid":"52b8d97f216ea22693bc16fadcd46dae"}
{"text_full":"[DESCRIPTION]Consider a sequence [a1, a2, ... , an]. Define its prefix product sequence .Now given n, find a permutation of [1, 2, ..., n], such that its prefix product sequence is a permutation of [0, 1, ..., n - 1].[SOURCE CODE]n = int(input())\nif n == 4:\n    print (\"YES\\n1 3 2 4\")\nelif [i for i in range(2,n) if n%i==0]:\n    print(\"NO\")\nelse:\n    print(\"YES\\n1 %s\"%(\" \".join(str((pow(x+1,n-2,n)*(x+2))%n or n) for x in range(n-1))))","tags":["number theory","math"],"src_uid":"8b61e354ece0242eff539163f76cabde"}
{"text_full":"[DESCRIPTION]Ivan is a novice painter. He has $$$n$$$ dyes of different colors. He also knows exactly $$$m$$$ pairs of colors which harmonize with each other.Ivan also enjoy playing chess. He has $$$5000$$$ rooks. He wants to take $$$k$$$ rooks, paint each of them in one of $$$n$$$ colors and then place this $$$k$$$ rooks on a chessboard of size $$$10^{9} \\times 10^{9}$$$.Let's call the set of rooks on the board connected if from any rook we can get to any other rook in this set moving only through cells with rooks from this set. Assume that rooks can jump over other rooks, in other words a rook can go to any cell which shares vertical and to any cell which shares horizontal.Ivan wants his arrangement of rooks to have following properties: For any color there is a rook of this color on a board; For any color the set of rooks of this color is connected; For any two different colors $$$a$$$ $$$b$$$ union of set of rooks of color $$$a$$$ and set of rooks of color $$$b$$$ is connected if and only if this two colors harmonize with each other.Please help Ivan find such an arrangement.[SOURCE CODE]n, m = list(map(int, input().split()))\n\nG = [[] for _ in range(n + 1)]\nfinal = [[] for _ in range(n + 1)]\n\nseen = {}\nfor _ in range(m):\n    a, b = list(map(int, input().split()))\n    if a > b:\n        a,b = b,a\n    seen[a] = True\n    seen[b] = True\n    G[a].append(b)\n\nstep = 1\n\nfor i in range(1, n + 1):\n    hrmny = G[i]\n    if i not in seen:\n        final[i].append((step, i))\n        step += 1\n    for h in hrmny:\n        final[i].append((step, i))\n        final[h].append((step, h))\n        step += 1\n\nfor i in range(1, n + 1):\n    f = final[i]\n    print(len(f))\n    print('\\n'.join(map(lambda a: '{} {}'.format(*a), f)))","tags":["graphs"],"src_uid":"29476eefb914b445f1421d99d928fd5a"}
{"text_full":"[DESCRIPTION]The Department of economic development of IT City created a model of city development till year 2100.To prepare report about growth perspectives it is required to get growth estimates from the model.To get the growth estimates it is required to solve a quadratic equation. Since the Department of economic development of IT City creates realistic models only, that quadratic equation has a solution, moreover there are exactly two different real roots.The greater of these roots corresponds to the optimistic scenario, the smaller one corresponds to the pessimistic one. Help to get these estimates, first the optimistic, then the pessimistic one.[SOURCE CODE]a,b,c=map(float,raw_input().split())\nq=(b*b-4*a*c)**0.5\nx=(-b+q)\/(2*a)\ny=(-b-q)\/(2*a)\nprint max(x,y)\nprint min(x,y)","tags":["math"],"src_uid":"2d4ad39d42b349765435b351897403da"}
{"text_full":"[DESCRIPTION]Polycarp has n dice d1, d2, ..., dn. The i-th dice shows numbers from 1 to di. Polycarp rolled all the dice and the sum of numbers they showed is A. Agrippina didn't see which dice showed what number, she knows only the sum A and the values d1, d2, ..., dn. However, she finds it enough to make a series of statements of the following type: dice i couldn't show number r. For example, if Polycarp had two six-faced dice and the total sum is A = 11, then Agrippina can state that each of the two dice couldn't show a value less than five (otherwise, the remaining dice must have a value of at least seven, which is impossible).For each dice find the number of values for which it can be guaranteed that the dice couldn't show these values if the sum of the shown values is A.[SOURCE CODE]n, a = map(int, input().split())\nd = list(map(int, input().split()))\ns = sum(d)\n\ndef solve():\n    for x in d:\n        yield max(x - (a - n + 1), 0) + max(a - (s - x) - 1, 0)\n\nprint(' '.join(map(str, solve())))","tags":["math"],"src_uid":"2c51414eeb430ad06aac53a99ff95eff"}
{"text_full":"[DESCRIPTION]Acingel is a small town. There was only one doctor here — Miss Ada. She was very friendly and nobody has ever said something bad about her, so who could've expected that Ada will be found dead in her house? Mr Gawry, world-famous detective, is appointed to find the criminal. He asked $$$m$$$ neighbours of Ada about clients who have visited her in that unlucky day. Let's number the clients from $$$1$$$ to $$$n$$$. Each neighbour's testimony is a permutation of these numbers, which describes the order in which clients have been seen by the asked neighbour.However, some facts are very suspicious – how it is that, according to some of given permutations, some client has been seen in the morning, while in others he has been seen in the evening? \"In the morning some of neighbours must have been sleeping!\" — thinks Gawry — \"and in the evening there's been too dark to see somebody's face...\". Now he wants to delete some prefix and some suffix (both prefix and suffix can be empty) in each permutation, so that they'll be non-empty and equal to each other after that — some of the potential criminals may disappear, but the testimony won't stand in contradiction to each other.In how many ways he can do it? Two ways are called different if the remaining common part is different.[SOURCE CODE]def intersect(seqOne, seqTwo):\n\tseqOne = sorted(seqOne, key=lambda x: x[0])\n\tseqTwo = sorted(seqTwo, key=lambda x: x[0])\n\ti = 0\n\tj = 0\n\tans = []\n\twhile i < len(seqOne) and j < len(seqTwo):\n\t\ta,b = seqOne[i]\n\t\tc,d = seqTwo[j]\n\t\tif max(a,c) < min(b,d):\n\t\t\tans.append( (max(a,c), min(b,d)) )\n\t\tif b < d:\n\t\t\ti += 1\n\t\telse:\n\t\t\tj += 1\n\treturn ans\n\ndef main():\n\tn,m = map(int, input().strip().split())\n\torders = []\n\tfor i in range(m):\n\t\torders.append([int(x) for x in input().strip().split()])\n\t\n\tind = [0] * (n+1)\n\tfor i in range(1,n+1):\n\t\tind[orders[0][i-1]] = i\n\n\tsubseqs = [(1,n)]\n\tfor i in range(1,m):\n\t\torder = list(map(lambda x: ind[x], orders[i]))\n\t\ti = 0\n\t\tcurrSubseqs = []\n\t\tfor j in range(1,n):\n\t\t\tif order[j] == order[j-1] + 1:\n\t\t\t\tcontinue\n\t\t\telse:\n\t\t\t\tif j - i > 1:\n\t\t\t\t\tcurrSubseqs.append( (order[i], order[j-1]) )\n\t\t\t\ti = j\n\t\tif i != n-1:\n\t\t\tcurrSubseqs.append( (order[i], order[j]) )\n\n\t\tsubseqs = intersect(subseqs, currSubseqs)\n\t\tif len(subseqs) == 0:\n\t\t\tbreak\n\n\tans = n\n\tfor subseq in subseqs:\n\t\tx,y = subseq\n\t\tm = (y - x + 1)\n\t\tans += m * (m + 1) \/\/ 2 - m\n\n\tprint(ans)\t\n\t\n\n\nif __name__ == '__main__':\n\tmain()","tags":["math"],"src_uid":"7733551cffde2a78826e9cd53f3a7c9d"}
{"text_full":"[DESCRIPTION]A tuple of positive integers {x1, x2, ..., xk} is called simple if for all pairs of positive integers (i,  j) (1  ≤ i  &lt;  j ≤ k), xi  +  xj is a prime.You are given an array a with n positive integers a1,  a2,  ...,  an (not necessary distinct). You want to find a simple subset of the array a with the maximum size.A prime number (or a prime) is a natural number greater than 1 that has no positive divisors other than 1 and itself.Let's define a subset of the array a as a tuple that can be obtained from a by removing some (possibly all) elements of it.[SOURCE CODE]def f(N):\n    p=[1]*N\n    k=4\n    for i in range(2,N):\n        if p[i]:\n            for j in range(k,N,i):\n                p[j]=0\n        k+=i<<1|1\n    return p\np=f(2000001)\nn=input()\na=map(int,raw_input().split())\none=a.count(1)\nif one>1:\n    for x in a:\n        if not x&1:\n            if p[x+1]:\n                print one+1\n                print x, '1 '*one\n                exit()\n    print one\n    print '1 '*one\nelse:\n    for x in a:\n        for y in a:\n            if p[x+y] and x+y>2:\n                print 2\n                print x,y\n                exit()\n    print 1\n    print a[0]","tags":["number theory"],"src_uid":"6be0731d9d2d55bf9aa3492a8161d23c"}
{"text_full":"[DESCRIPTION]A string is binary, if it consists only of characters \"0\" and \"1\".String v is a substring of string w if it has a non-zero length and can be read starting from some position in string w. For example, string \"010\" has six substrings: \"0\", \"1\", \"0\", \"01\", \"10\", \"010\". Two substrings are considered different if their positions of occurrence are different. So, if some string occurs multiple times, we should consider it the number of times it occurs.You are given a binary string s. Your task is to find the number of its substrings, containing exactly k characters \"1\".[SOURCE CODE]k=int(input())\nl=input()\nif k==0:\n    c=0\n    ans=0\n    for i in range(len(l)):\n        if l[i]==\"0\":\n            c+=1\n        else:\n            temp=((c*(c+1))\/\/2)\n            ans+=temp\n            c=0\n    ans+=(c*(c+1))\/\/2\n    print(ans)\nelse:\n    ans=0\n    ar=[]\n    a=-1\n    for i in range(len(l)):\n        if l[i]==\"1\":\n            ar.append(i-a-1)\n            a=i\n    ar.append(len(l)-a-1)\n    p=len(ar)-1\n    for i in range(len(ar)):\n        if i+k>p:\n            break\n        ans+=ar[i]*ar[i+k]+ar[i]+ar[i+k]+1\n    print(ans)","tags":["math","strings"],"src_uid":"adc43f273dd9b3f1c58b052a34732a50"}
{"text_full":"[DESCRIPTION]Reading books is one of Sasha's passions. Once while he was reading one book, he became acquainted with an unusual character. The character told about himself like that: \"Many are my names in many countries. Mithrandir among the Elves, Tharkûn to the Dwarves, Olórin I was in my youth in the West that is forgotten, in the South Incánus, in the North Gandalf; to the East I go not.\"And at that moment Sasha thought, how would that character be called in the East? In the East all names are palindromes. A string is a palindrome if it reads the same backward as forward. For example, such strings as \"kazak\", \"oo\" and \"r\" are palindromes, but strings \"abb\" and \"ij\" are not. Sasha believed that the hero would be named after one of the gods of the East. As long as there couldn't be two equal names, so in the East people did the following: they wrote the original name as a string on a piece of paper, then cut the paper minimum number of times $$$k$$$, so they got $$$k+1$$$ pieces of paper with substrings of the initial string, and then unite those pieces together to get a new string. Pieces couldn't be turned over, they could be shuffled.In this way, it's possible to achive a string abcdefg from the string f|de|abc|g using $$$3$$$ cuts (by swapping papers with substrings f and abc). The string cbadefg can't be received using the same cuts.More formally, Sasha wants for the given palindrome $$$s$$$ find such minimum $$$k$$$, that you can cut this string into $$$k + 1$$$ parts, and then unite them in such a way that the final string will be a palindrome and it won't be equal to the initial string $$$s$$$. It there is no answer, then print \"Impossible\" (without quotes).[SOURCE CODE]s = input()\n\nl = len(s)\n\nc = s[0]\ndiff = False\nfor i in range(0,int(l\/2)):\n    if s[i] != c:\n        diff = True\n\nif not diff:\n    print('Impossible')\n    exit()\n\ns_2 = s + s\n\nfor i in range(1,l):\n    is_palendrome = True\n\n    for j in range(int(l\/2)):\n        if s_2[j + i] != s_2[i + l - j-1]:\n            is_palendrome = False\n    if is_palendrome and s_2[i:i+l] != s:\n        print(1)\n        exit()\n\nprint(2)","tags":["strings"],"src_uid":"ffdef277d0ff8e8579b113f5bd30f52a"}
{"text_full":"[DESCRIPTION]You are given an angle $$$\\text{ang}$$$. The Jury asks You to find such regular $$$n$$$-gon (regular polygon with $$$n$$$ vertices) that it has three vertices $$$a$$$, $$$b$$$ and $$$c$$$ (they can be non-consecutive) with $$$\\angle{abc} = \\text{ang}$$$ or report that there is no such $$$n$$$-gon.  If there are several answers, print the minimal one. It is guarantied that if answer exists then it doesn't exceed $$$998244353$$$.[SOURCE CODE]L = [-1] * 181\n\nfor i in range(3, 400):\n    for j in range(1, i-1):\n        if L[180*j\/i] == -1 and 180*j%i==0:\n            L[180*j\/i] = i\nT = input()\nfor i in range(T):\n    ang = input()\n    print L[ang]","tags":["geometry"],"src_uid":"d11b56fe172110d5dfafddf880e48f18"}
{"text_full":"[DESCRIPTION]You have to handle a very complex water distribution system. The system consists of $$$n$$$ junctions and $$$m$$$ pipes, $$$i$$$-th pipe connects junctions $$$x_i$$$ and $$$y_i$$$.The only thing you can do is adjusting the pipes. You have to choose $$$m$$$ integer numbers $$$f_1$$$, $$$f_2$$$, ..., $$$f_m$$$ and use them as pipe settings. $$$i$$$-th pipe will distribute $$$f_i$$$ units of water per second from junction $$$x_i$$$ to junction $$$y_i$$$ (if $$$f_i$$$ is negative, then the pipe will distribute $$$|f_i|$$$ units of water per second from junction $$$y_i$$$ to junction $$$x_i$$$). It is allowed to set $$$f_i$$$ to any integer from $$$-2 \\cdot 10^9$$$ to $$$2 \\cdot 10^9$$$.In order for the system to work properly, there are some constraints: for every $$$i \\in [1, n]$$$, $$$i$$$-th junction has a number $$$s_i$$$ associated with it meaning that the difference between incoming and outcoming flow for $$$i$$$-th junction must be exactly $$$s_i$$$ (if $$$s_i$$$ is not negative, then $$$i$$$-th junction must receive $$$s_i$$$ units of water per second; if it is negative, then $$$i$$$-th junction must transfer $$$|s_i|$$$ units of water per second to other junctions).Can you choose the integers $$$f_1$$$, $$$f_2$$$, ..., $$$f_m$$$ in such a way that all requirements on incoming and outcoming flows are satisfied?[SOURCE CODE]import sys\nfrom time import time\n\ndef i_ints():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef main():\n    limit =10**10\n\n    n, = i_ints()\n    s = [0] + i_ints()\n    if sum(s):\n        print(\"Impossible\")\n        return\n    print(\"Possible\")\n\n    m, = i_ints()\n    es = [i_ints() for _ in range(m)]\n\n    nb = [[] for i in range(n+1)]\n    for i, (x, y) in enumerate(es):\n        nb[x].append((y, i, 1))\n        nb[y].append((x, i, -1))\n\n    path = []\n    def make_path():\n        stack = []\n        seen = [False] * (n+1)\n        stack.append(1)\n        seen[1] = True\n        while stack:\n            x = stack.pop()\n            for y, i, factor in nb[x]:\n                if not seen[y]:\n                    seen[y] = True\n                    stack.append(y)\n                    path.append((x, y, i, factor))\n    make_path()\n\n    f = [0] * m\n    for x, y, i,factor in reversed(path):\n        f[i] = factor * s[y]\n        s[x] += s[y]\n        s[y] = 0\n\n    print(\"\\n\".join(map(str, f)))\n        \n    return\n            \nmain()","tags":["trees"],"src_uid":"666b710742bb710dda112e4a6bbbe96b"}
{"text_full":"[DESCRIPTION]Heidi found out that the Daleks have created a network of bidirectional Time Corridors connecting different destinations (at different times!). She suspects that they are planning another invasion on the entire Space and Time. In order to counter the invasion, she plans to deploy a trap in the Time Vortex, along a carefully chosen Time Corridor. She knows that tinkering with the Time Vortex is dangerous, so she consulted the Doctor on how to proceed. She has learned the following:  Different Time Corridors require different amounts of energy to keep stable.  Daleks are unlikely to use all corridors in their invasion. They will pick a set of Corridors that requires the smallest total energy to maintain, yet still makes (time) travel possible between any two destinations (for those in the know: they will use a minimum spanning tree).  Setting the trap may modify the energy required to keep the Corridor stable. Heidi decided to carry out a field test and deploy one trap, placing it along the first Corridor. But she needs to know whether the Daleks are going to use this corridor after the deployment of the trap. She gives you a map of Time Corridors (an undirected graph) with energy requirements for each Corridor.For a Corridor $$$c$$$, $$$E_{max}(c)$$$ is the largest $$$e \\le 10^9$$$ such that if we changed the required amount of energy of $$$c$$$ to $$$e$$$, then the Daleks may still be using $$$c$$$ in their invasion (that is, it belongs to some minimum spanning tree). Your task is to calculate $$$E_{max}(c_1)$$$ for the Corridor $$$c_1$$$ that Heidi plans to arm with a trap, which is the first edge in the graph.[SOURCE CODE]from __future__ import division, print_function\ndef main():\n    class DSU:\n        def __init__ (self,n):\n            self.parent=list(range(n))\n            self.size=[1]*n\n            self.count_sets=n\n        def find(self,u):\n            to_update=[]\n            while u!=self.parent[u]:\n                to_update.append(u)\n                u=self.parent[u]\n            for v in to_update:\n                self.parent[v]=u\n            return u\n        def union(self,u,v):\n            u=self.find(u)\n            v=self.find(v)\n            if u==v:\n                return\n            if self.size[u] < self.size[v]:\n                u,v=v,u\n            self.count_sets-=1\n            self.parent[v]=u\n            self.size[u]+=self.size[v]\n        def set_size(self,a):\n            return self.size[self.find(a)]\n    n,m=map(int,input().split())\n    a,b,e=map(int,input().split())\n    a-=1\n    b-=1\n    l1=[]\n    flag1=0\n    flag2=0\n    for i in range(m-1):\n        x,y,z=map(int,input().split())\n        l1.append((z,x-1,y-1))\n    l1.sort()\n    import sys\n    my_dsu=DSU(n)\n    for item in l1:\n        if my_dsu.find(item[1])!=my_dsu.find(item[2]):\n            my_dsu.union(item[1],item[2])\n        if my_dsu.find(a)==my_dsu.find(b):\n            print(item[0])\n            sys.exit()\n    print(10**9)\npy2 = round(0.5)\nif py2:\n    from future_builtins import ascii, filter, hex, map, oct, zip\n    range = xrange\nimport os, sys\nfrom io import IOBase, BytesIO\nBUFSIZE = 8192\nclass FastIO(BytesIO):\n    newlines = 0\n    def __init__(self, file):\n        self._file = file\n        self._fd = file.fileno()\n        self.writable = \"x\" in file.mode or \"w\" in file.mode\n        self.write = super(FastIO, self).write if self.writable else None\n    def _fill(self):\n        s = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n        self.seek((self.tell(), self.seek(0,2), super(FastIO, self).write(s))[0])\n        return s\n    def read(self):\n        while self._fill(): pass\n        return super(FastIO,self).read()\n    def readline(self):\n        while self.newlines == 0:\n            s = self._fill(); self.newlines = s.count(b\"\\n\") + (not s)\n        self.newlines -= 1\n        return super(FastIO, self).readline()\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.getvalue())\n            self.truncate(0), self.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        if py2:\n            self.write = self.buffer.write\n            self.read = self.buffer.read\n            self.readline = self.buffer.readline\n        else:\n            self.write = lambda s:self.buffer.write(s.encode('ascii'))\n            self.read = lambda:self.buffer.read().decode('ascii')\n            self.readline = lambda:self.buffer.readline().decode('ascii')\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n')\nimport sys\nclass ostream:\n    def __lshift__(self,a):\n        sys.stdout.write(str(a))\n        return self\ncout = ostream()\nendl = '\\n'\ndef readnumbers(zero = 0):\n    conv = ord if py2 else lambda x:x\n    A = []; numb = zero; sign = 1; i = 0; s = sys.stdin.buffer.read()\n    try:\n        while True:\n            if s[i] >= b'0' [0]:\n                numb = 10 * numb + conv(s[i]) - 48\n            elif s[i] == b'-' [0]: sign = -1\n            elif s[i] != b'\\r' [0]:\n                A.append(sign*numb)\n                numb = zero; sign = 1\n            i += 1\n    except:pass\n    if s and s[-1] >= b'0' [0]:\n        A.append(sign*numb)\n    return A\nif __name__== \"__main__\":\n  main()","tags":["trees","graphs"],"src_uid":"507e3e805e91a91e5130f53588e62dab"}
{"text_full":"[DESCRIPTION]The map of Berland is a rectangle of the size n × m, which consists of cells of size 1 × 1. Each cell is either land or water. The map is surrounded by the ocean. Lakes are the maximal regions of water cells, connected by sides, which are not connected with the ocean. Formally, lake is a set of water cells, such that it's possible to get from any cell of the set to any other without leaving the set and moving only to cells adjacent by the side, none of them is located on the border of the rectangle, and it's impossible to add one more water cell to the set such that it will be connected with any other cell.You task is to fill up with the earth the minimum number of water cells so that there will be exactly k lakes in Berland. Note that the initial number of lakes on the map is not less than k.[SOURCE CODE]n,m,k = (int(x) for x in input().split())\nMap = []\nlakesizes = [0]\nlakemembers = [0]\nfor i in range(n):\n    Map.append([x for x in input()])\n\n\n\n\nstack = [(x,y,None) for x in range(1,m-1) for y in range(1,n-1)] + [(0,y,None) for y in range(n)] + [(m-1,y,None) for y in range(n)] + [(x,0,None) for x in range(1,m-1)] + [(x,n-1,None) for x in range(1,m-1)]\nlakenumber = [ [None]*m for y in range(n) ]\nfor y in range(n):\n    for x in range(m):\n        if Map[y][x] == '.':\n            lakenumber[y][x] = -1\n\nwhile(stack):\n    x,y,current = stack.pop()\n    if lakenumber[y][x] is not None and lakenumber[y][x] < 0:\n\n        if current is None:\n            if x in [0,m-1] or y in [0,n-1]:\n                current = 0\n            else:\n                current = len(lakesizes)\n                lakesizes.append(0)\n                lakemembers.append([])\n\n        lakenumber[y][x] = current\n        lakesizes[current] += 1\n        if current > 0:\n            lakemembers[current].append( (x,y) )\n\n        for xo,yo in [(x,y+1),(x,y-1),(x+1,y),(x-1,y)]:\n            if 0 <= yo < n and 0 <= xo < m:\n                stack.append( (xo,yo,current) )\n\nordlakes = [(lakesizes[i],i) for i in range(1,len(lakesizes))]\nordlakes.sort()\ntotalsize = 0\nfor i in range(len(ordlakes)-k):\n    size,ind = ordlakes[i]\n    totalsize += size\n    for x,y in lakemembers[ind]:\n        Map[y][x] = '*'\n\nprint(totalsize)\nfor i in range(n):\n    print(''.join(Map[i]))","tags":["graphs"],"src_uid":"e514d949e7837c603a9ee032f83b90d2"}
{"text_full":"[DESCRIPTION]Oleg the bank client lives in Bankopolia. There are n cities in Bankopolia and some pair of cities are connected directly by bi-directional roads. The cities are numbered from 1 to n. There are a total of m roads in Bankopolia, the i-th road connects cities ui and vi. It is guaranteed that from each city it is possible to travel to any other city using some of the roads.Oleg wants to give a label to each city. Suppose the label of city i is equal to xi. Then, it must hold that for all pairs of cities (u, v) the condition |xu - xv| ≤ 1 holds if and only if there is a road connecting u and v.Oleg wonders if such a labeling is possible. Find an example of such labeling if the task is possible and state that it is impossible otherwise.[SOURCE CODE]import collections\nimport sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\nn, m = map(int, readline().split())\ng = [[i] for i in xrange(n)]\nfor i in xrange(m):\n    u, v = map(int, readline().split())\n    g[u-1].append(v-1)\n    g[v-1].append(u-1)\nfor i in xrange(n):\n    g[i] = tuple(sorted(g[i]))\ns = {e: i for i, e in enumerate({e for e in g})}\nsn = len(s)\nsg = [set() for i in xrange(sn)]\nused = [0]*sn\nfor v in xrange(n):\n    lv = g[v]\n    i = s[lv]\n    if not used[i]:\n        used[i] = 1\n        for t in g[v]:\n            lt = g[t]\n            if hash(lt) != hash(lv):\n                j = s[lt]\n                sg[i].add(j)\n                sg[j].add(i)\nintwo = 1\none = 0; one_node = None\nfor i in xrange(sn):\n    if len(sg[i]) > 2:\n        intwo = 0\n        break\n    if len(sg[i]) <= 1:\n        one = 1\n        one_node = i\nif intwo and one:\n    used = [0]*sn\n    deq = collections.deque()\n    used[one_node] = 1\n    v = one_node\n    ans = [-1]*sn\n    cur = 1\n    while 1:\n        ans[v] = cur\n        cur += 1\n        for t in sg[v]:\n            if not used[t]:\n                used[t] = 1\n                v = t\n                break\n        else:\n            break\n    write(\"YES\\n\")\n    write(\" \".join(str(ans[s[e]]) for e in g))\n    write(\"\\n\")\nelse:\n    write(\"NO\\n\")","tags":["graphs"],"src_uid":"bb7ecc5dbb922007bc0c25491aaa53d9"}
{"text_full":"[DESCRIPTION]You are given an array consisting of $$$n$$$ integers $$$a_1$$$, $$$a_2$$$, ..., $$$a_n$$$. Initially $$$a_x = 1$$$, all other elements are equal to $$$0$$$.You have to perform $$$m$$$ operations. During the $$$i$$$-th operation, you choose two indices $$$c$$$ and $$$d$$$ such that $$$l_i \\le c, d \\le r_i$$$, and swap $$$a_c$$$ and $$$a_d$$$.Calculate the number of indices $$$k$$$ such that it is possible to choose the operations so that $$$a_k = 1$$$ in the end.[SOURCE CODE]for _ in range(int(input())):\n    \n    n,x,m = map(int,input().split())\n    \n    lst = []\n    for i in range(m):\n        \n        tmp = list(map(int,input().split()))\n        lst.append(tmp)\n        \n    while lst and not lst[0][0]<=x<=lst[0][1]:\n        lst.pop(0)\n        \n    if not lst:\n        print(1)\n    \n    else:\n        ans = [lst[0]]\n        \n        for i in range(1,len(lst)):\n            \n            if lst[i][0]<ans[-1][0] and ans[-1][1]<lst[i][1]:\n                ans[-1] = lst[i]\n            \n            elif ans[-1][0]<=lst[i][1]<=ans[-1][1] and lst[i][0]<ans[-1][0]:\n                ans[-1][0] = lst[i][0]\n                \n            elif ans[-1][0]<=lst[i][0]<=ans[-1][1] and lst[i][1]>ans[-1][1]:\n                ans[-1][1] = lst[i][1]\n         \n        if ans:       \n            print(ans[-1][1]-ans[-1][0]+1)\n            \n        else:\n            print(1)","tags":["math"],"src_uid":"c358bce566a846bd278329ef2c029dff"}
{"text_full":"[DESCRIPTION]This is an interactive problem. You should use flush operation after each printed line. For example, in C++ you should use fflush(stdout), in Java you should use System.out.flush(), and in Pascal — flush(output).In this problem you should guess an array a which is unknown for you. The only information you have initially is the length n of the array a.The only allowed action is to ask the sum of two elements by their indices. Formally, you can print two indices i and j (the indices should be distinct). Then your program should read the response: the single integer equals to ai + aj.It is easy to prove that it is always possible to guess the array using at most n requests.Write a program that will guess the array a by making at most n requests.[SOURCE CODE]from math import ceil,gcd,floor\nfrom collections import deque,defaultdict as dict\nfrom heapq import heappush as hpush,heappop as hpop, heapify\nfrom functools import lru_cache\nimport sys\n\ninf=float(\"inf\")\n\ndef inpi(): return(int(input()))\ndef inpa(): return(list(map(int,input().split())))\ndef inp(): s = input();return(list(s))\ndef inpv(): return(map(int,input().split()))\n\nn=int(input())\na=[0]*n\nd={}\nfor i in range(2,n+1):\n\tprint(\"?\",1,i)\n\n\td[i]=int(input())\nprint(\"?\",2,3)\nk=inpi()\nd[1]=((d[2]+d[3])-k)\/\/2\n\nfor i in range(2,n+1):\n\ta[i-1]=d[i]-d[1]\na[0]=d[1]\nprint(\"!\",*a)\n\n\n# 5\n# 4 6 1 5 5","tags":["math"],"src_uid":"1898e591b40670173e4c33e08ade48ba"}
{"text_full":"[DESCRIPTION]Arseny likes to organize parties and invite people to it. However, not only friends come to his parties, but friends of his friends, friends of friends of his friends and so on. That's why some of Arseny's guests can be unknown to him. He decided to fix this issue using the following procedure.At each step he selects one of his guests A, who pairwise introduces all of his friends to each other. After this action any two friends of A become friends. This process is run until all pairs of guests are friends.Arseny doesn't want to spend much time doing it, so he wants to finish this process using the minimum number of steps. Help Arseny to do it.[SOURCE CODE]from collections import defaultdict\ndef count(x):\n    c=0\n    while x > 0:\n        c+=1\n        x &= (x-1)\n    return c\n\nn,m=map(int,input().split())\ng=defaultdict(list)\nfor _ in range(m):\n    u, v = map(int,input().split())\n    u-=1;v-=1\n    g[u].append(v)\n    g[v].append(u)\n\nmask1=0;mask2=0;MAX=(1<<n)-1\na=[0]*(1 << n)\ndp=[MAX]*(1 << n)\nif m == (n*(n-1))\/\/2:\n    print(0)\n    exit(0)\nfor i,j in g.items():\n    mask1  = (1 << i);mask2=0;mask2 |= mask1\n    for k in j:\n        mask2 |= (1 << k)\n        \n    dp[mask2]=mask1\n    a[mask1]=mask2\n    \nfor i in range(0,(1 << n)-1):\n    if dp[i] != MAX:\n        #print('HEllo')\n        temp = dp[i] ^ i \n        for j in range(n):\n            if temp & (1 << j) != 0:\n                nmask = i | a[(1 << j)]\n                dp[nmask]=dp[i] | (1 << j) if count(dp[i] | (1 << j)) < count(dp[nmask]) else dp[nmask]\n                \nans = []\nfor i in range(n):\n    if dp[-1] & (1 << i) != 0:\n        ans.append(i+1)\nprint(len(ans))\nprint(*ans)","tags":["graphs"],"src_uid":"5ec62d1ab7bd3b14ec3f1508ca327134"}
{"text_full":"[DESCRIPTION]Lee is used to finish his stories in a stylish way, this time he barely failed it, but Ice Bear came and helped him. Lee is so grateful for it, so he decided to show Ice Bear his new game called \"Critic\"...The game is a one versus one game. It has $$$t$$$ rounds, each round has two integers $$$s_i$$$ and $$$e_i$$$ (which are determined and are known before the game begins, $$$s_i$$$ and $$$e_i$$$ may differ from round to round). The integer $$$s_i$$$ is written on the board at the beginning of the corresponding round. The players will take turns. Each player will erase the number on the board (let's say it was $$$a$$$) and will choose to write either $$$2 \\cdot a$$$ or $$$a + 1$$$ instead. Whoever writes a number strictly greater than $$$e_i$$$ loses that round and the other one wins that round.Now Lee wants to play \"Critic\" against Ice Bear, for each round he has chosen the round's $$$s_i$$$ and $$$e_i$$$ in advance. Lee will start the first round, the loser of each round will start the next round.The winner of the last round is the winner of the game, and the loser of the last round is the loser of the game.Determine if Lee can be the winner independent of Ice Bear's moves or not. Also, determine if Lee can be the loser independent of Ice Bear's moves or not.[SOURCE CODE]def win(s, e):\n    if e == s:return False\n    elif e == s + 1:return True\n    elif e & 1:return s & 1 == 0\n    elif e \/\/ 2 < s:return s & 1 == 1\n    elif e \/\/ 4 < s:return True\n    else:return win(s, e \/\/ 4)    \ndef lose(s, e):return (True if e \/\/ 2 < s else win(s, e \/\/ 2))       \ndef main():\n    res = [False, True]\n    for _ in range(int(input())):\n        s, e = [int(x) for x in input().split()]\n        if res == [True, True]:continue\n        if res == [False, False]:continue\n        cur = [win(s, e), lose(s, e)]\n        if res[0]:cur = [not x for x in cur]\n        res = cur\n    print(*[int(x) for x in res])\nmain()","tags":["games"],"src_uid":"a0376bf145f4d9b5fbc1683956c203df"}
{"text_full":"[DESCRIPTION]In the town of Aalam-Aara (meaning the Light of the Earth), previously there was no crime, no criminals but as the time progressed, sins started creeping into the hearts of once righteous people. Seeking solution to the problem, some of the elders found that as long as the corrupted part of population was kept away from the uncorrupted part, the crimes could be stopped. So, they are trying to set up a compound where they can keep the corrupted people. To ensure that the criminals don't escape the compound, a watchtower needs to be set up, so that they can be watched.Since the people of Aalam-Aara aren't very rich, they met up with a merchant from some rich town who agreed to sell them a land-plot which has already a straight line fence AB along which a few points are set up where they can put up a watchtower. Your task is to help them find out the number of points on that fence where the tower can be put up, so that all the criminals can be watched from there. Only one watchtower can be set up. A criminal is watchable from the watchtower if the line of visibility from the watchtower to him doesn't cross the plot-edges at any point between him and the tower i.e. as shown in figure 1 below, points X, Y, C and A are visible from point B but the points E and D are not.    Figure 1     Figure 2 Assume that the land plot is in the shape of a polygon and coordinate axes have been setup such that the fence AB is parallel to x-axis and the points where the watchtower can be set up are the integer points on the line. For example, in given figure 2, watchtower can be setup on any of five integer points on AB i.e. (4, 8), (5, 8), (6, 8), (7, 8) or (8, 8). You can assume that no three consecutive points are collinear and all the corner points other than A and B, lie towards same side of fence AB. The given polygon doesn't contain self-intersections.[SOURCE CODE]from math import floor,ceil\nn = input()\nx,y = zip(*[map(int,raw_input().split()) for _ in xrange(n)])\nnr,mr=min(x[:2]),max(x[:2])\nfor j in xrange(3,n):\n    i = j-1\n    dx = x[j]-x[i]\n    dy = y[j]-y[i]\n    t = 1.*(y[0]-y[i])*dx;\n    r = t\/dy+x[i] if dy else 1e9\n    if t-dy*(mr-x[i])>0 and r<mr: mr=r;\n    if t-dy*(nr-x[i])>0 and r>nr: nr=r;\nmr = floor(mr)-ceil(nr)\nprint \"%.0f\"%(0. if mr<-1e-14 else mr+1.1)","tags":["geometry"],"src_uid":"1503f0379bf8d7f25c191ddea9278842"}
{"text_full":"[DESCRIPTION]Anya and Kirill are doing a physics laboratory work. In one of the tasks they have to measure some value n times, and then compute the average value to lower the error.Kirill has already made his measurements, and has got the following integer values: x1, x2, ..., xn. It is important that the values are close to each other, namely, the difference between the maximum value and the minimum value is at most 2.Anya does not want to make the measurements, however, she can't just copy the values from Kirill's work, because the error of each measurement is a random value, and this coincidence will be noted by the teacher. Anya wants to write such integer values y1, y2, ..., yn in her work, that the following conditions are met:  the average value of x1, x2, ..., xn is equal to the average value of y1, y2, ..., yn; all Anya's measurements are in the same bounds as all Kirill's measurements, that is, the maximum value among Anya's values is not greater than the maximum value among Kirill's values, and the minimum value among Anya's values is not less than the minimum value among Kirill's values; the number of equal measurements in Anya's work and Kirill's work is as small as possible among options with the previous conditions met. Formally, the teacher goes through all Anya's values one by one, if there is equal value in Kirill's work and it is not strike off yet, he strikes off this Anya's value and one of equal values in Kirill's work. The number of equal measurements is then the total number of strike off values in Anya's work. Help Anya to write such a set of measurements that the conditions above are met.[SOURCE CODE]n=int(input())\nx=input()\na=list(map(int,x.split()))\nif max(a)-min(a)<2:\n print(n)\n print(x)\n exit()\ns=set(a)\nq=min(a)\ns=max(a)\nr=q+1\nm={}\nm[q]=m[s]=m[r]=0\nfor i in a:m[i]+=1\nif n-2*min(m[q],m[s])<n-m[r]\/\/2*2:\n print(n-2*min(m[q],m[s]))\n e=min(m[q],m[s])\n m[r]+=e+e\n m[q]-=e\n m[s]-=e\nelse:\n print(n-m[r]\/\/2*2)\n e=m[r]\/\/2\n m[r]-=e+e\n m[q]+=e\n m[s]+=e\nb=[r for i in range(m[r])]\nb=b+[q for i in range(m[q])]\nb=b+[s for i in range(m[s])]\nprint(*b)\n\n\n\n\n# Made By Mostafa_Khaled","tags":["math"],"src_uid":"dbbea6784cafdd4244f56729996e9187"}
{"text_full":"[DESCRIPTION]You are given a string $$$s$$$ consisting only of characters + and -. You perform some process with this string. This process can be described by the following pseudocode: res = 0for init = 0 to inf    cur = init    ok = true    for i = 1 to |s|        res = res + 1        if s[i] == '+'            cur = cur + 1        else            cur = cur - 1        if cur &lt; 0            ok = false            break    if ok        breakNote that the $$$inf$$$ denotes infinity, and the characters of the string are numbered from $$$1$$$ to $$$|s|$$$.You have to calculate the value of the $$$res$$$ after the process ends.[SOURCE CODE]#!\/usr\/bin\/env python\nfrom __future__ import division, print_function\n\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\nif sys.version_info[0] < 3:\n    from __builtin__ import xrange as range\n    from future_builtins import ascii, filter, hex, map, oct, zip\n\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\n\nfrom math import sqrt, floor, factorial, gcd, log\nfrom collections import deque, Counter, defaultdict\nfrom itertools import permutations, combinations\nfrom math import gcd\nfrom bisect import bisect\n\n\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\nread = lambda: list(map(int, input().strip().split(\" \")))\n\n\n\ndef func(x):\n    t = 0\n    for i in arr:\n        if i <= x:\n            t += i\n    return(t)\n\ndef solve():\n    for _ in range(int(input())):\n        s = input(); \n        arr = [[-1, 1][i==\"+\"] for i in s]\n        for i in range(1, len(s)):arr[i] += arr[i-1]\n        ans = 0; sett = set()\n\n        for i in range(len(s)):\n            if arr[i] < 0 and arr[i] not in sett:\n                ans += i+1\n                sett.add(arr[i])\n        # print(arr, sett)\n        # if ans:\n        print(ans+len(s))\n        # else:\n        #     print(len(s))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\nif __name__ == \"__main__\":\n\tsolve()","tags":["math"],"src_uid":"07eecfe948aa78623586b5e30e84e415"}
{"text_full":"[DESCRIPTION]Let's introduce the designation , where x is a string, n is a positive integer and operation \" + \" is the string concatenation operation. For example, [abc, 2] = abcabc.We'll say that string s can be obtained from string t, if we can remove some characters from string t and obtain string s. For example, strings ab and aсba can be obtained from string xacbac, and strings bx and aaa cannot be obtained from it.Sereja has two strings, w = [a, b] and q = [c, d]. He wants to find such maximum integer p (p &gt; 0), that [q, p] can be obtained from string w.[SOURCE CODE]from itertools import repeat,chain\nfrom fractions import gcd\n\ndef eternal(c,d, n = None):\n\n\n    while True:\n\n        yield chain.from_iterable(repeat(c,d))\n\n\n\n        \n\n\ndef cyclic_array(arr):\n\n    n = len(arr)\n    def cyclar(i):\n\n        return arr[i % n]\n\n    return cyclar\ndef find_repeat(enum,q_r_gen, a_n):\n\n    ac_count =0\n    a_count = 0\n    remainders ={}\n    tempq=''\n    tempa = ''\n    for q,q_r in enumerate(q_r_gen):\n\n        tempq=''\n        for c_c in q_r:\n            tempq= tempq +c_c\n            for a_count,a_c in enum:\n                if a_c == c_c:\n                    tempa = tempa +a_c\n                    ac_count+=1\n                    break\n            #print len(tempa),len(tempq)\n        if (a_count % a_n) in remainders:\n\n            #print tempq[:20],tempa[:20]\n            break\n        else:\n\n            remainders[(a_count % a_n)]=(a_count,q)\n\n    repeat_length = a_count - remainders[a_count % a_n][0]\n    q_count = q-remainders[a_count % a_n][1]\n\n    return remainders[a_count % a_n][0],repeat_length,q_count\n    \n\n\n    \ndef main(a,b,c,d):\n  \n\n    \n    #print a, c\n\n\n    a_r = chain.from_iterable(repeat(a,b))\n\n    #print \"\".join(chain.from_iterable(repeat(a,b)))\n\n\n    enum =enumerate(a_r)\n\n    q_r_gen = eternal(c,d)\n\n    i = 0\n    flag = True\n\n\n    if len(a) > len(c)*d:\n        multiplier =1\n        start,repeat_length,q_count = find_repeat(enum,q_r_gen, len(a))\n\n    else:\n        multiplier =((len(c)*d)\/\/len(a))+1\n        #print \"Multi\",multiplier\n        enum2 = enumerate(chain.from_iterable(repeat(a*multiplier,b\/\/multiplier)))\n        start,repeat_length,q_count =find_repeat(enum2,q_r_gen, multiplier*len(a))\n        \n    if repeat_length >0:\n        advance_n = (((len(a)*multiplier)*(b\/\/multiplier))\/\/repeat_length)-1\n        advance = repeat_length * advance_n\n\n        sofar = q_count * advance_n\n    else:\n        advance_n =0\n        advance = 0\n        sofar = 0\n\n    #print advance_n,advance, repeat_length, len(a)*b, sofar , len(c)*d\n        \n    ca = cyclic_array(a)\n\n    ra = iter(range(advance,len(a)*b))\n\n    ac_count =0\n    for q_r in q_r_gen:\n        for i,c_c in enumerate(q_r):\n\n            flag = False\n            for a_count in ra:\n                #print a_count\n\n                if ca(a_count) == c_c:\n                    ac_count+=1\n                    flag = True\n                    break\n                \n        if not flag:\n            break\n\n    \n    print sofar + (ac_count \/\/ (len(c)*d))\n\n\n    \nif __name__ == \"__main__\":\n    b,d = [int(s) for s in (raw_input()).split()]\n\n    a = raw_input()\n\n    c = raw_input()\n\n    aset = set(a)\n    cset = set(c)\n\n    if cset.difference(aset):\n        print 0\n\n    elif a == c:\n\n        print b \/\/ d\n        \n    else:\n        \n        main(a,b,c,d)","tags":["strings"],"src_uid":"5ea0351ac9f949dedae1928bfb7ebffa"}
{"text_full":"[DESCRIPTION]Little Chris is very keen on his toy blocks. His teacher, however, wants Chris to solve more problems, so he decided to play a trick on Chris.There are exactly s blocks in Chris's set, each block has a unique number from 1 to s. Chris's teacher picks a subset of blocks X and keeps it to himself. He will give them back only if Chris can pick such a non-empty subset Y from the remaining blocks, that the equality holds:  \"Are you kidding me?\", asks Chris.For example, consider a case where s = 8 and Chris's teacher took the blocks with numbers 1, 4 and 5. One way for Chris to choose a set is to pick the blocks with numbers 3 and 6, see figure. Then the required sums would be equal: (1 - 1) + (4 - 1) + (5 - 1) = (8 - 3) + (8 - 6) = 7.  However, now Chris has exactly s = 106 blocks. Given the set X of blocks his teacher chooses, help Chris to find the required set Y![SOURCE CODE]s = 10 ** 6\ncnt = int(raw_input())\ndata = set(map(int, raw_input().split()))\n\nans = []\np = 0\nfor i in data:\n    now = s + 1 - i\n    if now in data:\n        p += 1\n    else:\n        ans.append(now)\n\np \/= 2\nif p > 0:\n    for i in xrange(1, s \/ 2 + 1):\n        now = s + 1 - i\n        if (now not in data) and (i not in data):\n            ans.append(i)\n            ans.append(now)\n            p -= 1\n            if p == 0:\n                break\nprint len(ans)\nprint ' '.join(map(str, ans))","tags":["math"],"src_uid":"4143caa25fcc2f4d400d169f9697be01"}
{"text_full":"[DESCRIPTION]Given three numbers $$$n, a, b$$$. You need to find an adjacency matrix of such an undirected graph that the number of components in it is equal to $$$a$$$, and the number of components in its complement is $$$b$$$. The matrix must be symmetric, and all digits on the main diagonal must be zeroes.In an undirected graph loops (edges from a vertex to itself) are not allowed. It can be at most one edge between a pair of vertices.The adjacency matrix of an undirected graph is a square matrix of size $$$n$$$ consisting only of \"0\" and \"1\", where $$$n$$$ is the number of vertices of the graph and the $$$i$$$-th row and the $$$i$$$-th column correspond to the $$$i$$$-th vertex of the graph. The cell $$$(i,j)$$$ of the adjacency matrix contains $$$1$$$ if and only if the $$$i$$$-th and $$$j$$$-th vertices in the graph are connected by an edge.A connected component is a set of vertices $$$X$$$ such that for every two vertices from this set there exists at least one path in the graph connecting this pair of vertices, but adding any other vertex to $$$X$$$ violates this rule.The complement or inverse of a graph $$$G$$$ is a graph $$$H$$$ on the same vertices such that two distinct vertices of $$$H$$$ are adjacent if and only if they are not adjacent in $$$G$$$.[SOURCE CODE]from collections import defaultdict\n\nn,a,b = map(int,input().split())\n\nhash = defaultdict(list)\n\n# debug\n# def dfs(n):\n# \n# \n#     bool[n] = True\n#     for i in hash[n]:\n#         if bool[i] == False:\n#             dfs(i)\n\n\n\nif a == 1 and b == 1:\n    if n == 2 or n == 3:\n        print('NO')\n        exit()\n\nif a == 1 or b == 1:\n\n\n    bool = [False]*(n+1)\n\n    if a>n or b>n:\n        print('NO')\n        exit()\n    print('YES')\n\n    l = []\n    for i in range(n):\n        z = ['0']*(n)\n        l.append(z)\n    ans = []\n\n    for i in range(n):\n        z = ['0']*(n)\n        ans.append(z)\n\n    if b == 1:\n\n\n\n\n        for i in range(a-1,n-1):\n            # hash[i].add(i+1)\n            # hash[i+1].add(i)\n            l[i][i+1] = '1'\n            l[i+1][i] = '1'\n            # hash[i+1].append(i)\n            # hash[i].append(i+1)\n\n\n        # count = 0\n        # for i in range(n):\n        #     if bool[i] == False:\n        #\n        #         dfs(i)\n        #         count+=1\n        # if a == 1 and b == 1:\n\n        for i in l:\n            print(''.join(i))\n    else:\n\n\n        ans = []\n\n        for i in range(n):\n           z = ['0']*(n)\n           ans.append(z)\n\n        for i in range(b-1,n-1):\n            # hash[i].add(i+1)\n            # hash[i+1].add(i)\n            l[i][i+1] = '1'\n            l[i+1][i] = '1'\n            # hash[i+1].append(i)\n            # hash[i].append(i+1)\n        # for i in l:\n        #     print(*i)\n        for i in range(n):\n            for j in range(n):\n                if i!=j:\n                    if l[i][j] == '1':\n                        ans[i][j] = '0'\n                    if l[i][j] == '0':\n                        ans[i][j] = '1'\n                        # hash[i+1].append(j+1)\n        # count = 0\n        # for i in range(n):\n        #     if bool[i] == False:\n        #\n        #         dfs(i)\n        #         count+=1\n\n\n        for i in ans:\n            print(''.join(i))\n\n\n\nelse:\n    print('NO')","tags":["graphs"],"src_uid":"8adebeaed713b7e90c68553127d17b19"}
{"text_full":"[DESCRIPTION]A group of n merry programmers celebrate Robert Floyd's birthday. Polucarpus has got an honourable task of pouring Ber-Cola to everybody. Pouring the same amount of Ber-Cola to everybody is really important. In other words, the drink's volume in each of the n mugs must be the same.Polycarpus has already began the process and he partially emptied the Ber-Cola bottle. Now the first mug has a1 milliliters of the drink, the second one has a2 milliliters and so on. The bottle has b milliliters left and Polycarpus plans to pour them into the mugs so that the main equation was fulfilled.Write a program that would determine what volume of the drink Polycarpus needs to add into each mug to ensure that the following two conditions were fulfilled simultaneously:   there were b milliliters poured in total. That is, the bottle need to be emptied;  after the process is over, the volumes of the drink in the mugs should be equal.[SOURCE CODE]x=[int(i) for i in input().split()]\nn=x[0]\ny=[int(i) for i in input().split()]\nif x[1]<max(y)*n-sum(y):\n    print(-1)\n    raise SystemExit\n\nfor i in range(n):\n    s=x[1]\/n-y[i]++sum(y)\/n\n    print('%.6f'% s)","tags":["math"],"src_uid":"65fea461d3caa5a932d1e2c13e99a59e"}
{"text_full":"[DESCRIPTION]Fishing Prince loves trees, and he especially loves trees with only one centroid. The tree is a connected graph without cycles.A vertex is a centroid of a tree only when you cut this vertex (remove it and remove all edges from this vertex), the size of the largest connected component of the remaining graph is the smallest possible.For example, the centroid of the following tree is $$$2$$$, because when you cut it, the size of the largest connected component of the remaining graph is $$$2$$$ and it can't be smaller.  However, in some trees, there might be more than one centroid, for example:  Both vertex $$$1$$$ and vertex $$$2$$$ are centroids because the size of the largest connected component is $$$3$$$ after cutting each of them.Now Fishing Prince has a tree. He should cut one edge of the tree (it means to remove the edge). After that, he should add one edge. The resulting graph after these two operations should be a tree. He can add the edge that he cut.He wants the centroid of the resulting tree to be unique. Help him and find any possible way to make the operations. It can be proved, that at least one such way always exists.[SOURCE CODE]######################################################\n############Created by Devesh Kumar###################\n#############devesh1102@gmail.com####################\n##########For CodeForces(Devesh1102)#################\n#####################2020#############################\n######################################################\nimport sys\ninput = sys.stdin.readline\n \nimport sys \nimport heapq \nimport copy\nimport math\nimport decimal\n \n# import sys.stdout.flush as flush\n# from decimal import *\n#heapq.heapify(li) \n#\n#heapq.heappush(li,4) \n#\n#heapq.heappop(li)\n#\n# &    Bitwise AND Operator    10 & 7 = 2\n# |    Bitwise OR Operator    10 | 7 = 15\n# ^    Bitwise XOR Operator    10 ^ 7 = 13\n \n# <<    Bitwise Left Shift operator    10<<2 = 40\n# >>    Bitwise Right Shift Operator\n# '''############ ---- Input Functions ---- #######Start#####'''\n# n = 100\n# parent = [-1 for i in range(n)]\n# def find(a):\n#     if parent[a] == a:\n#         return a\n#     else:\n#         parent[a] = find(parent[a])\n    \n# def union(a,b):\n\n\n\n\n\n\n\n\n    # print(lsp )\ndef inp():\n    return(int(input()))\ndef inlt(): \n    return(list(map(int,input().split())))\ndef insr():\n    s = input()\n    return(list(s[:len(s) - 1]))\ndef insr2():\n    s = input()\n    s = list(s[:len(s) - 1])\n    s = [ord(s[i]) - ord(\"a\") for i in range(len(s))]\n    return s\ndef invr():\n    return(map(int,input().split()))\n############ ---- Input Functions ---- #######End\n# #####   \n\n\nans = 0\ndef pr_list(a):\n    print( *a , sep=\" \")\n\ndef swap(a,b):\n    temp = a\n    a = b\n    b = temp\n    return [ a,b]\n    # return [b,a]\ndef pri(a,b):\n    s = \"? \" + str(a) + \" \" + str(b)\n    print(s)\n    sys.stdout.flush()\ndef main():\n    tests =  inp()\n    # tests = 1\n    mod = 1000000007\n    limit = 10**18\n    ans = 0\n    stack = []\n    hashm = {}\n    arr = []\n    heapq.heapify(arr) \n    def find_next(hashm,itr):\n        for i in range(itr,len(hashm)):\n            if hashm[i] == 0:\n                return i \n\n    for test in range(tests):\n        n= inp()\n        edges = [{} for i in range(n+1)]\n        dum = []\n        for j in range(n-1):\n            [a,b]  = inlt()\n            edges[a][b] = 1\n            edges[b][a] = 1\n            dum = [a,b]\n        # e = copy.deepcopy(edges)\n        \n        children = [0 for i in range (n+1)]\n        done = [-1 for i in range(n+1)]\n        stack = [1]\n        done [1] = 1\n        while(stack!= []):\n            # print(stack)\n            curr= stack[-1]\n            flag = 0\n            for child in edges[curr]:\n                if done[child] == -1:\n                    done[child] = 1\n                    flag = 1\n                    stack.append(child)\n                if curr in edges[child]:\n                    del edges[child][curr]\n            if flag == 1:\n                continue\n            curr= stack.pop()\n            c = 0\n            for i in edges[curr]:\n                c = c + children[i] + 1\n            children[curr] = c\n        # print(children)\n        # print(edges)\n        centroid = [[sys.maxsize,i] for i in range(n+1)]\n        for i in range(1,n+1):\n            sums = 0\n            maxi = -1*sys.maxsize\n            for j in edges[i]:\n                sums= sums+ children[j] + 1\n                maxi = max(maxi,children[j] +  1)\n            maxi = max(maxi, n-1 - sums)\n            centroid[i][0] = maxi\n        centroid.sort()\n        # print(centroid)\n        if centroid[0][0] != centroid[1][0]:\n            pr_list(dum)\n            pr_list(dum)\n            continue\n        a = centroid[0][1]\n        b = centroid[1][1]\n\n        def find_leaf(a,b):\n            done = [0 for i in range(n+1)]\n            done[a] = 1 \n            # print(e)\n            stack = [a]\n            leaf = []\n            while(stack!=[] and leaf == []):\n                curr= stack.pop()\n                for i in edges[curr]:\n                    if len(edges[i])== 0 :\n                        leaf = [curr,i]\n                        return leaf\n                    elif i!= b and done[i] != 1:\n                        done[i] = 1\n                        stack.append(i)\n            return leaf\n        leaf =    find_leaf(a,b)\n        if leaf == []:\n            leaf = find_leaf(b,a)\n            pr_list(leaf)\n            n_edge = [leaf[1], a]\n            pr_list(n_edge)\n        else:\n            pr_list(leaf)\n            n_edge = [leaf[1], b]\n            pr_list(n_edge)\n\n\n\n\n        \n\n\n\n\n            \n                \n\n        \n\n\nif __name__== \"__main__\":\n    main()","tags":["trees","graphs"],"src_uid":"b01fb9d4d78a02e3c634800b4b177d75"}
{"text_full":"[DESCRIPTION]There are n stone quarries in Petrograd.Each quarry owns mi dumpers (1 ≤ i ≤ n). It is known that the first dumper of the i-th quarry has xi stones in it, the second dumper has xi + 1 stones in it, the third has xi + 2, and the mi-th dumper (the last for the i-th quarry) has xi + mi - 1 stones in it.Two oligarchs play a well-known game Nim. Players take turns removing stones from dumpers. On each turn, a player can select any dumper and remove any non-zero amount of stones from it. The player who cannot take a stone loses.Your task is to find out which oligarch will win, provided that both of them play optimally. The oligarchs asked you not to reveal their names. So, let's call the one who takes the first stone «tolik» and the other one «bolik».[SOURCE CODE]def f(x):\n    if x%4==0:\n        return x\n    elif x%4==1:\n        return 1\n    elif x%4==2:\n        return x+1\n    return 0\n\nn = int(input())\nres = 0\nfor i in range(n):\n    x,m = input().split()\n    x,m = int(x),int(m)\n    res ^= f(x-1)^f(x+m-1)\n\nif res == 0:\n    print(\"bolik\")\nelse:\n    print(\"tolik\")","tags":["games"],"src_uid":"55099493c66b003d4261310bf2cc8f93"}
{"text_full":"[DESCRIPTION]There are two sisters Alice and Betty. You have $$$n$$$ candies. You want to distribute these $$$n$$$ candies between two sisters in such a way that:  Alice will get $$$a$$$ ($$$a &gt; 0$$$) candies;  Betty will get $$$b$$$ ($$$b &gt; 0$$$) candies;  each sister will get some integer number of candies;  Alice will get a greater amount of candies than Betty (i.e. $$$a &gt; b$$$);  all the candies will be given to one of two sisters (i.e. $$$a+b=n$$$). Your task is to calculate the number of ways to distribute exactly $$$n$$$ candies between sisters in a way described above. Candies are indistinguishable.Formally, find the number of ways to represent $$$n$$$ as the sum of $$$n=a+b$$$, where $$$a$$$ and $$$b$$$ are positive integers and $$$a&gt;b$$$.You have to answer $$$t$$$ independent test cases.[SOURCE CODE]from math import ceil\nT=int(input())\nwhile T>0:\n      A=int(input())\n      B=ceil(A-A\/2-1)\n      print(B)\n      T-=1","tags":["math"],"src_uid":"b69170c8377623beb66db4706a02ffc6"}
{"text_full":"[DESCRIPTION]Mahmoud wrote a message s of length n. He wants to send it as a birthday present to his friend Moaz who likes strings. He wrote it on a magical paper but he was surprised because some characters disappeared while writing the string. That's because this magical paper doesn't allow character number i in the English alphabet to be written on it in a string of length more than ai. For example, if a1 = 2 he can't write character 'a' on this paper in a string of length 3 or more. String \"aa\" is allowed while string \"aaa\" is not.Mahmoud decided to split the message into some non-empty substrings so that he can write every substring on an independent magical paper and fulfill the condition. The sum of their lengths should be n and they shouldn't overlap. For example, if a1 = 2 and he wants to send string \"aaa\", he can split it into \"a\" and \"aa\" and use 2 magical papers, or into \"a\", \"a\" and \"a\" and use 3 magical papers. He can't split it into \"aa\" and \"aa\" because the sum of their lengths is greater than n. He can split the message into single string if it fulfills the conditions.A substring of string s is a string that consists of some consecutive characters from string s, strings \"ab\", \"abc\" and \"b\" are substrings of string \"abc\", while strings \"acb\" and \"ac\" are not. Any string is a substring of itself.While Mahmoud was thinking of how to split the message, Ehab told him that there are many ways to split it. After that Mahmoud asked you three questions:   How many ways are there to split the string into substrings such that every substring fulfills the condition of the magical paper, the sum of their lengths is n and they don't overlap? Compute the answer modulo 109 + 7.  What is the maximum length of a substring that can appear in some valid splitting?  What is the minimum number of substrings the message can be spit in? Two ways are considered different, if the sets of split positions differ. For example, splitting \"aa|a\" and \"a|aa\" are considered different splittings of message \"aaa\".[SOURCE CODE]n=int(input())\ns=input()\nl=list(map(int,input().split()))\ndp=[0]*(n+2)\nmn=[10**4]*(n+2)\ndp[0]=dp[n+1]=1\nmn[0]=1\nmn[n+1]=0\nmod=10**9+7\nmaxx=1\nfor i in range(1,n):\n  cur=10**4\n\n  for j in range(i,-1,-1):\n    c=ord(s[j])-ord('a')\n    cur=min(cur,l[c])\n    if cur<(i-j+1):\n      break\n    dp[i]=(dp[i]+dp[j-1])%mod\n    mn[i]=min(mn[i],mn[j-1]+1)\n    maxx=max(maxx,i-j+1)\n#print(dp)\nprint(dp[n-1])\nprint(maxx)\nprint(mn[n-1])","tags":["strings"],"src_uid":"b56e70728d36c41134c39bd6ad13d059"}
{"text_full":"[DESCRIPTION]Bear Limak examines a social network. Its main functionality is that two members can become friends (then they can talk with each other and share funny pictures).There are n members, numbered 1 through n. m pairs of members are friends. Of course, a member can't be a friend with themselves.Let A-B denote that members A and B are friends. Limak thinks that a network is reasonable if and only if the following condition is satisfied: For every three distinct members (X, Y, Z), if X-Y and Y-Z then also X-Z.For example: if Alan and Bob are friends, and Bob and Ciri are friends, then Alan and Ciri should be friends as well.Can you help Limak and check if the network is reasonable? Print \"YES\" or \"NO\" accordingly, without the quotes.[SOURCE CODE]n, m = map(int, raw_input().split())\n\nvisited = [False for i in xrange(n+1)]\ngraph = [[] for i in xrange(n+1)]\n\nfor i in xrange(m):\n    a, b = map(int, raw_input().split())\n    graph[a].append(b)\n    graph[b].append(a)\n    \ndef dfs(node, countV = 0, countE = 0):\n    stack = [node]\n    while stack:\n        top = stack.pop()\n        if not visited[top]:\n            visited[top] = True\n            countV += 1\n            countE += len(graph[top])\n            for i in graph[top]:\n                if not visited[i]:\n                    stack.append(i)\n    return countE, countV\n    \nflag = True\nfor i in xrange(1, n+1):\n    if not visited[i]:\n        countE, countV = dfs(i)\n        if countE != countV*(countV-1):\n            flag = False\n            break\n        \nif flag:\n    print 'YES'\nelse:\n    print 'NO'","tags":["graphs"],"src_uid":"1173d89dd3af27b46e579cdeb2cfdfe5"}
{"text_full":"[DESCRIPTION]You're given an undirected graph with $$$n$$$ nodes and $$$m$$$ edges. Nodes are numbered from $$$1$$$ to $$$n$$$.The graph is considered harmonious if and only if the following property holds:  For every triple of integers $$$(l, m, r)$$$ such that $$$1 \\le l &lt; m &lt; r \\le n$$$, if there exists a path going from node $$$l$$$ to node $$$r$$$, then there exists a path going from node $$$l$$$ to node $$$m$$$. In other words, in a harmonious graph, if from a node $$$l$$$ we can reach a node $$$r$$$ through edges ($$$l &lt; r$$$), then we should able to reach nodes $$$(l+1), (l+2), \\ldots, (r-1)$$$ too.What is the minimum number of edges we need to add to make the graph harmonious?[SOURCE CODE]from sys import stdin\nfrom itertools import repeat\ndef main():\n    n, m = map(int, stdin.readline().split())\n    dat = map(int, stdin.read().split(), repeat(10, 2 * m))\n    par = range(n + 1)\n    st = []\n    pu = st.append\n    for i in xrange(m):\n        x, y = dat[i*2], dat[i*2+1]\n        while x != par[x]:\n            pu(x)\n            x = par[x]\n        pu(x)\n        while y != par[y]:\n            pu(y)\n            y = par[y]\n        for x in st:\n            par[x] = y\n        del st[:]\n    l = range(n + 1)\n    r = range(n + 1)\n    c = [0] * (n + 1)\n    s = set()\n    for i in xrange(1, n + 1):\n        x = i\n        while x != par[x]:\n            pu(x)\n            x = par[x]\n        for y in st:\n            par[y] = x\n        del st[:]\n        if l[x] > i:\n            l[x] = i\n        if r[x] < i:\n            r[x] = i\n        c[x] += 1\n        if x == i:\n            s.add(x)\n    ans = 0\n    f = 1\n    while f:\n        f = 0\n        t = s.copy()\n        for i in s:\n            if c[i] == r[i] - l[i] + 1 or i not in t:\n                continue\n            for j in xrange(l[i], r[i] + 1):\n                x = j\n                while x != par[x]:\n                    pu(x)\n                    x = par[x]\n                if x != i:\n                    f = 1\n                    if l[i] > l[x]:\n                        l[i] = l[x]\n                    if r[i] < r[x]:\n                        r[i] = r[x]\n                    c[i] += c[x]\n                    pu(x)\n                    ans += 1\n                    t.remove(x)\n                for y in st:\n                    par[y] = i\n                del st[:]\n        s = t\n    print ans\nmain()","tags":["graphs"],"src_uid":"04fd1a55027cce56a491b984ce3a1d6d"}
{"text_full":"[DESCRIPTION]New Year is coming in Tree World! In this world, as the name implies, there are n cities connected by n - 1 roads, and for any two distinct cities there always exists a path between them. The cities are numbered by integers from 1 to n, and the roads are numbered by integers from 1 to n - 1. Let's define d(u, v) as total length of roads on the path between city u and city v.As an annual event, people in Tree World repairs exactly one road per year. As a result, the length of one road decreases. It is already known that in the i-th year, the length of the ri-th road is going to become wi, which is shorter than its length before. Assume that the current year is year 1.Three Santas are planning to give presents annually to all the children in Tree World. In order to do that, they need some preparation, so they are going to choose three distinct cities c1, c2, c3 and make exactly one warehouse in each city. The k-th (1 ≤ k ≤ 3) Santa will take charge of the warehouse in city ck.It is really boring for the three Santas to keep a warehouse alone. So, they decided to build an only-for-Santa network! The cost needed to build this network equals to d(c1, c2) + d(c2, c3) + d(c3, c1) dollars. Santas are too busy to find the best place, so they decided to choose c1, c2, c3 randomly uniformly over all triples of distinct numbers from 1 to n. Santas would like to know the expected value of the cost needed to build the network.However, as mentioned, each year, the length of exactly one road decreases. So, the Santas want to calculate the expected after each length change. Help them to calculate the value.[SOURCE CODE]from queue import Queue\nimport sys\n\ncost = []\n\ndef readarray(): return map(int, input().split(' '))\n\nn = int(input())\ngraph = [[] for i in range(n)]\n\nfor i in range(n - 1):\n\tu, v, c = readarray()\n\tu, v = u - 1, v - 1\n\tcost.append(c)\n\tgraph[u].append((v, i))\n\tgraph[v].append((u, i))\n\t\n\norder = []\nused = [0] * n\nq = [0] * (n + n)\n\nqh = qt = 0\n\n\nused[qh] = 1\nqh += 1\n\nwhile qt < qh:\n\tv = q[qt]\n\tqt += 1\n\t\n\torder.append(v)\n\t\n\tfor (to, e) in graph[v]:\n\t\tif used[to]:\n\t\t\tcontinue\n\t\tused[to] = 1\n\t\tq[qh] = to\n\t\tqh += 1\n\t\t\n\n\t\t\norder.reverse()\n\t\t\nsz = [0 for x in range(n)]\n\nfor v in order:\n\tsz[v] = 1\n\tfor (to, e) in graph[v]:\n\t\tsz[v] += sz[to]\n\"\"\"\n\nsz = [0] * n\n\nsys.setrecursionlimit(100505)\n\ndef dfs(v, p):\n\tsz[v] = 1\n\t\n\tfor (to, e) in graph[v]:\n\t\tif to != p:\n\t\t\tdfs(to, v)\n\t\t\tsz[v] += sz[to]\n\t\t\t\ndfs(0, -1)\n\n\"\"\"\n\ndistanceSum = 0.0\nedgeMult = [0] * n\n\nfor v in range(n):\n\tfor (to, e) in graph[v]:\n\t\tx = min(sz[v], sz[to])\n\t\tedgeMult[e] = x\n\t\tdistanceSum += 1.0 * cost[e] * x * (n - x)\n\t\t\ndistanceSum \/= 2.0\n\nqueryCnt = int(input())\n\nans = []\n\nfor i in range(queryCnt):\n\tx, y = readarray()\n\tx -= 1\n\t\n\tdistanceSum -= 1.0 * cost[x] * edgeMult[x] * (n - edgeMult[x])\n\tcost[x] = y\n\tdistanceSum += 1.0 * cost[x] * edgeMult[x] * (n - edgeMult[x])\n\t\n\tans.append('%.10lf' % (distanceSum \/ n \/ (n - 1) * 6.0))\n\nprint('\\n'.join(ans))","tags":["trees","graphs"],"src_uid":"38388446f5c265f77124132caa3ce4d2"}
{"text_full":"[DESCRIPTION]Berland, 2016. The exchange rate of currency you all know against the burle has increased so much that to simplify the calculations, its fractional part was neglected and the exchange rate is now assumed to be an integer.Reliable sources have informed the financier Anton of some information about the exchange rate of currency you all know against the burle for tomorrow. Now Anton knows that tomorrow the exchange rate will be an even number, which can be obtained from the present rate by swapping exactly two distinct digits in it. Of all the possible values that meet these conditions, the exchange rate for tomorrow will be the maximum possible. It is guaranteed that today the exchange rate is an odd positive integer n. Help Anton to determine the exchange rate of currency you all know for tomorrow![SOURCE CODE]#!\/usr\/bin\/env python\n# -*- encoding: utf-8 -*-\n# pylint: disable=C0111\n\ndef main():\n    n = list(raw_input().strip())\n    maxswap = (0, -1)\n    for x in xrange(len(n) - 2, -1, -1):\n        if int(n[x]) % 2 == 0:\n            if maxswap[0] == 0 or (int(n[-1]) - int(n[x]) > 0):\n                maxswap = (int(n[-1]) - int(n[x]), x)\n\n    if maxswap[1] != -1:\n        x = maxswap[1]\n        n[x], n[-1] = n[-1], n[x]\n        print ''.join(n)\n    else:\n        print -1\n\nmain()","tags":["math","strings"],"src_uid":"bc375e27bd52f413216aaecc674366f8"}
{"text_full":"[DESCRIPTION]Ramesses knows a lot about problems involving trees (undirected connected graphs without cycles)!He created a new useful tree decomposition, but he does not know how to construct it, so he asked you for help!The decomposition is the splitting the edges of the tree in some simple paths in such a way that each two paths have at least one common vertex. Each edge of the tree should be in exactly one path.Help Remesses, find such a decomposition of the tree or derermine that there is no such decomposition.[SOURCE CODE]n = int(input())\ndeg = [0]*100005\nleaves = []\nfor i in range(1,n):\n    a,b = map(int, input().split())\n    deg[a]+=1\n    deg[b]+=1\ncnt = 0\nmxdeg = 0\nroot = 0\nfor j in range(1,n+1):\n    if deg[j]>mxdeg:\n        mxdeg = deg[j]\n        root = j\n    if deg[j] == 1:\n        leaves.append(j)\n    if deg[j] > 2:\n        cnt+=1\nif cnt>1:\n    print(\"No\")\n    exit()\nprint(\"Yes\")\nm = 0\nfor it in leaves:\n    if it != root:\n        m+=1\nprint(m)\nfor it2 in leaves:\n    if it2 != root:\n        print(root,it2)","tags":["trees"],"src_uid":"0a476638c2122bfb236b53742cf8a89d"}
{"text_full":"[DESCRIPTION]Little Petya likes numbers a lot. Recently his mother has presented him a collection of n non-negative integers. There's only one thing Petya likes more than numbers: playing with little Masha. He immediately decided to give a part of his new collection to her. To make the game even more interesting, Petya decided to give Masha such collection of numbers for which the following conditions fulfill:  Let's introduce x1 to denote the xor of all numbers Petya has got left; and let's introduce x2 to denote the xor of all numbers he gave to Masha. Value (x1 + x2) must be as large as possible.  If there are multiple ways to divide the collection so that the previous condition fulfilled, then Petya minimizes the value x1. The xor operation is a bitwise excluding \"OR\", that is denoted as \"xor\" in the Pascal language and \"^\" in C\/C++\/Java.Help Petya divide the collection as described above. If there are multiple suitable ways to divide it, find any of them. Please note that after Petya gives a part of his numbers to Masha, he may have no numbers left. The reverse situation is also possible, when Petya gives nothing to Masha. In both cases we must assume that the xor of an empty set of numbers equals 0.[SOURCE CODE]import sys\nrange = xrange\ninput = raw_input\n \nn = int(input())\nA = [int(x) for x in input().split()]\n \n\n# Reorder the bits\nbig = 60\nmapper = [0]*big\nind = big - 1\nxor = 0\nfor a in A: \n    xor ^= a\nfor j in reversed(range(big)):\n    if xor & (1 << j) == 0:\n        mapper[j] = ind\n        ind -= 1\nfor j in reversed(range(big)):\n    if xor & (1 << j):\n        mapper[j] = ind\n        ind -= 1\n\nB = []\nfor a in A:\n    tmp = 0\n    for j in range(big):\n        if a & (1 << j):\n            tmp += 1 << mapper[j]\n    B.append(tmp)\nA = B\n\n# returns a subset of A with maximum xor\ndef max_xor(A):\n    who = []\n    how = {}\n    base = {}\n     \n    for i in range(n):\n        a = A[i]\n        tmp = 0\n        while a > 0:\n            b = a.bit_length() - 1\n            if b in how:\n                a ^= base[b]\n                tmp ^= how[b]\n            else:\n                base[b] = a\n                how[b] = tmp | (1 << len(who))\n                who.append(i)\n                break\n    x = 0\n    tmp = 0\n    for j in sorted(how, reverse = True):\n        if not x & (1 << j):\n            x ^= base[j]\n            tmp ^= how[j]\n    B = [who[j] for j in range(len(who)) if tmp & (1 << j)]\n    return B\n\nans = [1]*n\nfor i in max_xor(A):\n    ans[i] = 2\nprint ' '.join(str(x) for x in ans)","tags":["math"],"src_uid":"2c279b3065d8da8021051241677d9cf1"}
{"text_full":"[DESCRIPTION]One day, as Sherlock Holmes was tracking down one very important criminal, he found a wonderful painting on the wall. This wall could be represented as a plane. The painting had several concentric circles that divided the wall into several parts. Some parts were painted red and all the other were painted blue. Besides, any two neighboring parts were painted different colors, that is, the red and the blue color were alternating, i. e. followed one after the other. The outer area of the wall (the area that lied outside all circles) was painted blue. Help Sherlock Holmes determine the total area of red parts of the wall.Let us remind you that two circles are called concentric if their centers coincide. Several circles are called concentric if any two of them are concentric.[SOURCE CODE]n = int(input())\npie = 3.1415926536\n\narr = list(map(int, input().split()))\nans = 0.0\n\narr.sort()\ncnt = 0\nfor i in range(n-1,-1,-1):\n    if cnt % 2 == 0:\n        ans += arr[i] * arr[i] * pie\n    else:\n        ans -= arr[i] * arr[i] * pie\n    cnt += 1\n\nprint(ans)\n\n\n### 1 2 3 4","tags":["geometry"],"src_uid":"48b9c68380d3bd64bbc69d921a098641"}
{"text_full":"[DESCRIPTION]You are given an array $$$a_1, a_2, \\dots, a_n$$$. All $$$a_i$$$ are pairwise distinct.Let's define function $$$f(l, r)$$$ as follows:   let's define array $$$b_1, b_2, \\dots, b_{r - l + 1}$$$, where $$$b_i = a_{l - 1 + i}$$$;  sort array $$$b$$$ in increasing order;  result of the function $$$f(l, r)$$$ is $$$\\sum\\limits_{i = 1}^{r - l + 1}{b_i \\cdot i}$$$. Calculate $$$\\left(\\sum\\limits_{1 \\le l \\le r \\le n}{f(l, r)}\\right) \\mod (10^9+7)$$$, i.e. total sum of $$$f$$$ for all subsegments of $$$a$$$ modulo $$$10^9+7$$$.[SOURCE CODE]import sys\n\nMOD = (int)(1e9+7)\n\ndef add(a, b):\n\ta += b\n\tif a >= MOD: a -= MOD\n\treturn a\n\t\ndef mul(a, b):\n\treturn (a * b) % MOD\n\nclass fenwickTree:\n\tdef __init__(self, max_val):\n\t\tself.max_val = max_val + 5\n\t\tself.tree = [0] * self.max_val\n\t\n\tdef update(self, idx, value):\n\t\tidx += 1\n\t\twhile idx < self.max_val:\n\t\t\tself.tree[idx] = add(self.tree[idx], value)\n\t\t\tidx += (idx & (-idx))\n\t\n\tdef read(self, idx):\n\t\tidx += 1\n\t\tres = 0\n\t\twhile idx > 0:\n\t\t\tres = add(res, self.tree[idx])\n\t\t\tidx -= (idx & (-idx))\n\t\treturn res\n\ninp = [int(x) for x in sys.stdin.read().split()]\n\nn = inp[0]\na = []\nfor i in range(1, n + 1):\n\ta.append(inp[i])\n\t\nsorted_array = sorted(a)\ndict = {}\nfor i in range(n):\n\tdict[sorted_array[i]] = i\n\t\nfactor = [0] * n\nfor i in range(0, n):\n\tfactor[i] = mul(i + 1, n - i)\n\t\nleft_tree = fenwickTree(n)\nfor i in range(0, n):\n\telement_idx = dict[a[i]]\n\tfactor[i] = add(factor[i], mul(n - i, left_tree.read(element_idx)))\n\tleft_tree.update(element_idx, i + 1)\n\t\nright_tree = fenwickTree(n)\nfor i in range(n - 1, -1, -1):\n\telement_idx = dict[a[i]]\n\tfactor[i] = add(factor[i], mul(i + 1, right_tree.read(element_idx)))\n\tright_tree.update(element_idx, n - i)\n\nans = 0\nfor i in range(n):\n\tans = add(ans, mul(a[i], factor[i]))\nprint(ans)","tags":["math"],"src_uid":"f4a9abc1cdfcdc2c96982477f17a197b"}
{"text_full":"[DESCRIPTION]Vitya is studying in the third grade. During the last math lesson all the pupils wrote on arithmetic quiz. Vitya is a clever boy, so he managed to finish all the tasks pretty fast and Oksana Fillipovna gave him a new one, that is much harder.Let's denote a flip operation of an integer as follows: number is considered in decimal notation and then reverted. If there are any leading zeroes afterwards, they are thrown away. For example, if we flip 123 the result is the integer 321, but flipping 130 we obtain 31, and by flipping 31 we come to 13.Oksana Fillipovna picked some number a without leading zeroes, and flipped it to get number ar. Then she summed a and ar, and told Vitya the resulting value n. His goal is to find any valid a.As Oksana Fillipovna picked some small integers as a and ar, Vitya managed to find the answer pretty fast and became interested in finding some general algorithm to deal with this problem. Now, he wants you to write the program that for given n finds any a without leading zeroes, such that a + ar = n or determine that such a doesn't exist.[SOURCE CODE]#!\/usr\/bin\/python3\n\ndef can(s, n):\n    if n == 0:\n        return \"\"\n    \n    cs = list(map(int, s))\n    was_over = [False for i in range(n)]\n    ans = [0 for i in range(n)]\n    i, j = 0, n - 1\n    last = int(n == len(cs) - 1)\n    while i < j:\n        need_a = last * 10 + cs[i]\n        need_b = last * 10 + cs[j]\n        if last == 1 and cs[i] == 9 and cs[j] == 0:\n            need_a = 9\n            need_b = 10\n        if abs(need_a - need_b) > 1:\n            return \"\"\n        if need_a == need_b + 1:\n            return \"\"\n        if need_a == need_b == 19:\n            return \"\"\n\n        if need_a >= 10:\n            ans[j] = 9\n            ans[i] = need_a - 9\n        else:\n            ans[j] = need_a\n            ans[i] = 0\n\n        if need_a >= 10 or was_over[i]:\n            cs[i + 1] = (cs[i + 1] - 1) % 10\n            if cs[i + 1] == 9:\n                was_over[i + 1] = True\n            \n        last = (need_b == need_a + 1)\n        \n        i += 1\n        j -= 1\n\n    if i == j:\n        need = last * 10 + cs[i]\n        if need % 2 != 0:\n            return \"\"\n        ans[i] = need \/\/ 2\n\n    if int(\"\".join(map(str, ans))) + int(\"\".join(map(str, reversed(ans)))) != int(\"\".join(map(str, reversed(s)))):\n        return \"\"\n        \n    return \"\".join(map(str, reversed(ans)))\n\n\ns = \"\".join(reversed(input()))\nif s[0] != '0':\n    t = can(s, len(s))\n    if t != \"\":\n        print(t)\n        exit(0)\nif s[-1] == '1':\n    t = can(s, len(s) - 1)\n    if t != \"\":\n        print(t)\n        exit(0)\n\nprint(0)","tags":["math"],"src_uid":"fc892e4aac2d60e53f377a582f5ba7d3"}
{"text_full":"[DESCRIPTION]You have n distinct points on a plane, none of them lie on OY axis. Check that there is a point after removal of which the remaining points are located on one side of the OY axis.[SOURCE CODE]n=int(input())\ncountl=0\ncountr=0\nfor _ in range(n):\n  a,b=map(int,input().split())\n  if a<0:\n    countl+=1\n  else:\n    countr+=1\nif min(countl,countr)<=1:\n  print(\"Yes\")\nelse:\n  print(\"No\")","tags":["geometry"],"src_uid":"cf7bf89a6038586b69d3b8021cee0b27"}
{"text_full":"[DESCRIPTION]The main server of Gomble company received a log of one top-secret process, the name of which can't be revealed. The log was written in the following format: «[date:time]: message», where for each «[date:time]» value existed not more than 10 lines. All the files were encoded in a very complicated manner, and only one programmer — Alex — managed to decode them. The code was so complicated that Alex needed four weeks to decode it. Right after the decoding process was finished, all the files were deleted. But after the files deletion, Alex noticed that he saved the recordings in format «[time]: message». So, information about the dates was lost. However, as the lines were added into the log in chronological order, it's not difficult to say if the recordings could appear during one day or not. It is possible also to find the minimum amount of days during which the log was written.So, to make up for his mistake Alex has to find the minimum amount of days covered by the log. Note that Alex doesn't have to find the minimum amount of days between the beginning and the end of the logging, he has to find the minimum amount of dates in which records could be done. (See Sample test 2 for further clarifications).We should remind you that the process made not more than 10 recordings in a minute. Consider that a midnight belongs to coming day.[SOURCE CODE]#------------------------template--------------------------#\nimport os\nimport sys\nfrom math import *\nfrom collections import *\n# from fractions import *\n# from heapq import*\nfrom bisect import *\nfrom io import BytesIO, IOBase\ndef vsInput():\n    sys.stdin = open('input.txt', 'r')\n    sys.stdout = open('output.txt', 'w')\nBUFSIZE = 8192\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\nALPHA='abcdefghijklmnopqrstuvwxyz'\nM=10**9+7\nEPS=1e-6\ndef Ceil(a,b): return a\/\/b+int(a%b>0)\ndef value():return tuple(map(int,input().split()))\ndef array():return [int(i) for i in input().split()]\ndef Int():return int(input())\ndef Str():return input()\ndef arrayS():return [i for i in input().split()]\n\n\n#-------------------------code---------------------------#\n# vsInput()\n\ndef To24Format(s):\n    time,pm=s.split()\n    h,sec=[int(i) for i in time.split(':')]\n    h%=12\n\n    if(pm=='p.m.'):\n        h+=12\n\n    return (h,sec)\n\n\nn=Int()\na=[]\n\nfor i in range(n):\n    s=input()\n    s=s[1:11]\n    a.append(To24Format(s))\n\n\nlast=(inf,inf)\nday=0\nc=0\n# print(a)\n\nfor i in a:\n\n    if(i<last):\n        day+=1\n        c=1\n    elif(i==last): c+=1\n    else: c=1\n\n    if(c>10):\n        c=1\n        day+=1\n    \n    last=i\n\n\nprint(day)","tags":["strings"],"src_uid":"54f8b8e6711ff5c69e0bc38a6e2f4999"}
{"text_full":"[DESCRIPTION]You are given a sequence of n positive integers d1, d2, ..., dn (d1 &lt; d2 &lt; ... &lt; dn). Your task is to construct an undirected graph such that:  there are exactly dn + 1 vertices;  there are no self-loops;  there are no multiple edges;  there are no more than 106 edges;  its degree set is equal to d. Vertices should be numbered 1 through (dn + 1).Degree sequence is an array a with length equal to the number of vertices in a graph such that ai is the number of vertices adjacent to i-th vertex.Degree set is a sorted in increasing order sequence of all distinct values from the degree sequence.It is guaranteed that there exists such a graph that all the conditions hold, and it contains no more than 106 edges.Print the resulting graph.[SOURCE CODE]from sys import stdin\nfrom sys import stdout\n\nn = int(stdin.readline())\nd = [0] + list(map(int, stdin.readline().split()))\ne = []\nfor i in range(1, n+1):\n\tfor u in range(d[i-1]+1, d[i]+1):\n\t\tfor v in range(u+1, d[n-i+1]+2):\n\t\t\te.append([u,v])\nstdout.write(\"{}\\n\".format(len(e)))\nfor ei in e: stdout.write(\"{} {}\\n\".format(ei[0], ei[1]))","tags":["graphs"],"src_uid":"1fa93a236c36f75120af3534d6226fa9"}
{"text_full":"[DESCRIPTION]Bob is an active user of the social network Faithbug. On this network, people are able to engage in a mutual friendship. That is, if $$$a$$$ is a friend of $$$b$$$, then $$$b$$$ is also a friend of $$$a$$$. Each user thus has a non-negative amount of friends.This morning, somebody anonymously sent Bob the following link: graph realization problem and Bob wants to know who that was. In order to do that, he first needs to know how the social network looks like. He investigated the profile of every other person on the network and noted down the number of his friends. However, he neglected to note down the number of his friends. Help him find out how many friends he has. Since there may be many possible answers, print all of them.[SOURCE CODE]def main():\n    n=int(input())\n    a=list(map(int,input().split()))\n    a.sort(reverse=True)\n    mod=sum(a)%2\n    counts=[0]*(n+1)\n    for guy in a:\n        counts[guy]+=1\n    cumcounts=[counts[0]]\n    for i in range(n):\n        cumcounts.append(cumcounts[-1]+counts[i+1])\n    partialsums=[0]\n    curr=0\n    for i in range(n):\n        curr+=(i+1)*counts[i+1]\n        partialsums.append(curr)\n    partialsums.append(0)\n    cumcounts.append(0)\n    sumi=0\n    diffs=[]\n    altdiffs=[]\n    for i in range(n):\n        sumi+=a[i]\n        rhs=i*(i+1)\n        if a[i]>i:\n            rhs+=partialsums[i]+(i+1)*(n-i-1-cumcounts[i])\n        else:\n            rhs+=partialsums[a[i]-1]+a[i]*(n-i-1-cumcounts[a[i]-1])\n        diffs.append(sumi-rhs)\n        \n        rhs2=(i+1)*(i+2)\n        if a[i]>i+1:\n            rhs2+=partialsums[i+1]+(i+2)*(n-i-1-cumcounts[i+1])\n        else:\n            rhs2+=partialsums[a[i]-1]+a[i]*(n-i-1-cumcounts[a[i]-1])\n        altdiffs.append(sumi-rhs2)\n    mini=max(diffs)\n    maxi=-max(altdiffs)\n    mini=max(mini,0)\n    maxi=min(maxi,n)\n    out=\"\"\n    if mini%2!=mod:\n        mini+=1\n    if maxi%2==mod:\n        maxi+=1\n    for guy in range(mini,maxi,2):\n        out+=str(guy)+\" \"\n    if mini>maxi:\n        print(-1)\n    else:\n        print(out)\nmain()","tags":["graphs","math"],"src_uid":"e5ac0312381701a25970dd9a98cda3d4"}
{"text_full":"[DESCRIPTION]You've got string s, consisting of small English letters. Some of the English letters are good, the rest are bad.A substring s[l...r] (1 ≤ l ≤ r ≤ |s|) of string s  =  s1s2...s|s| (where |s| is the length of string s) is string  slsl + 1...sr.The substring s[l...r] is good, if among the letters  sl, sl + 1, ..., sr there are at most k bad ones (look at the sample's explanation to understand it more clear).Your task is to find the number of distinct good substrings of the given string s. Two substrings s[x...y] and s[p...q] are considered distinct if their content is different, i.e. s[x...y] ≠ s[p...q].[SOURCE CODE]s = input()\nL = input()\nk = int(input())\nl=len(s)\ngood = set()\nstring = set()\nLIST = [chr(i) for i in range(97, 123)]\nfor i in range(26):\n    if L[i] == '1':\n        good.add(LIST[i])\nt = [s[i] not in good for i in range(l)]\nend = [0]*l\nsumbad = 0\ni,j=0,0\nwhile i<l:\n    if j<l:\n        sumbad+=t[j]\n    if sumbad>k or j==l:\n        sumbad-=t[i]\n        end[i]=j\n        i+=1\n        if sumbad>k:\n            sumbad-=t[j]\n            continue\n    if j<l:\n        j+=1\nfor i in range(len(s)):\n    t = 0\n    for j in range(i, end[i]):\n        t = (t*29 + ord(s[j])-96)&1152921504606846975\n        string.add(t)\nprint(len(string))","tags":["strings"],"src_uid":"c0998741424cd53de41d31f0bbaef9a2"}
{"text_full":"[DESCRIPTION]Allen is hosting a formal dinner party. $$$2n$$$ people come to the event in $$$n$$$ pairs (couples). After a night of fun, Allen wants to line everyone up for a final picture. The $$$2n$$$ people line up, but Allen doesn't like the ordering. Allen prefers if each pair occupies adjacent positions in the line, as this makes the picture more aesthetic.Help Allen find the minimum number of swaps of adjacent positions he must perform to make it so that each couple occupies adjacent positions in the line.[SOURCE CODE]l = int(input())\na = list(map(int,input().split()))\ncount = 0\ni = 0\nn = 2*l\nwhile (i<n-2):\n    if (a[i]==a[i+1]):\n        i += 2\n        continue\n    j = i+2\n    while (j<n and a[j]!=a[i]):\n        j += 1\n    while (j>i+1):\n        count += 1\n        a[j-1],a[j] = a[j],a[j-1]\n        j -= 1\n    i += 2\nprint(count)","tags":["math"],"src_uid":"194bc63b192a4e24220b36984901fb3b"}
{"text_full":"[DESCRIPTION]One day n cells of some array decided to play the following game. Initially each cell contains a number which is equal to it's ordinal number (starting from 1). Also each cell determined it's favourite number. On it's move i-th cell can exchange it's value with the value of some other j-th cell, if |i - j| = di, where di is a favourite number of i-th cell. Cells make moves in any order, the number of moves is unlimited.The favourite number of each cell will be given to you. You will also be given a permutation of numbers from 1 to n. You are to determine whether the game could move to this state.[SOURCE CODE]n = int(input())\ndata = list(map(int, input().split()))\nspans = list(map(int, input().split()))\n\nconnect = [[False for c in range(n)] for r in range(n)]\nfor p, span in enumerate(spans):\n  for r in [p-span, p+span]:\n    if r >= 0 and r < n:\n      connect[p][r] = connect[r][p] = True\n\ndef visit(data, connect, seen, group, i):\n  if not seen[i]:\n    seen[i] = True\n    group.append((i, data[i]))\n    for j in range(n):\n      if connect[i][j]:\n        visit(data, connect, seen, group, j)\n\nseen = [False for i in range(n)]\nfor i in range(n):\n  group = []\n  visit(data, connect, seen, group, i)\n  group.sort()\n  #print()\n  #print(group)\n  values = sorted([value for (index, value) in group])\n  #print(values)\n  for i, value in enumerate(values):\n    data[group[i][0]] = value\n  #print(data)\n\nif data == list(range(1, n+1)):\n  print('YES')\nelse:\n  print('NO')","tags":["graphs"],"src_uid":"c4b7265ff4332225c0d5617c3233a910"}
{"text_full":"[DESCRIPTION]Eric is the teacher of graph theory class. Today, Eric teaches independent set and edge-induced subgraph.Given a graph $$$G=(V,E)$$$, an independent set is a subset of vertices $$$V' \\subset V$$$ such that for every pair $$$u,v \\in V'$$$, $$$(u,v) \\not \\in E$$$ (i.e. no edge in $$$E$$$ connects two vertices from $$$V'$$$).An edge-induced subgraph consists of a subset of edges $$$E' \\subset E$$$ and all the vertices in the original graph that are incident on at least one edge in the subgraph.Given $$$E' \\subset E$$$, denote $$$G[E']$$$ the edge-induced subgraph such that $$$E'$$$ is the edge set of the subgraph. Here is an illustration of those definitions:  In order to help his students get familiar with those definitions, he leaves the following problem as an exercise:Given a tree $$$G=(V,E)$$$, calculate the sum of $$$w(H)$$$ over all except null edge-induced subgraph $$$H$$$ of $$$G$$$, where $$$w(H)$$$ is the number of independent sets in $$$H$$$. Formally, calculate $$$\\sum \\limits_{\\emptyset \\not= E' \\subset E} w(G[E'])$$$.Show Eric that you are smarter than his students by providing the correct answer as quickly as possible. Note that the answer might be large, you should output the answer modulo $$$998,244,353$$$.[SOURCE CODE]import sys\nrange = xrange\ninput = raw_input\n\nMOD = 998244353\n\ninp = [int(x) for x in sys.stdin.read().split()]; ii = 0\n\nn = inp[ii]; ii += 1\ncoupl = [[] for _ in range(n)]\nfor _ in range(n - 1):\n    u = inp[ii] - 1; ii += 1\n    v = inp[ii] - 1; ii += 1\n    coupl[u].append(v)\n    coupl[v].append(u)\n\nleaf = 0\nwhile len(coupl[leaf]) > 1:\n    leaf += 1\n\nroot = leaf\nbfs = [root]\nfor node in bfs:\n    for nei in coupl[node]:\n        del coupl[nei][coupl[nei].index(node)]\n    bfs += coupl[node]\n\nDP0 = [0]*n\nDP2 = [0]*n\nDP4 = [0]*n\nDP6 = [0]*n\n\nfor node in reversed(bfs):\n    a = 1\n    for child in coupl[node]:\n        fac = (DP2[child] + DP4[child] + DP6[child]) % MOD\n        a = a * fac % MOD \n    DP0[node] = int(a)\n\n    c = 1\n    for child in coupl[node]:\n        fac = (DP4[child] + DP6[child]) % MOD\n        c = c * fac % MOD\n    DP4[node] = int((a - c) % MOD)\n\n    e = 1\n    for child in coupl[node]:\n        fac = (DP0[child] + DP2[child] + DP4[child] + DP6[child]) % MOD\n        e = e * fac % MOD\n\n    DP6[node] = DP2[node] = int(e)\n\nprint (DP4[root] + DP6[root] - 1) % MOD","tags":["trees"],"src_uid":"82c3c6b0190e0e098396bd9e6fb885d1"}
{"text_full":"[DESCRIPTION]Gathering darkness shrouds the woods and the world. The moon sheds its light on the boat and the river.\"To curtain off the moonlight should be hardly possible; the shades present its mellow beauty and restful nature.\" Intonates Mino.\"See? The clouds are coming.\" Kanno gazes into the distance.\"That can't be better,\" Mino turns to Kanno. The sky can be seen as a one-dimensional axis. The moon is at the origin whose coordinate is $$$0$$$.There are $$$n$$$ clouds floating in the sky. Each cloud has the same length $$$l$$$. The $$$i$$$-th initially covers the range of $$$(x_i, x_i + l)$$$ (endpoints excluded). Initially, it moves at a velocity of $$$v_i$$$, which equals either $$$1$$$ or $$$-1$$$.Furthermore, no pair of clouds intersect initially, that is, for all $$$1 \\leq i \\lt j \\leq n$$$, $$$\\lvert x_i - x_j \\rvert \\geq l$$$.With a wind velocity of $$$w$$$, the velocity of the $$$i$$$-th cloud becomes $$$v_i + w$$$. That is, its coordinate increases by $$$v_i + w$$$ during each unit of time. Note that the wind can be strong and clouds can change their direction.You are to help Mino count the number of pairs $$$(i, j)$$$ ($$$i &lt; j$$$), such that with a proper choice of wind velocity $$$w$$$ not exceeding $$$w_\\mathrm{max}$$$ in absolute value (possibly negative and\/or fractional), the $$$i$$$-th and $$$j$$$-th clouds both cover the moon at the same future moment. This $$$w$$$ doesn't need to be the same across different pairs.[SOURCE CODE]def solve(xs, vs, l, wmax):\n    assert wmax >= 1\n    assert l >= 1\n    n = len(xs)\n    assert len(vs) == n >= 1\n    poss = [i for i in xrange(n) if vs[i] == +1]\n    negs = [i for i in xrange(n) if vs[i] == -1]\n    poss = sorted([-xs[i] for i in poss])\n    negs = sorted([xs[i] + l for i in negs])\n    ans = 0\n    for x1 in poss:\n        if wmax == 1 and x1 <= 0: continue\n        lf = max(-x1, (x1 * (1 - wmax)) \/ (wmax + 1))\n        if wmax != 1:\n            lf = max(lf, -x1 * (wmax + 1) \/ (wmax - 1))\n        L = -1\n        R = len(negs)\n        while R - L > 1:\n            M = L + R >> 1\n            if negs[M] <= lf:\n                L = M\n            else:\n                R = M\n        ans += len(negs) - R\n    return ans\nn, l, wmax = map(int, raw_input().split())\nxs = []\nvs = []\nfor i in xrange(n):\n    x, v = map(int, raw_input().split())\n    xs.append(x)\n    vs.append(v)\nprint solve(xs, vs, l, wmax)","tags":["geometry","math"],"src_uid":"8c464cc6c9d012156828f5e3c250ac20"}
{"text_full":"[DESCRIPTION]There is a right triangle with legs of length a and b. Your task is to determine whether it is possible to locate the triangle on the plane in such a way that none of its sides is parallel to the coordinate axes. All the vertices must have integer coordinates. If there exists such a location, you have to output the appropriate coordinates of vertices.[SOURCE CODE]a, b = map(int, input().split())\na, b = min(a, b), max(a, b)\nfor x in range(1, a):\n    if ((a ** 2 - x ** 2) ** 0.5) % 1 < 10 ** -5:\n        y = round((a ** 2 - x ** 2) ** 0.5)\n        if x > 0 and y > 0 and (y * b) % a == 0 and (x * b) % a == 0:\n            print('YES')\n            print(0, 0)\n            print(x, y)\n            print(y * b \/\/ a, -x * b \/\/ a)\n            exit(0)\nprint('NO')","tags":["geometry","math"],"src_uid":"a949ccae523731f601108d4fa919c112"}
{"text_full":"[DESCRIPTION]While Vasya finished eating his piece of pizza, the lesson has already started. For being late for the lesson, the teacher suggested Vasya to solve one interesting problem. Vasya has an array a and integer x. He should find the number of different ordered pairs of indexes (i, j) such that ai ≤ aj and there are exactly k integers y such that ai ≤ y ≤ aj and y is divisible by x.In this problem it is meant that pair (i, j) is equal to (j, i) only if i is equal to j. For example pair (1, 2) is not the same as (2, 1).[SOURCE CODE]import math\nimport bisect\n\n\nn, x, k = map(int, input().split())\na = sorted(list(map(int, input().split())))\nans = 0\n\nfor num in a:\n    l = math.ceil(num\/x)*x + (k-1)*x\n    r = l + x - 1\n    l = num if l < num else l\n    # print(l, r, bisect.bisect_left(a, l), bisect.bisect_right(a, r), bisect.bisect_right(a, r) - bisect.bisect_left(a, l))\n    ans += bisect.bisect_right(a, r) - bisect.bisect_left(a, l)\n\nprint(ans)\n\n\n'''\n7 3 2\n1 3 5 9 11 16 25\n'''\n\n'''\n4 2 0\n5 3 1 7\n'''","tags":["math"],"src_uid":"6fbcc92541705a63666701238778a04a"}
{"text_full":"[DESCRIPTION]Little penguin Polo has got a tree — a non-directed connected acyclic graph, containing n nodes and n - 1 edges. We will consider the tree nodes numbered by integers from 1 to n.Today Polo wonders, how to find the number of pairs of paths that don't have common nodes. More formally, he should find the number of groups of four integers a, b, c and d such that:  1 ≤ a &lt; b ≤ n;  1 ≤ c &lt; d ≤ n;  there's no such node that lies on both the shortest path from node a to node b and from node c to node d. The shortest path betweem two nodes is the path that is shortest in the number of edges.Help Polo solve this problem.[SOURCE CODE]n=input()\ne=[[] for i in range(0,n+10)]\nsz,f=[0]*(n+10),[0]*(n+10)\ns=[]\nans=n*n*(n-1)*(n-1)\/4\nfor i in xrange(1,n):\n\tu,v=map(int,raw_input().split())\n\te[u].append(v)\n\te[v].append(u)\nq=[1]\nfor i in xrange(0,n):\n\tu=q[i]\n\tfor v in e[u]:\n\t\tif (v==f[u]): continue\n\t\tq.append(v)\n\t\tf[v]=u\nfor i in reversed(xrange(0,n)):\n\tu=q[i]\n\tsz[u]+=1\n\tsz[f[u]]+=sz[u]\n\tsu=sz[u]*(sz[u]-1)\/2-sum(sz[v]*(sz[v]-1)\/2 for v in e[u] if (v!=f[u]))\n\tans-=su*(su+2*(n-sz[u])*sz[u])\nprint ans","tags":["trees"],"src_uid":"a1631f068c8da218243a9ab0aced4f16"}
{"text_full":"[DESCRIPTION]Your math teacher gave you the following problem:There are $$$n$$$ segments on the $$$x$$$-axis, $$$[l_1; r_1], [l_2; r_2], \\ldots, [l_n; r_n]$$$. The segment $$$[l; r]$$$ includes the bounds, i.e. it is a set of such $$$x$$$ that $$$l \\le x \\le r$$$. The length of the segment $$$[l; r]$$$ is equal to $$$r - l$$$.Two segments $$$[a; b]$$$ and $$$[c; d]$$$ have a common point (intersect) if there exists $$$x$$$ that $$$a \\leq x \\leq b$$$ and $$$c \\leq x \\leq d$$$. For example, $$$[2; 5]$$$ and $$$[3; 10]$$$ have a common point, but $$$[5; 6]$$$ and $$$[1; 4]$$$ don't have.You should add one segment, which has at least one common point with each of the given segments and as short as possible (i.e. has minimal length). The required segment can degenerate to be a point (i.e a segment with length zero). The added segment may or may not be among the given $$$n$$$ segments.In other words, you need to find a segment $$$[a; b]$$$, such that $$$[a; b]$$$ and every $$$[l_i; r_i]$$$ have a common point for each $$$i$$$, and $$$b-a$$$ is minimal.[SOURCE CODE]t = int(input())\naa = []\nbb = []\nfor i in range(t):\n    n = int(input())\n\n    max = 0\n    min = 10**10\n    for j in range(n):\n        d = list(map(int, input().split(' ')))\n        if d[1] < min:\n            min = d[1]\n        if d[0] > max:\n            max = d[0]\n\n\n    print(max-min if max-min >= 0 else 0)","tags":["math"],"src_uid":"f8a8bda80a75ed430465605deff249ca"}
{"text_full":"[DESCRIPTION]Fangy the little walrus, as all the modern walruses, loves to communicate via text messaging. One day he faced the following problem: When he sends large texts, they are split into parts each containing n characters (which is the size of one text message). Thus, whole sentences and words get split!Fangy did not like it, so he faced the task of breaking the text into minimal messages on his own so that no sentence were broken into pieces when it is sent and the number of text messages to be sent would be minimal. If two consecutive sentences are in different messages, the space between them can be ignored (Fangy does not write this space).The little walrus's text looks in the following manner: TEXT ::= SENTENCE | SENTENCE SPACE TEXTSENTENCE ::= WORD SPACE SENTENCE | WORD ENDEND ::= {'.', '?', '!'}WORD ::= LETTER | LETTER WORDLETTER ::= {'a'..'z', 'A'..'Z'}SPACE ::= ' 'SPACE stands for the symbol of a space.So, how many messages did Fangy send?[SOURCE CODE]n = int(raw_input())\na = map(len, (\" \" + raw_input()).replace('?', '.').replace('!', '.')[:-1].split('.'))\nres = 0\nt = -1\nfor i in a:\n    if i > n:\n        print \"Impossible\"\n        exit()\n    if t + i + 1 <= n:\n        t += i + 1\n    else:\n        res += 1\n        t = i\nif t != 0:\n    res += 1\nprint res","tags":["strings"],"src_uid":"12b64f77fc9dd44a7e0287ff0a716a6a"}
{"text_full":"[DESCRIPTION]Alexey, a merry Berland entrant, got sick of the gray reality and he zealously wants to go to university. There are a lot of universities nowadays, so Alexey is getting lost in the diversity — he has not yet decided what profession he wants to get. At school, he had bad grades in all subjects, and it's only thanks to wealthy parents that he was able to obtain the graduation certificate.The situation is complicated by the fact that each high education institution has the determined amount of voluntary donations, paid by the new students for admission — ni berubleys. He cannot pay more than ni, because then the difference between the paid amount and ni can be regarded as a bribe!Each rector is wearing the distinctive uniform of his university. Therefore, the uniform's pockets cannot contain coins of denomination more than ri. The rector also does not carry coins of denomination less than li in his pocket — because if everyone pays him with so small coins, they gather a lot of weight and the pocket tears. Therefore, a donation can be paid only by coins of denomination x berubleys, where li ≤ x ≤ ri (Berland uses coins of any positive integer denomination). Alexey can use the coins of different denominations and he can use the coins of the same denomination any number of times. When Alexey was first confronted with such orders, he was puzzled because it turned out that not all universities can accept him! Alexey is very afraid of going into the army (even though he had long wanted to get the green uniform, but his dad says that the army bullies will beat his son and he cannot pay to ensure the boy's safety). So, Alexey wants to know for sure which universities he can enter so that he could quickly choose his alma mater.Thanks to the parents, Alexey is not limited in money and we can assume that he has an unlimited number of coins of each type.In other words, you are given t requests, each of them contains numbers ni, li, ri. For each query you need to answer, whether it is possible to gather the sum of exactly ni berubleys using only coins with an integer denomination from li to ri berubleys. You can use coins of different denominations. Coins of each denomination can be used any number of times.[SOURCE CODE]def possible(numbers):\n        if int(numbers[0])\/\/int(numbers[1])!=0 and int(numbers[0])%int(numbers[1])\/\/(int(numbers[0])\/\/int(numbers[1]))<=int(numbers[2])-int(numbers[1]) and int(numbers[0])%int(numbers[1])%int(numbers[0])\/\/int(numbers[1])+int(numbers[0])%int(numbers[1])%(int(numbers[0])\/\/int(numbers[1]))<=(int(numbers[2])-int(numbers[1]))*(int(numbers[0])\/\/int(numbers[1])-int(numbers[0])\/\/int(numbers[2])):\n            return 'Yes'\n        return 'No'\nfor i in range(0,int(input())):\n    numbers=input().split(' ')\n    if i == -1 and int(numbers[0])!=2 and int(numbers[0])!=912247143:\n        print(numbers)\n    print(possible(numbers))","tags":["math"],"src_uid":"287505698b6c850a768ee35d2e37753e"}
{"text_full":"[DESCRIPTION]The determinant of a matrix 2 × 2 is defined as follows:A matrix is called degenerate if its determinant is equal to zero. The norm ||A|| of a matrix A is defined as a maximum of absolute values of its elements.You are given a matrix . Consider any degenerate matrix B such that norm ||A - B|| is minimum possible. Determine ||A - B||.[SOURCE CODE]from decimal import *\nimport sys\ngetcontext().prec = 22\na,b = map(int,sys.stdin.readline().split())\nc, d = map(int,sys.stdin.readline().split())\na = Decimal(a)\nb = Decimal(b)\nc = Decimal(c)\nd = Decimal(d)\nl = Decimal(0)\nr = Decimal(1000000001)\neps = Decimal(0.00000000001)\nbinn = Decimal(2)\nwhile(r - l >= eps):\n    mid = (l + r) \/ binn\n    as1 = (a - mid) * (d - mid);\n    as2 = (a - mid) * (d + mid);\n    as3 = (a + mid) * (d - mid);\n    as4 = (a + mid) * (d + mid);\n    mx1 = max(as1, max(as2, max(as3, as4)));\n    mn1 = min(as1, min(as2, min(as3, as4)));\n    as1 = (b - mid) * (c - mid);\n    as2 = (b - mid) * (c + mid);\n    as3 = (b + mid) * (c - mid);\n    as4 = (b + mid) * (c + mid);\n    mx2 = max(as1, max(as2, max(as3, as4)));\n    mn2 = min(as1, min(as2, min(as3, as4)));\n    if (mx1 < mn2 or mn1 > mx2):\n        l = mid\n    else :\n        r = mid\nprint Decimal(l)","tags":["math"],"src_uid":"b779946fe86b1a2a4449bc85ff887367"}
{"text_full":"[DESCRIPTION]You are given a sequence a1, a2, ..., an consisting of different integers. It is required to split this sequence into the maximum number of subsequences such that after sorting integers in each of them in increasing order, the total sequence also will be sorted in increasing order.Sorting integers in a subsequence is a process such that the numbers included in a subsequence are ordered in increasing order, and the numbers which are not included in a subsequence don't change their places.Every element of the sequence must appear in exactly one subsequence.[SOURCE CODE]def binSearch(arr, el):\n    if len(arr) == 0: return -1\n    l, p = 0, len(arr)-1\n    while l != p:\n        s = (l+p) \/\/ 2\n        if arr[s] < el:\n            l = s + 1\n        else:\n            p = s\n    return l if arr[l] == el else -1\n\nn = int(input())\na = [int(i) for i in input().split()]\ns = sorted(a)\n\nsubsList = []\nvisited = [False for i in range(n)]\nfor i in range(n):\n    ind = i\n    newSub = False\n    while not visited[ind]:\n        if not newSub:\n            subsList.append([])\n        newSub = True\n        visited[ind] = True\n        subsList[-1].append(str(ind+1))\n        ind = binSearch(s, a[ind])\n    \nout = str(len(subsList)) + \"\\n\"\nfor lineNr in range(len(subsList)-1):\n    \n    out += str(len(subsList[lineNr])) + \" \"\n    out += \" \".join(subsList[lineNr]) + \"\\n\"\nout += str(len(subsList[-1])) + \" \"    \nout += \" \".join(subsList[-1])\nprint(out)","tags":["math"],"src_uid":"159365b2f037647fbaa656905e6f5252"}
{"text_full":"[DESCRIPTION]An undirected graph is called k-regular, if the degrees of all its vertices are equal k. An edge of a connected graph is called a bridge, if after removing it the graph is being split into two connected components.Build a connected undirected k-regular graph containing at least one bridge, or else state that such graph doesn't exist.[SOURCE CODE]k = int(input())\nif k % 2 == 0:\n    print('NO')\nelse:\n    print('YES')\n    reb = [[1, 2]]\n    for v in range(3, k + 2):\n        reb.append([1, v])\n        reb.append([v, k + 2 * v - 4])\n        reb.append([v, k + 2 * v - 3])\n        reb.append([k + 2 * v - 4, k + 2 * v - 3])\n        for u in range(v + 1, k + 2):\n            if v + u != k + 4:\n                reb.append([v, u])\n            reb.append([k + 2 * v - 4, k + 2 * u - 4])\n            reb.append([k + 2 * v - 3, k + 2 * u - 3])\n    for v in range(3 * k, 4 * k - 1):\n        reb.append([2, v])\n        reb.append([v, 2 * v - 2 * k - 1])\n        reb.append([v, 2 * v - 2 * k])\n        reb.append([2 * v - 2 * k, 2 * v - 2 * k - 1])\n        for u in range(v + 1, 4 * k - 1):\n            if v + u != 7 * k - 2:\n                reb.append([v, u])\n            reb.append([2 * v - 2 * k, 2 * u - 2 * k])\n            reb.append([2 * v - 2 * k - 1, 2 * u - 2 * k - 1])\n    print(2 * (3 * k - 2), k * (3 * k - 2))\n    for a, b in reb:\n        print(a, b)","tags":["graphs"],"src_uid":"1e061d8c4bff217047ddc58e88be0c3f"}
{"text_full":"[DESCRIPTION]An IPv6-address is a 128-bit number. For convenience, this number is recorded in blocks of 16 bits in hexadecimal record, the blocks are separated by colons — 8 blocks in total, each block has four hexadecimal digits. Here is an example of the correct record of a IPv6 address: \"0124:5678:90ab:cdef:0124:5678:90ab:cdef\". We'll call such format of recording an IPv6-address full.Besides the full record of an IPv6 address there is a short record format. The record of an IPv6 address can be shortened by removing one or more leading zeroes at the beginning of each block. However, each block should contain at least one digit in the short format. For example, the leading zeroes can be removed like that: \"a56f:00d3:0000:0124:0001:f19a:1000:0000\"  →  \"a56f:d3:0:0124:01:f19a:1000:00\". There are more ways to shorten zeroes in this IPv6 address.Some IPv6 addresses contain long sequences of zeroes. Continuous sequences of 16-bit zero blocks can be shortened to \"::\". A sequence can consist of one or several consecutive blocks, with all 16 bits equal to 0. You can see examples of zero block shortenings below:  \"a56f:00d3:0000:0124:0001:0000:0000:0000\"  →  \"a56f:00d3:0000:0124:0001::\";  \"a56f:0000:0000:0124:0001:0000:1234:0ff0\"  →  \"a56f::0124:0001:0000:1234:0ff0\";  \"a56f:0000:0000:0000:0001:0000:1234:0ff0\"  →  \"a56f:0000::0000:0001:0000:1234:0ff0\";  \"a56f:00d3:0000:0124:0001:0000:0000:0000\"  →  \"a56f:00d3:0000:0124:0001::0000\";  \"0000:0000:0000:0000:0000:0000:0000:0000\"  →  \"::\". It is not allowed to shorten zero blocks in the address more than once. This means that the short record can't contain the sequence of characters \"::\" more than once. Otherwise, it will sometimes be impossible to determine the number of zero blocks, each represented by a double colon.The format of the record of the IPv6 address after removing the leading zeroes and shortening the zero blocks is called short.You've got several short records of IPv6 addresses. Restore their full record.[SOURCE CODE]def do(t):\n    ret = \"\"\n    for item in t:\n        ret += \"0\"*(4-len(item)) + item + \":\"\n    return ret\n\nn = int(raw_input())    \nfor i in range(n):\n    ip6 = str(raw_input()).split(\"::\")\n    if len(ip6) == 2:\n        prefix,postfix = ip6[0].split(\":\"),ip6[1].split(\":\")\n        res = do(prefix) +\"0000:\"*(8-len(prefix) - len(postfix))+ do(postfix)\n        print(res[:-1])\n    else:\n        print(do(ip6[0].split(\":\"))[:-1])","tags":["strings"],"src_uid":"20f69ee5f04c8cbb769be3ab646031ab"}
{"text_full":"[DESCRIPTION]A number of skyscrapers have been built in a line. The number of skyscrapers was chosen uniformly at random between 2 and 314! (314 factorial, a very large number). The height of each skyscraper was chosen randomly and independently, with height i having probability 2 - i for all positive integers i. The floors of a skyscraper with height i are numbered 0 through i - 1.To speed up transit times, a number of zip lines were installed between skyscrapers. Specifically, there is a zip line connecting the i-th floor of one skyscraper with the i-th floor of another skyscraper if and only if there are no skyscrapers between them that have an i-th floor.Alice and Bob decide to count the number of skyscrapers.Alice is thorough, and wants to know exactly how many skyscrapers there are. She begins at the leftmost skyscraper, with a counter at 1. She then moves to the right, one skyscraper at a time, adding 1 to her counter each time she moves. She continues until she reaches the rightmost skyscraper.Bob is impatient, and wants to finish as fast as possible. He begins at the leftmost skyscraper, with a counter at 1. He moves from building to building using zip lines. At each stage Bob uses the highest available zip line to the right, but ignores floors with a height greater than h due to fear of heights. When Bob uses a zip line, he travels too fast to count how many skyscrapers he passed. Instead, he just adds 2i to his counter, where i is the number of the floor he's currently on. He continues until he reaches the rightmost skyscraper.Consider the following example. There are 6 buildings, with heights 1, 4, 3, 4, 1, 2 from left to right, and h = 2. Alice begins with her counter at 1 and then adds 1 five times for a result of 6. Bob begins with his counter at 1, then he adds 1, 4, 4, and 2, in order, for a result of 12. Note that Bob ignores the highest zip line because of his fear of heights (h = 2).  Bob's counter is at the top of the image, and Alice's counter at the bottom. All zip lines are shown. Bob's path is shown by the green dashed line and Alice's by the pink dashed line. The floors of the skyscrapers are numbered, and the zip lines Bob uses are marked with the amount he adds to his counter.When Alice and Bob reach the right-most skyscraper, they compare counters. You will be given either the value of Alice's counter or the value of Bob's counter, and must compute the expected value of the other's counter.[SOURCE CODE]s=raw_input()\nn,h=map(int,raw_input().split())\nif s == \"Bob\": print n;exit()\n\nans=n\nti=1.0\nfor i in xrange(1,h+1):\n    ti *= 0.5\n    if ti < 0.1**50: break\n    tj = 1.0\/(1.0-ti)\n    for j in xrange(1,n+1):\n        tj *= 1.0-ti\n        ans += (n-j)*tj*(ti-0.5*ti*(1.0+(j-1.0)*ti\/(1.0-ti)))\n\nprint ans","tags":["probabilities","math"],"src_uid":"ca417ff967dcd4594de66ade1a06acf0"}
{"text_full":"[DESCRIPTION]After getting kicked out of her reporting job for not knowing the alphabet, Bessie has decided to attend school at the Fillet and Eggs Eater Academy. She has been making good progress with her studies and now knows the first k English letters.Each morning, Bessie travels to school along a sidewalk consisting of m + n tiles. In order to help Bessie review, Mr. Moozing has labeled each of the first m sidewalk tiles with one of the first k lowercase English letters, spelling out a string t. Mr. Moozing, impressed by Bessie's extensive knowledge of farm animals, plans to let her finish labeling the last n tiles of the sidewalk by herself.Consider the resulting string s (|s| = m + n) consisting of letters labeled on tiles in order from home to school. For any sequence of indices p1 &lt; p2 &lt; ... &lt; pq we can define subsequence of the string s as string sp1sp2... spq. Two subsequences are considered to be distinct if they differ as strings. Bessie wants to label the remaining part of the sidewalk such that the number of distinct subsequences of tiles is maximum possible. However, since Bessie hasn't even finished learning the alphabet, she needs your help!Note that empty subsequence also counts.[SOURCE CODE]#\n# http:\/\/codeforces.com\/problemset\/problem\/655\/E\n\nMOD = 10 ** 9 + 7\n\n\ndef read_ints():\n    return map(int, raw_input().split())\n\nN, K = read_ints()\ncounts, indexes = [0] * K, [-1] * K\n\ncount = 1\nfor i, c in enumerate(raw_input()):\n    c = ord(c) - ord('a')\n    counts[c], count, indexes[c] = count, (2 * count - counts[c]) % MOD, i\n\ncounts = [counts[i] for i in sorted(xrange(K), key=lambda _: indexes[_])]\n\nfor i in xrange(N):\n    counts[i % K], count = count, (2 * count - counts[i % K]) % MOD\n\nprint count","tags":["strings"],"src_uid":"13574507efa5089f3420cf002c3f8077"}
{"text_full":"[DESCRIPTION]One beautiful day Vasily the bear painted 2m circles of the same radius R on a coordinate plane. Circles with numbers from 1 to m had centers at points (2R - R, 0), (4R - R, 0), ..., (2Rm - R, 0), respectively. Circles with numbers from m + 1 to 2m had centers at points (2R - R, 2R), (4R - R, 2R), ..., (2Rm - R, 2R), respectively. Naturally, the bear painted the circles for a simple experiment with a fly. The experiment continued for m2 days. Each day of the experiment got its own unique number from 0 to m2 - 1, inclusive. On the day number i the following things happened:   The fly arrived at the coordinate plane at the center of the circle with number  ( is the result of dividing number x by number y, rounded down to an integer).  The fly went along the coordinate plane to the center of the circle number  ( is the remainder after dividing number x by number y). The bear noticed that the fly went from the center of circle v to the center of circle u along the shortest path with all points lying on the border or inside at least one of the 2m circles. After the fly reached the center of circle u, it flew away in an unknown direction. Help Vasily, count the average distance the fly went along the coordinate plane during each of these m2 days.[SOURCE CODE]m,R=map(int, input().split())\nprint((2*m\/3-2+22\/m\/3-4\/m\/m+2**.5*(2-4\/m+2\/m\/m))*R)","tags":["math"],"src_uid":"f827ea399e6b801c0392eac53710d950"}
{"text_full":"[DESCRIPTION]Sagheer is working at a kindergarten. There are n children and m different toys. These children use well-defined protocols for playing with the toys:  Each child has a lovely set of toys that he loves to play with. He requests the toys one after another at distinct moments of time. A child starts playing if and only if he is granted all the toys in his lovely set. If a child starts playing, then sooner or later he gives the toys back. No child keeps the toys forever. Children request toys at distinct moments of time. No two children request a toy at the same time. If a child is granted a toy, he never gives it back until he finishes playing with his lovely set. If a child is not granted a toy, he waits until he is granted this toy. He can't request another toy while waiting. If two children are waiting for the same toy, then the child who requested it first will take the toy first.Children don't like to play with each other. That's why they never share toys. When a child requests a toy, then granting the toy to this child depends on whether the toy is free or not. If the toy is free, Sagheer will give it to the child. Otherwise, the child has to wait for it and can't request another toy.Children are smart and can detect if they have to wait forever before they get the toys they want. In such case they start crying. In other words, a crying set is a set of children in which each child is waiting for a toy that is kept by another child in the set.Now, we have reached a scenario where all the children made all the requests for their lovely sets, except for one child x that still has one last request for his lovely set. Some children are playing while others are waiting for a toy, but no child is crying, and no one has yet finished playing. If the child x is currently waiting for some toy, he makes his last request just after getting that toy. Otherwise, he makes the request right away. When child x will make his last request, how many children will start crying?You will be given the scenario and q independent queries. Each query will be of the form x y meaning that the last request of the child x is for the toy y. Your task is to help Sagheer find the size of the maximal crying set when child x makes his last request.[SOURCE CODE]from sys import stdin\nfrom sys import stdout\n\nn, m, k, q = map(int, stdin.readline().split())\nd = [None for i in range(m)]\nroots = set(range(n))\nmatrix = [[] for i in range(n)]\nfor i in range(k):\n    x, y = map(int, stdin.readline().split())\n    if d[y - 1] is None:\n        d[y - 1] = x - 1\n    else:\n        matrix[d[y - 1]].append(x - 1)\n        roots.discard(x - 1)\n        d[y - 1] = x - 1\nlocation = [None for i in range(n)]\ncomp_of_conn = []\ngraph = [matrix[i][:] for i in range(n)]\nfor i in roots:\n    stack = []\n    time = 1\n    queue = [[i, time]]\n    while queue:\n        j = queue[-1]\n        time += 1\n        if len(graph[j[0]]) == 0:\n            stack.append(queue.pop() + [time])\n        else:\n            queue.append([graph[j[0]].pop(), time])\n    stack.reverse()\n    if len(stack) > 1:\n        for j in range(len(stack)):\n            location[stack[j][0]] = [len(comp_of_conn), j]\n        for j in range(len(stack) - 1, -1, -1):\n            app = 0\n            for u in matrix[stack[j][0]]:\n                app += stack[location[u][1]][3]\n            stack[j].append(app + 1)\n        comp_of_conn.append(stack)\nfor i in range(q):\n    x, y = map(int, stdin.readline().split())\n    x -= 1\n    y = d[y - 1]\n    if y is None:\n        stdout.write('0\\n')\n    elif location[x] is not None and location[y] is not None and location[x][0] == location[y][0]:\n        c = location[x][0]\n        ind_x = location[x][1]\n        ind_y = location[y][1]\n        if comp_of_conn[c][ind_x][1] < comp_of_conn[c][ind_y][1] and comp_of_conn[c][ind_x][2] > comp_of_conn[c][ind_y][\n            2]:\n            stdout.write(str(comp_of_conn[c][ind_x][3]) + '\\n')\n        else:\n            stdout.write('0\\n')\n    else:\n        stdout.write('0\\n')","tags":["trees","graphs"],"src_uid":"d7ffedb180378b3ab70e5f05c79545f5"}
{"text_full":"[DESCRIPTION]There are some websites that are accessible through several different addresses. For example, for a long time Codeforces was accessible with two hostnames codeforces.com and codeforces.ru.You are given a list of page addresses being queried. For simplicity we consider all addresses to have the form http:\/\/&lt;hostname&gt;[\/&lt;path&gt;], where:  &lt;hostname&gt; — server name (consists of words and maybe some dots separating them),  \/&lt;path&gt; — optional part, where &lt;path&gt; consists of words separated by slashes. We consider two &lt;hostname&gt; to correspond to one website if for each query to the first &lt;hostname&gt; there will be exactly the same query to the second one and vice versa — for each query to the second &lt;hostname&gt; there will be the same query to the first one. Take a look at the samples for further clarifications.Your goal is to determine the groups of server names that correspond to one website. Ignore groups consisting of the only server name.Please note, that according to the above definition queries http:\/\/&lt;hostname&gt; and http:\/\/&lt;hostname&gt;\/ are different.[SOURCE CODE]n = int(raw_input())\ndomain_queries = {}\nfor i in range(n):\n    address = raw_input().strip()[7:]\n    if '\/' not in address:\n        domain = address\n        query = ''\n    else:\n        pos = address.index('\/')\n        domain = address[:pos]\n        query = address[pos:]\n    domain_queries.setdefault(domain, set()).add(query)\ndomain_signatures = {}\nfor domain, queries in domain_queries.items():\n    domain_signatures[domain] = ','.join(sorted(queries))\nsignature_domains = {}\nfor domain, signature in domain_signatures.items():\n    signature_domains.setdefault(signature, []).append('http:\/\/' + domain)\nlines = []\nfor signature, domains in signature_domains.items():\n    if len(domains) == 1:\n        continue\n    lines.append(' '.join(domains))\nprint(len(lines))\nif len(lines) > 0:\n    print('\\n'.join(lines))","tags":["strings"],"src_uid":"9b35f7df9e21162858a8fac8ee2837a4"}
{"text_full":"[DESCRIPTION]You have a simple and connected undirected graph consisting of $$$n$$$ nodes and $$$m$$$ edges.Consider any way to pair some subset of these $$$n$$$ nodes such that no node is present in more than one pair. This pairing is valid if for every pair of pairs, the induced subgraph containing all $$$4$$$ nodes, two from each pair, has at most $$$2$$$ edges (out of the $$$6$$$ possible edges). More formally, for any two pairs, $$$(a,b)$$$ and $$$(c,d)$$$, the induced subgraph with nodes $$$\\{a,b,c,d\\}$$$ should have at most $$$2$$$ edges. Please note that the subgraph induced by a set of nodes contains nodes only from this set and edges which have both of its end points in this set.Now, do one of the following:   Find a simple path consisting of at least $$$\\lceil \\frac{n}{2} \\rceil$$$ nodes. Here, a path is called simple if it does not visit any node multiple times.  Find a valid pairing in which at least $$$\\lceil \\frac{n}{2} \\rceil$$$ nodes are paired. It can be shown that it is possible to find at least one of the two in every graph satisfying constraints from the statement.[SOURCE CODE]# Fast IO (only use in integer input)\n\nimport os,io\ninput=io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\n\nt = int(input())\nfor _ in range(t):\n    n,m = map(int,input().split())\n    connectionList = []\n    for _ in range(n):\n        connectionList.append([])\n    for _ in range(m):\n        u,v = map(int,input().split())\n        connectionList[u-1].append(v-1)\n        connectionList[v-1].append(u-1)\n    DFSLevel = [-1] * n\n    DFSParent = [-1] * n\n    vertexStack = []\n    vertexStack.append((0,1,-1)) # vertex depth and parent\n    while vertexStack:\n        vertex,depth,parent = vertexStack.pop()\n        if DFSLevel[vertex] != -1:\n            continue\n        DFSLevel[vertex] = depth\n        DFSParent[vertex] = parent\n        for nextV in connectionList[vertex]:\n            if DFSLevel[nextV] == -1:\n                vertexStack.append((nextV,depth + 1,vertex))\n    if max(DFSLevel) >= n\/\/2 + n % 2:\n        for i in range(n):\n            if DFSLevel[i] >= (n\/\/2 + n%2):\n                break\n        longPath = [str(i + 1)]\n        while DFSParent[i] != -1:\n            longPath.append(str(DFSParent[i] + 1))\n            i = DFSParent[i]\n        print(\"PATH\")\n        print(len(longPath))\n        print(\" \".join(longPath))\n    else:\n        levelWithVertex = list(enumerate(DFSLevel))\n        levelWithVertex.sort(key = lambda x: x[1])\n        i = 0\n        pair = []\n        while i < len(levelWithVertex) - 1:\n            if levelWithVertex[i][1] == levelWithVertex[i + 1][1]:\n                pair.append([levelWithVertex[i][0],levelWithVertex[i + 1][0]])\n                i += 2\n            else:\n                i += 1\n        print(\"PAIRING\")\n        print(len(pair))\n        for elem in pair:\n            print(str(elem[0] + 1)+\" \"+str(elem[1] + 1))","tags":["graphs","trees"],"src_uid":"378f944b6839376dc71d85059d8efd2f"}
{"text_full":"[DESCRIPTION]You are given a rooted tree with n vertices. In each leaf vertex there's a single integer — the number of apples in this vertex. The weight of a subtree is the sum of all numbers in this subtree leaves. For instance, the weight of a subtree that corresponds to some leaf is the number written in the leaf.A tree is balanced if for every vertex v of the tree all its subtrees, corresponding to the children of vertex v, are of equal weight. Count the minimum number of apples that you need to remove from the tree (specifically, from some of its leaves) in order to make the tree balanced. Notice that you can always achieve the goal by just removing all apples.[SOURCE CODE]def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a \/\/ gcd(a, b) * b\n\ndef cal((f1, k1), (f2, k2)):\n    if f1 > f2:\n        f1, k1, f2, k2 = f2, k2, f1, k1\n    A = (f1 - f2) % k2\n    B = 0\n    x1 = 0\n    k11 = k1 % k2\n    k1x1 = 0\n    while B != A and k1x1 <= f1:\n        if B < A:\n            dx1 = (A - B) \/\/ k11\n        else:\n            dx1 = (A + k2 - B) \/\/ k11\n        dx1 = max(dx1, 1)\n        B = (B + k11 * dx1) % k2\n        x1 += dx1\n        k1x1 += k1 * dx1\n    f = f1 - k1x1\n    if f <= 0:\n        return (0, 1)\n    k = lcm(k1, k2)\n    return (f, k)\n\ndef cals(fks):\n    fk0 = None\n    for fk in fks:\n        if fk0 is None:\n            fk0 = fk\n        else:\n            # print fk, fk0\n            fk0 = cal(fk0, fk)\n        if fk0[0] == 0:\n            return fk0\n    return fk0\n\ndef solve():\n    n = int(raw_input())\n    a = map(int, raw_input().split())\n    chs = [[] for i in xrange(n)]\n    for i in xrange(n-1):\n        u, v = map(int, raw_input().split())\n        u, v = u - 1, v - 1\n        chs[u].append(v)\n        chs[v].append(u)\n\n    p = []\n    stk = [0]\n    vis = {0}\n    chs1 = [[] for i in xrange(n)]\n    while stk:\n        u = stk.pop()\n        p.append(u)\n        for v in chs[u]:\n            if not v in vis:\n                stk.append(v)\n                chs1[u].append(v)\n                vis.add(v)\n    chs = chs1\n    p.reverse()\n\n    ws = [0] * n\n    for u in p:\n        ws[u] = a[u] + sum(ws[v] for v in chs[u])\n\n    fks = [None] * n\n    for u in p:\n        if not chs[u]:\n            fks[u] = (a[u], 1)\n        else:\n            f, k = cals(fks[v] for v in chs[u])\n            nc = len(chs[u])\n            fks[u] = (a[u] + f * nc, k * nc)\n    # print chs\n    # print zip(a, fks)\n    return ws[0] - fks[0][0]\n\nprint solve()","tags":["number theory","trees"],"src_uid":"db1c28e9ac6251353fbad8730f4705ea"}
{"text_full":"[DESCRIPTION]Recently Irina arrived to one of the most famous cities of Berland — the Berlatov city. There are n showplaces in the city, numbered from 1 to n, and some of them are connected by one-directional roads. The roads in Berlatov are designed in a way such that there are no cyclic routes between showplaces.Initially Irina stands at the showplace 1, and the endpoint of her journey is the showplace n. Naturally, Irina wants to visit as much showplaces as she can during her journey. However, Irina's stay in Berlatov is limited and she can't be there for more than T time units.Help Irina determine how many showplaces she may visit during her journey from showplace 1 to showplace n within a time not exceeding T. It is guaranteed that there is at least one route from showplace 1 to showplace n such that Irina will spend no more than T time units passing it.[SOURCE CODE]from sys import stdin, stdout\n\n# LinkedList.py\nclass LLNode:\n    def __init__(self, value = None, nextNode = None):\n        self.value, self.nextNode = value, nextNode\n\nclass LinkedList:\n    def __init__(self, rootNode = None):\n        self.rootNode = rootNode\n\n    def FindBestPath(self, wayTime):\n        cNode = self.rootNode\n        while cNode != None:\n            if cNode.value.wayTime <= wayTime:\n                break\n            cNode = cNode.nextNode\n        return cNode\n\n    def FindMaxPreNode(self, path, startNode): # by wayLen\n        if path.wayLen > startNode.value.wayLen:\n            return None\n        preNode = startNode\n        while preNode.nextNode != None:\n            if path.wayLen > preNode.nextNode.value.wayLen:\n                break\n            preNode = preNode.nextNode\n        return preNode\n    \n    def FindMaxNextNode(self, path, startNode): # by wayTime\n        cNode = startNode\n        while cNode != None:\n            if cNode.value.wayTime < path.wayTime:\n                break\n            cNode = cNode.nextNode\n        return cNode\n\n    def RawInsert(self, path):\n        if path == None:\n            return\n        \n        if self.rootNode == None:\n            self.rootNode = LLNode(path, None)\n            return\n        \n        preNode = self.FindMaxPreNode(path, self.rootNode)\n        preNode.nextNode = LLNode(path, None)\n\n    def Insert(self, path):\n        if path == None:\n            return False\n        \n        if self.rootNode == None:\n            self.rootNode = LLNode(path, None)\n            return True\n        \n        preNode = self.FindMaxPreNode(path, self.rootNode)\n        node = None\n        if preNode == None:\n            node = LLNode(path, self.rootNode)\n            self.rootNode = node\n        else:\n            if path.wayTime < preNode.value.wayTime:\n                if path.wayLen == preNode.value.wayLen:\n                    preNode.value = path\n                    node = preNode\n                else:\n                    node = LLNode(path, preNode.nextNode)\n                    preNode.nextNode = node\n            else:\n                return False\n        \n        if node.nextNode != None: # delete useless paths\n            nextNode = self.FindMaxNextNode(path, node.nextNode)\n            node.nextNode = nextNode\n        \n        return True\n\n# Main.py\n\ncities = []\nmemo = []\nT = 0\n\nclass Node:\n    def __init__(self, number, wayLen, wayTime, preNode):\n        self.number, self.wayLen, self.wayTime, self.preNode = number, wayLen, wayTime, preNode\n\nclass Path:\n    def __init__(self, wayLen, wayTime, nextNode):\n        self.wayLen, self.wayTime, self.nextNode = wayLen, wayTime, nextNode \n\ndef MemoizeWay2(endNode):\n    global memo, T\n    cNode = endNode\n    while cNode.preNode != None: \n        cLLNode = memo[cNode.number].rootNode\n        while cLLNode != None:\n            tailLen = cLLNode.value.wayLen + 1\n            tailTime = cLLNode.value.wayTime + cities[cNode.preNode.number][cNode.number]\n            memo[cNode.preNode.number].Insert(Path(tailLen, tailTime, cNode.number))\n            cLLNode = cLLNode.nextNode\n        cNode = cNode.preNode\n\ndef MemoizeWay(endNode, tailLen, tailTime):\n    global memo\n    cNode = endNode\n    while cNode.preNode != None:\n        tailLen += 1\n        tailTime += cities[cNode.preNode.number][cNode.number]\n        b = memo[cNode.preNode.number].Insert(Path(tailLen, tailTime, cNode.number))\n        if not b:\n            break\n        cNode = cNode.preNode\n        \n \ndef main():\n    global T, cities\n    n, m, T = [int(s) for s in stdin.readline().split()]\n    cities = [None] * (n+1)\n    for i in range(m):\n        u, v, t = [int(s) for s in stdin.readline().split()]\n        if cities[u] == None:\n            cities[u] = {}\n        if u != n:\n            cities[u].update({v : t})\n    \n    global memo\n    memo = [LinkedList() for i in range(n+1)]\n    memo[n].Insert(Path(1, 0, None))\n    stack = []\n \n    stack.append(Node(1, 1, 0, None))    \n    while(len(stack) > 0):\n        city = stack.pop()\n \n        if city.number == n:\n            MemoizeWay(city, 1, 0)\n            continue\n\n        if memo[city.number].rootNode != None:\n            cNode = memo[city.number].rootNode\n            while cNode != None:\n                MemoizeWay(city, cNode.value.wayLen, cNode.value.wayTime)\n                cNode = cNode.nextNode\n            continue\n\n        if cities[city.number] != None:\n            for subCity in cities[city.number]:\n                stack.append(Node( subCity, city.wayLen + 1, city.wayTime + cities[city.number][subCity], city ))\n\n    cPath = memo[1].FindBestPath(T).value\n    stdout.write( \"{}\\n\".format(cPath.wayLen) )\n    stdout.write( \"{} \".format(1) )\n    while(cPath.nextNode != None):\n        stdout.write( \"{} \".format(cPath.nextNode) )\n        cPath = memo[cPath.nextNode].FindBestPath(cPath.wayTime).value\n\n\nmain()","tags":["graphs"],"src_uid":"31b929252f7d63cb3654ed367224cc31"}
{"text_full":"[DESCRIPTION]Pavel cooks barbecue. There are n skewers, they lay on a brazier in a row, each on one of n positions. Pavel wants each skewer to be cooked some time in every of n positions in two directions: in the one it was directed originally and in the reversed direction.Pavel has a plan: a permutation p and a sequence b1, b2, ..., bn, consisting of zeros and ones. Each second Pavel move skewer on position i to position pi, and if bi equals 1 then he reverses it. So he hope that every skewer will visit every position in both directions.Unfortunately, not every pair of permutation p and sequence b suits Pavel. What is the minimum total number of elements in the given permutation p and the given sequence b he needs to change so that every skewer will visit each of 2n placements? Note that after changing the permutation should remain a permutation as well.There is no problem for Pavel, if some skewer visits some of the placements several times before he ends to cook. In other words, a permutation p and a sequence b suit him if there is an integer k (k ≥ 2n), so that after k seconds each skewer visits each of the 2n placements.It can be shown that some suitable pair of permutation p and sequence b exists for any n.[SOURCE CODE]import sys\nsys.setrecursionlimit(10 ** 9)\n\n\nn = int(input())\np = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\nused = [False] * n\ncomp = 0\nfor i in range(n):\n    if not used[i]:\n        u = i\n        while True:\n            used[u] = True\n            v = p[u] - 1\n            if not used[v]:\n                u = v\n            else:\n                break\n            \n        comp += 1\n\nif comp == 1:\n    ans = 0\nelse:\n    ans = comp\n\ned = 0\nfor i in range(n):\n    if b[i]:\n        ed += 1\n\nif not ed % 2:\n    ans += 1\n    \nprint(ans)","tags":["graphs"],"src_uid":"1b2a2c8afcaf16b4055002a9511c6f23"}
{"text_full":"[DESCRIPTION]Vasya has a graph containing both directed (oriented) and undirected (non-oriented) edges. There can be multiple edges between a pair of vertices.Vasya has picked a vertex s from the graph. Now Vasya wants to create two separate plans:  to orient each undirected edge in one of two possible directions to maximize number of vertices reachable from vertex s;  to orient each undirected edge in one of two possible directions to minimize number of vertices reachable from vertex s. In each of two plans each undirected edge must become directed. For an edge chosen directions can differ in two plans.Help Vasya find the plans.[SOURCE CODE]I = lambda:map(int, raw_input().split())\nn, m, s = I()\nE = [I() for i in range(m)]\nw = ['+'] * sum(a[0] == 2 for a in E)\ne = [[] for i in range(n)]\nv, s, p = [0] * n, s - 1, 0\nfor i in range(m):\n\tE[i][1] -= 1\n\tE[i][2] -= 1\n\tif E[i][0] == 2:\n\t\te[E[i][1]].append([E[i][2], p * 2 + 1])\n\t\te[E[i][2]].append([E[i][1], p * 2])\n\t\tp += 1\n\telse:\n\t\te[E[i][1]].append([E[i][2], -1])\nq, v[s] = [s], 1\nwhile q:\n\tx = q.pop()\n\tfor y in e[x]:\n\t\tif not v[y[0]]:\n\t\t\tv[y[0]] = 1\n\t\t\tq.append(y[0])\n\t\t\tif y[1] != -1:\n\t\t\t\tw[y[1] \/ 2] = ['-', '+'][y[1] % 2]\nprint sum(v)\nprint ''.join(w)\nv = [0] * n\nq, v[s] = [s], 1\nwhile q:\n\tx = q.pop()\n\tfor y in e[x]:\n\t\tif y[1] != -1:\n\t\t\tw[y[1] \/ 2] = ['+', '-'][y[1] % 2]\n\t\telif not v[y[0]]:\n\t\t\tv[y[0]] = 1\n\t\t\tq.append(y[0])\n\t\t\t\nprint sum(v)\nprint ''.join(w)","tags":["graphs"],"src_uid":"d39359344dc38b3c94c6d304880804b4"}
{"text_full":"[DESCRIPTION]Recently Duff has been a soldier in the army. Malek is her commander.Their country, Andarz Gu has n cities (numbered from 1 to n) and n - 1 bidirectional roads. Each road connects two different cities. There exist a unique path between any two cities.There are also m people living in Andarz Gu (numbered from 1 to m). Each person has and ID number. ID number of i - th person is i and he\/she lives in city number ci. Note that there may be more than one person in a city, also there may be no people living in the city.  Malek loves to order. That's why he asks Duff to answer to q queries. In each query, he gives her numbers v, u and a.To answer a query:Assume there are x people living in the cities lying on the path from city v to city u. Assume these people's IDs are p1, p2, ..., px in increasing order. If k = min(x, a), then Duff should tell Malek numbers k, p1, p2, ..., pk in this order. In the other words, Malek wants to know a minimums on that path (or less, if there are less than a people).Duff is very busy at the moment, so she asked you to help her and answer the queries.[SOURCE CODE]import sys\nrange = xrange\ninput = raw_input\n\nclass Hld:\n    def __init__(self, graph, data, f = min):\n        root = 0\n        n = len(graph) + 1\n        self.data = data\n        self.f = f\n        \n        bfs = [root]\n        self.depth = [-1]*n\n        self.depth[root] = 0\n        self.P = [-1]*n\n        for node in bfs:\n            for nei in graph[node]:\n                if self.depth[nei] == -1:\n                    bfs.append(nei)\n                    self.P[nei] = node\n                    self.depth[nei] = 1 + self.depth[node]\n\n        fam_size = [1]*n\n        preffered_child = list(range(n))\n        for node in reversed(bfs):\n            p = self.P[node]\n            if fam_size[preffered_child[p]] <= fam_size[node]:\n                preffered_child[p] = node\n            fam_size[p] += fam_size[node]\n        fam_size[root] \/\/= 2\n\n        self.hld_P = list(range(n))\n        self.prefix_values = [0]*n\n        values = [[] for _ in range(n)]\n        for node in bfs:\n            self.hld_P[preffered_child[node]] = self.hld_P[node]\n            values[self.hld_P[node]].append(data[node])\n            self.prefix_values[node] = data[node] if node == self.hld_P[node] else f(self.prefix_values[self.P[node]], data[node])\n        self.seg_values = [self.seg_builder(value) for value in values]\n\n    def seg_builder(self, data):\n        self.f = f\n        ans = [0]*len(data)\n        ans += data\n        for i in reversed(range(1, len(data))):\n            ans[i] = self.f(ans[2 * i], ans[2 * i + 1])\n        return ans\n\n    def seg_query(self, data, l, r):\n        l += len(data) >> 1\n        r += len(data) >> 1\n        val = data[l]\n        l += 1\n        while l < r:\n            if l & 1:\n                val = self.f(val, data[l])\n                l += 1\n            if r & 1:\n                val = self.f(val, data[r - 1])\n            l >>= 1\n            r >>= 1\n        return val\n\n\n    def __call__(self, u,v):\n        if u == v:\n            return self.data[u]\n        if self.depth[u] < self.depth[v]:\n            u,v = v,u\n        val = self.data[u]\n        u = self.P[u]\n \n        uhld = self.hld_P[u]\n        vhld = self.hld_P[v]\n        while uhld != vhld:\n            if self.depth[uhld] >= self.depth[vhld]:\n                val = self.f(self.prefix_values[u], val)\n                u = self.P[uhld]\n                uhld = self.hld_P[u]\n            else:\n                val = self.f(self.prefix_values[v], val)\n                v = self.P[vhld]\n                vhld = self.hld_P[v]\n        if self.depth[u] < self.depth[v]:\n            u,v = v,u\n        return self.f(\n                self.seg_query(self.seg_values[uhld],\n                    self.depth[v] - self.depth[uhld], \n                    self.depth[u] - self.depth[uhld] + 1)\n                , val)\n\n\ninp = [int(x) for x in sys.stdin.read().split()]; ii = 0\n \nn = inp[ii]; ii += 1\nm = inp[ii]; ii += 1\nq = inp[ii]; ii += 1\n \ncoupl = [[] for _ in range(n)]\nfor _ in range(n - 1):\n    u = inp[ii] - 1; ii += 1\n    v = inp[ii] - 1; ii += 1\n \n    coupl[u].append(v)\n    coupl[v].append(u)\n \ndef f(A, B):\n    ans = []\n    A = list(A)\n    B = list(B)\n    goal = min(10, len(A) + len(B))\n    while len(ans) < goal:\n        if A and (not B or A[-1] < B[-1]):\n            ans.append(A.pop())\n        else:\n            ans.append(B.pop())\n    ans.reverse()\n    return ans\n \nC = inp[ii:ii + m]; ii += m\ndata = [[] for _ in range(n)]\nfor i in range(m):\n    if len(data[C[i] - 1]) < 10:\n        data[C[i] - 1].append(i + 1)\nfor d in data:\n    d.reverse()\nhld = Hld(coupl, data, f)\n \nout = []\nfor _ in range(q):\n    v = inp[ii] - 1; ii += 1\n    u = inp[ii] - 1; ii += 1\n    a = inp[ii]; ii += 1\n \n    ans = list(hld(v, u))\n    ans.append(min(len(ans), a))\n    out.append(' '.join(str(x) for x in ans[-1:~a-1:-1]))\nprint '\\n'.join(out)","tags":["trees"],"src_uid":"ff84bc8e8e01c82e1ecaa2a39a7f8dc6"}
{"text_full":"[DESCRIPTION]There are n cities numbered from 1 to n in Berland. Some of them are connected by two-way roads. Each road has its own length — an integer number from 1 to 1000. It is known that from each city it is possible to get to any other city by existing roads. Also for each pair of cities it is known the shortest distance between them. Berland Government plans to build k new roads. For each of the planned road it is known its length, and what cities it will connect. To control the correctness of the construction of new roads, after the opening of another road Berland government wants to check the sum of the shortest distances between all pairs of cities. Help them — for a given matrix of shortest distances on the old roads and plans of all new roads, find out how the sum of the shortest distances between all pairs of cities changes after construction of each road.[SOURCE CODE]n = int(input())\nmt = [[] for _i in range(n)]\n\nfor i in range(n):\n    mt[i] = list(map(int,input().split()))\n\n# print(mt)\n\nkk = int(input())\nfor i in range(kk):\n    a,b,c = map(int,input().split())\n    a-=1\n    b-=1\n    if mt[a][b]>c:\n        mt[a][b] = c\n        mt[b][a] = c\n    \n    for i in range(n):\n        for j in range(n):\n            mt[i][j] = min(mt[i][j],mt[i][a]+mt[b][j]+c,mt[i][b]+mt[a][j]+c)\n    \n\n    ans = 0\n    for i in range(n):\n        ans+= sum(mt[i])\n    print(ans\/\/2)","tags":["graphs"],"src_uid":"5dbf91f756fecb004c836a628eb23578"}
{"text_full":"[DESCRIPTION]While exploring the old caves, researchers found a book, or more precisely, a stash of mixed pages from a book. Luckily, all of the original pages are present and each page contains its number. Therefore, the researchers can reconstruct the book.After taking a deeper look into the contents of these pages, linguists think that this may be some kind of dictionary. What's interesting is that this ancient civilization used an alphabet which is a subset of the English alphabet, however, the order of these letters in the alphabet is not like the one in the English language.Given the contents of pages that researchers have found, your task is to reconstruct the alphabet of this ancient civilization using the provided pages from the dictionary.[SOURCE CODE]import os\nimport io\nfrom collections import deque, defaultdict\n\ninput = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\n\ndef li():return [int(i) for i in input().rstrip().split()]\ndef st():return str(input().rstrip())[2:-1]\ndef val():return int(input().rstrip())\n\n# def li():return [int(i) for i in input().rstrip().split()]\n# def st():return str(input())\n# def val():return int(input())\n\n#Input Reading\n\nn,k = li()\n\nwords = [\"\"] * n * k\nindeg = {}\n\nfor i in range(n):\n    p = val()\n    page = []\n    for j in range(k):\n        word = st()\n        words[p*k+j] = word\n    for c in word:\n        indeg[c] = 0\n\ndef match(w1,w2):\n    for i in range(min(len(w1), len(w2))):\n        if w1[i] == w2[i]:\n            continue\n        else:\n            return (w1[i],w2[i])\n\n    if len(w1) > len(w2):\n        print(\"IMPOSSIBLE\")\n        exit()    \n\n#Reading the graph and its indegrees\ng = defaultdict(set)\n\nfor i in range(len(words) - 1):\n    out = match(words[i], words[i+1])\n    if out is not None:\n        c1,c2 = out\n        if c2 not in g[c1]:\n            g[c1].add(c2)\n            indeg[c2] += 1\n\n\n#Topsort things\nts = []\nzero = deque()\nfor u in indeg:\n    if indeg[u] == 0:\n        zero.append(u)\n\nwhile len(ts) != len(indeg):\n    if len(zero) == 0:\n        print(\"IMPOSSIBLE\")\n        exit()\n    \n    u = zero.popleft()\n    ts.append(u)\n    for v in g[u]:\n        indeg[v] -= 1\n        if indeg[v] == 0:\n            zero.append(v)\n\nprint(\"\".join(ts))","tags":["graphs"],"src_uid":"b442b73ecb559f0841c0e86f84b5cbb1"}
{"text_full":"[DESCRIPTION]Welcome to another task about breaking the code lock! Explorers Whitfield and Martin came across an unusual safe, inside of which, according to rumors, there are untold riches, among which one can find the solution of the problem of discrete logarithm!Of course, there is a code lock is installed on the safe. The lock has a screen that displays a string of n lowercase Latin letters. Initially, the screen displays string s. Whitfield and Martin found out that the safe will open when string t will be displayed on the screen.The string on the screen can be changed using the operation «shift x». In order to apply this operation, explorers choose an integer x from 0 to n inclusive. After that, the current string p = αβ changes to βRα, where the length of β is x, and the length of α is n - x. In other words, the suffix of the length x of string p is reversed and moved to the beginning of the string. For example, after the operation «shift 4» the string «abcacb» will be changed with string «bcacab », since α = ab, β = cacb, βR = bcac.Explorers are afraid that if they apply too many operations «shift», the lock will be locked forever. They ask you to find a way to get the string t on the screen, using no more than 6100 operations.[SOURCE CODE]n = int(input())\ns = input()\nt = input()\n\nif sorted(s) != sorted(t):\n    print(-1)\nelse:\n    ans = []\n    for i in t:\n        j = 0\n        for j in range(n):\n            if i == s[j]:\n                break\n        ans.append(n-j-1)\n        ans.append(1)\n        ans.append(n)\n        s = \"\".join(reversed(s[:j])) + s[j+1:] + s[j]\n    print(len(ans))\n    for i in ans:\n        print(i, end=' ')","tags":["strings"],"src_uid":"df0b20cf9b848f7406a13378126f301f"}
{"text_full":"[DESCRIPTION]Nikita likes tasks on order statistics, for example, he can easily find the $$$k$$$-th number in increasing order on a segment of an array. But now Nikita wonders how many segments of an array there are such that a given number $$$x$$$ is the $$$k$$$-th number in increasing order on this segment. In other words, you should find the number of segments of a given array such that there are exactly $$$k$$$ numbers of this segment which are less than $$$x$$$.Nikita wants to get answer for this question for each $$$k$$$ from $$$0$$$ to $$$n$$$, where $$$n$$$ is the size of the array.[SOURCE CODE]from math import pi\nfrom cmath import exp\ndef fft(a, lgN, rot=1): # rot=-1 for ifft\n  N = 1<<lgN\n  assert len(a)==N\n  rev = [0]*N\n  for i in range(N):\n    rev[i] = (rev[i>>1]>>1)+(i&1)*(N>>1)\n  A = [a[rev[i]] for i in range(N)]\n  h = 1\n  while h<N:\n    w_m = exp((0+1j) * rot * (pi \/ h))\n    for k in range(0, N, h<<1):\n      w = 1\n      for j in range(h):\n        t = w * A[k+j+h]\n        A[k+j+h] = A[k+j]-t\n        A[k+j] = A[k+j]+t\n        w *= w_m\n    h = h<<1\n  return A if rot==1 else [x\/N for x in A]\n\n\nimport sys\nints = (int(x) for x in sys.stdin.read().split())\n\nn, x = (next(ints) for i in range(2))\nr = [next(ints) for i in range(n)]\nac = [0]*(n+1)\nfor i in range(n): ac[i+1] = (r[i]<x) + ac[i]\n\n# Multiset addition\nmin_A, min_B = 0, -ac[-1]\nmax_A, max_B = ac[-1], 0\nN, lgN, m = 1, 0, 2*max(max_A-min_A+1, max_B-min_B+1)\nwhile N<m: N,lgN = N<<1,lgN+1\na, b = [0]*N, [0]*N\nfor x in ac:\n  a[x-min_A] += 1\n  b[-x-min_B] += 1\nc = zip(fft(a, lgN), fft(b, lgN))\nc = fft([x*y for x,y in c], lgN, rot=-1)\nc = [round(x.real) for x in c][-min_A-min_B:][:n+1]\nc[0] = sum((x*(x-1))\/\/2 for x in a)\nprint(*c, *(0 for i in range(n+1-len(c))), flush=True)","tags":["math"],"src_uid":"97e68e5cf05c157b4f83eb07ff003790"}
{"text_full":"[DESCRIPTION]You are given a tree (an undirected connected acyclic graph) consisting of $$$n$$$ vertices and $$$n - 1$$$ edges. A number is written on each edge, each number is either $$$0$$$ (let's call such edges $$$0$$$-edges) or $$$1$$$ (those are $$$1$$$-edges).Let's call an ordered pair of vertices $$$(x, y)$$$ ($$$x \\ne y$$$) valid if, while traversing the simple path from $$$x$$$ to $$$y$$$, we never go through a $$$0$$$-edge after going through a $$$1$$$-edge. Your task is to calculate the number of valid pairs in the tree.[SOURCE CODE]import sys\n\nreadline = sys.stdin.buffer.readline\nread = sys.stdin.read\nns = lambda: readline().rstrip()\nni = lambda: int(readline().rstrip())\nnm = lambda: map(int, readline().split())\nnl = lambda: list(map(int, readline().split()))\nprn = lambda x: print(*x, sep='\\n')\n\nclass UnionFind:\n    def __init__(self, n):\n        self.ps = [-1] * (n + 1)\n\n    def find(self, x):\n        if self.ps[x] < 0:\n            return x\n        else:\n            self.ps[x] = self.find(self.ps[x])\n            return self.ps[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return False\n        if self.ps[x] > self.ps[y]:\n            x, y = y, x\n        self.ps[x] += self.ps[y]\n        self.ps[y] = x\n        return True\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def size(self, x):\n        x = self.find(x)\n        return -self.ps[x]\n\n\ndef solve():\n    n = ni()\n    uni = [UnionFind(n), UnionFind(n)]\n    for _ in range(n-1):\n        u, v, c = nm()\n        u -= 1; v -= 1\n        uni[c].unite(u, v)\n    ans = 0\n    for c in range(2):\n        for i in range(n):\n            if uni[c].find(i) == i:\n                v = uni[c].size(i)\n                ans += v * (v-1)\n    for i in range(n):\n        # print(i, (uni[0].size(i), uni[1].size(i)))\n        ans += (uni[0].size(i) - 1) * (uni[1].size(i) - 1)\n    print(ans)\n    return\n\nsolve()\n\n# T = ni()\n# for _ in range(T):\n#     solve()","tags":["trees"],"src_uid":"13b9b9c47ae7e8cfdcaee50f9c187d84"}
{"text_full":"[DESCRIPTION]As Will is stuck in the Upside Down, he can still communicate with his mom, Joyce, through the Christmas lights (he can turn them on and off with his mind). He can't directly tell his mom where he is, because the monster that took him to the Upside Down will know and relocate him.   Thus, he came up with a puzzle to tell his mom his coordinates. His coordinates are the answer to the following problem.A string consisting only of parentheses ('(' and ')') is called a bracket sequence. Some bracket sequence are called correct bracket sequences. More formally:  Empty string is a correct bracket sequence.  if s is a correct bracket sequence, then (s) is also a correct bracket sequence.  if s and t are correct bracket sequences, then st (concatenation of s and t) is also a correct bracket sequence. A string consisting of parentheses and question marks ('?') is called pretty if and only if there's a way to replace each question mark with either '(' or ')' such that the resulting string is a non-empty correct bracket sequence.Will gave his mom a string s consisting of parentheses and question marks (using Morse code through the lights) and his coordinates are the number of pairs of integers (l, r) such that 1 ≤ l ≤ r ≤ |s| and the string slsl + 1... sr is pretty, where si is i-th character of s.Joyce doesn't know anything about bracket sequences, so she asked for your help.[SOURCE CODE]S = raw_input()\nN = len(S)\n\nA = 0\nfor i in xrange(N):\n\tD = 0\n\tQ = 0\n\tfor j in xrange(i, N):\n\t\tD += S[j] == '('\n\t\tD -= S[j] == ')'\n\t\tQ += S[j] == '?'\n\n\t\tif D + Q < 0:\n\t\t\tbreak\n\n\t\tif Q > D:\n\t\t\tD, Q = Q, D\n\n\t\tif Q == D:\n\t\t\tA += 1\nprint A","tags":["math"],"src_uid":"6b0d00ecfa260a33e313ae60d8f9ee06"}
{"text_full":"[DESCRIPTION]You are given an array $$$a$$$, consisting of $$$n$$$ positive integers.Let's call a concatenation of numbers $$$x$$$ and $$$y$$$ the number that is obtained by writing down numbers $$$x$$$ and $$$y$$$ one right after another without changing the order. For example, a concatenation of numbers $$$12$$$ and $$$3456$$$ is a number $$$123456$$$.Count the number of ordered pairs of positions $$$(i, j)$$$ ($$$i \\neq j$$$) in array $$$a$$$ such that the concatenation of $$$a_i$$$ and $$$a_j$$$ is divisible by $$$k$$$.[SOURCE CODE]from sys import stdin, stdout\nti = lambda : stdin.readline().strip()\nos = lambda i : stdout.write(str(i) + '\\n')\nma = lambda fxn, ti : map(fxn, ti.split())\nol = lambda arr : stdout.write(' '.join(element for element in arr) + '\\n')\nolws = lambda arr : stdout.write(''.join(element for element in arr) + '\\n')\n\n\n\nclass Digit:\n\tdef __init__(self):\n\t\tself.count = {}\n\n\tdef increment(self, k):\n\t\tif self.count.has_key(k):\n\t\t\tgot = self.count[k]\n\t\t\tself.count[k] += 1\n\t\telse:\n\t\t\tself.count[k] = 1\n\n\tdef found(self, k):\n\t\tif self.count.has_key(k):\n\t\t\treturn self.count[k]\n\t\telse:\n\t\t\treturn 0\n\nn, mod = ma(int, ti())\narray = ma(int, ti())\n\n\nans = 0\ndigits = [None]*11\nfor i in range(11):\n\tdigits[i] = Digit()\n\nfor i in range(n):\n\ttemp = array[i]%mod\n\n\tfor j in range(10):\n\t\ttemp *= 10\n\t\ttemp %= mod\n\n\t\tdigits[j+1].increment(temp)\n\nfor i in range(n):\n\ttemp = array[i]\n\tcount = 0\n\twhile temp>0:\n\t\ttemp \/= 10\n\t\tcount += 1\n\n\tfind = mod-array[i]%mod\n\tfind %= mod\n\tans += digits[count].found(find)\n\nfor i in range(n):\n\ttemp1 = array[i]%mod\n\ttemp2 = array[i]\n\n\twhile temp2 > 0:\n\t\ttemp2 \/= 10\n\t\ttemp1 *= 10\n\t\ttemp1 %= mod\n\n\tif ((temp1 + array[i])%mod == 0):\n\t\tans -= 1\n\nos(ans)","tags":["math"],"src_uid":"1eb41e764a4248744edce6a9e7e3517a"}
{"text_full":"[DESCRIPTION]Please notice the unusual memory limit of this problem.Orac likes games. Recently he came up with the new game, \"Game of Life\".You should play this game on a black and white grid with $$$n$$$ rows and $$$m$$$ columns. Each cell is either black or white.For each iteration of the game (the initial iteration is $$$0$$$), the color of each cell will change under the following rules: If there are no adjacent cells with the same color as this cell on the current iteration, the color of it on the next iteration will be the same. Otherwise, the color of the cell on the next iteration will be different.Two cells are adjacent if they have a mutual edge.Now Orac has set an initial situation, and he wants to know for the cell $$$(i,j)$$$ (in $$$i$$$-th row and $$$j$$$-th column), what will be its color at the iteration $$$p$$$. He may ask you these questions several times.[SOURCE CODE]import os\nimport sys\nfrom atexit import register\nfrom io import BytesIO\nsys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))\nsys.stdout = BytesIO()\nregister(lambda: os.write(1, sys.stdout.getvalue()))\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n')\nraw_input = lambda: sys.stdin.readline().rstrip('\\r\\n')\n\n\nn,m,tt = map(int,raw_input().split(\" \"))\nmat = []\nfor i in range(n):\n\tmat.append(map(int,raw_input()))\n\nflag = [[0]*m for i in range(n)]\nsteps = [[0]*m for i in range(n)]\ndirs = [[0,1],[0,-1],[-1,0],[1,0]]\n\ndef adj(i,j):\n\tfor x,y in dirs:\n\t\ts = i+x\n\t\tt = j+y\n\t\tif 0<=s<n and 0<=t<m and mat[i][j] == mat[s][t]:\n\t\t\treturn 1\n\treturn 0\n\nq = []\nvisited = [[0]*m for i in range(n)]\nfor i in range(n):\n\tfor j in range(m):\n\t\tflag[i][j] = adj(i,j)\n\t\tif flag[i][j]:\n\t\t\tq.append((i,j))\n\t\t\tvisited[i][j] = 1\n\nif len(q) == 0:\n\tfor _ in range(tt):\n\t\ti,j,p = map(int,raw_input().split(\" \"))\t\n\t\tprint mat[i-1][j-1]\n\nelse:\n\tit = 0\n\tl1 = len(q)\n\twhile it < l1:\n\t\ti,j = q[it]\n\t\tfor x,y in dirs:\n\t\t\ts = i+x\n\t\t\tt = j+y\n\t\t\tif 0<=s<n and 0<=t<m and not visited[s][t]:\n\t\t\t\tvisited[s][t] = 1\n\t\t\t\tsteps[s][t] = steps[i][j]+1\n\t\t\t\tq.append((s,t))\n\t\t\t\tl1 += 1\n\t\tit += 1\n\n\tfor _ in range(tt):\n\t\ti,j,p = map(int,raw_input().split(\" \"))\n\n\t\tif p <= steps[i-1][j-1]:\n\t\t\tprint mat[i-1][j-1]\n\t\telse:\n\t\t\tprint ((p-steps[i-1][j-1])%2)^mat[i-1][j-1]","tags":["graphs"],"src_uid":"1326553bb07ffcc7bd3eecc7070c5958"}
{"text_full":"[DESCRIPTION]Jeel and Ashish play a game on an $$$n \\times m$$$ matrix. The rows are numbered $$$1$$$ to $$$n$$$ from top to bottom and the columns are numbered $$$1$$$ to $$$m$$$ from left to right. They play turn by turn. Ashish goes first.Initially, each cell of the matrix contains a non-negative integer. Each turn, a player must perform all of the following actions in order.   Choose a starting cell $$$(r_1, c_1)$$$ with non-zero value.  Choose a finishing cell $$$(r_2, c_2)$$$ such that $$$r_1 \\leq r_2$$$ and $$$c_1 \\leq c_2$$$.  Decrease the value of the starting cell by some positive non-zero integer.  Pick any of the shortest paths between the two cells and either increase, decrease or leave the values of cells on this path unchanged. Note that:   a shortest path is one that passes through the least number of cells;  all cells on this path excluding the starting cell, but the finishing cell may be modified;  the resulting value of each cell must be a non-negative integer;  the cells are modified independently and not necessarily by the same value.  If the starting and ending cells are the same, then as per the rules, the value of the cell is decreased. No other operations are performed.The game ends when all the values become zero. The player who is unable to make a move loses. It can be shown that the game will end in a finite number of moves if both players play optimally.Given the initial matrix, if both players play optimally, can you predict who will win?[SOURCE CODE]def solve():\n    n, m = [int(x) for x in input().split()]\n    a = []\n\n    for i in range(n):\n        v =[int(x) for x in input().split()]\n        a.append(v)\n\n    xorsums = [0] * (n+m-1)\n\n    for i in range(n):\n        for j in range(m):\n            xorsums[i+j] ^= a[i][j]\n\n    f = 0\n\n    for i in range(n+m-1):\n        if xorsums[i] !=0:\n            f = 1\n    if f == 1:\n        print('Ashish')\n    else:\n        print('Jeel')\n\ndef main():\n    t = int(input())\n    \n    for i in range(t):\n        solve()\n\nmain()","tags":["games"],"src_uid":"7c7acf9f91920cb00ed8cfcb0d3539e2"}
{"text_full":"[DESCRIPTION]Today is Devu's birthday. For celebrating the occasion, he bought n sweets from the nearby market. He has invited his f friends. He would like to distribute the sweets among them. As he is a nice guy and the occasion is great, he doesn't want any friend to be sad, so he would ensure to give at least one sweet to each friend. He wants to celebrate it in a unique style, so he would like to ensure following condition for the distribution of sweets. Assume that he has distributed n sweets to his friends such that ith friend is given ai sweets. He wants to make sure that there should not be any positive integer x &gt; 1, which divides every ai.Please find the number of ways he can distribute sweets to his friends in the required way. Note that the order of distribution is important, for example [1, 2] and [2, 1] are distinct distributions. As the answer could be very large, output answer modulo 1000000007 (109 + 7).To make the problem more interesting, you are given q queries. Each query contains an n, f pair. For each query please output the required number of ways modulo 1000000007 (109 + 7).[SOURCE CODE]import itertools\nimport functools\nimport operator\n\nN = 100001\nP = 10**9 + 7\n\nfact = [1]\nfor i in range(1, N):\n\tfact.append(fact[-1] * i % P)\n\ninv = [0, 1]\nfor i in range(2, N):\n\tinv.append(P - P \/\/ i * inv[P % i] % P)\ninv_fact = [1]\nfor i in range(1, N):\n\tinv_fact.append(inv_fact[-1] * inv[i] % P)\n\nleast_div = [-1] * N\nprimes = []\n\nfor p in range(2, N):\n\tif least_div[p] == -1:\n\t\tprimes.append(p)\n\t\tleast_div[p] = p\n\tldiv = least_div[p]\n\tfor mult in primes:\n\t\tmark = mult * p\n\t\tif (mult > ldiv) or (mark >= N):\n\t\t\tbreak\n\t\tleast_div[mark] = mult\n\nt = int(input())\n\ndef powerset(iterable):\n    s = list(iterable)\n    return itertools.chain.from_iterable(itertools.combinations(s, r) for r in range(len(s) + 1))\n\nmemo_factor = dict()\n\ndef factor(n):\n\tif n in memo_factor:\n\t\treturn memo_factor[n]\n\tret = []\n\twhile n != 1:\n\t\ttmp = least_div[n]\n\t\tif not(ret and ret[-1] == tmp):\n\t\t\tret.append(tmp)\n\t\tn \/\/= tmp\n\tmemo_factor[n] = ret\n\treturn ret\n\n@functools.lru_cache(maxsize = None)\ndef solve(n, k):\n\tdivs = factor(n)\n\t# print(divs)\n\tret = 0\n\tfor subset in powerset(divs):\n\t\tdiv = functools.reduce(operator.mul, subset, 1)\n\t\t# print(div, f(n \/\/ div, k))\n\t\tif n \/\/ div >= k:\n\t\t\ttmp = fact[n \/\/ div - 1] * inv_fact[n \/\/ div - k] % P * inv_fact[k - 1] % P\n\t\t\tret += (-1 if len(subset) % 2 == 1 else 1) * tmp\n\t\t\tret %= P\n\treturn ret\n\nfor _ in range(t):\n\tn, k = map(int, input().split())\n\tprint(solve(n, k))","tags":["math"],"src_uid":"a00e2e79a3914ee11202a799c9bc01e7"}
{"text_full":"[DESCRIPTION]Fox Ciel is playing a game. In this game there is an infinite long tape with cells indexed by integers (positive, negative and zero). At the beginning she is standing at the cell 0.There are also n cards, each card has 2 attributes: length li and cost ci. If she pays ci dollars then she can apply i-th card. After applying i-th card she becomes able to make jumps of length li, i. e. from cell x to cell (x - li) or cell (x + li).She wants to be able to jump to any cell on the tape (possibly, visiting some intermediate cells). For achieving this goal, she wants to buy some cards, paying as little money as possible. If this is possible, calculate the minimal cost.[SOURCE CODE]#!\/usr\/bin\/env python\n#-*- coding:utf-8 -*-\n\nimport sys\nimport math\nimport random\nimport operator\nfrom fractions import Fraction, gcd\nfrom decimal import Decimal, getcontext\nfrom itertools import product, permutations, combinations\ngetcontext().prec = 100\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\nMOD = 10**9 + 7\nINF = float(\"+inf\")\n\nn = int(raw_input())\n\narr = map(int, raw_input().split())\narr_costs = map(int, raw_input().split())\ncosts = {}\nfor i, c in enumerate(arr):\n    costs[c] = min(arr_costs[i], costs.get(c, INF))\n\nmin_cost = sum(arr_costs)\n\nfor i in xrange(100):\n    lst = arr[::]\n    random.shuffle(lst)\n    r = 0\n    cost = 0\n    for x in lst:\n        r0 = r\n        r = gcd(r, x)\n        if r != r0:\n            cost += costs[x]\n        if r == 1:\n            break\n    if cost < min_cost:\n        min_cost = cost\n\nif reduce(gcd, arr, 0) != 1:\n    print -1\n    quit()\n\ng_min_cost = {0: 0}\nfrom Queue import PriorityQueue\nq = PriorityQueue()\nq.put((0, 0))\nchecked = set()\nwhile not q.empty():\n    cost, g = q.get()\n    # print cost, g\n    if g_min_cost[g] != cost:\n        continue\n    checked.add((cost, g))\n\n    for x in arr:\n        cost2 = cost + costs[x]\n        if cost2 >= min_cost:\n            continue\n        g2 = int(abs(gcd(g, x)))\n        if g2 == g:\n            continue\n        if g2 == 1:\n            min_cost = min(min_cost, cost2)\n            continue\n\n        if g_min_cost.get(g2, INF) > cost2:\n            g_min_cost[g2] = cost2\n            q.put((cost2, g2))\n        # if (cost2, g2) not in checked:\n\nprint min_cost","tags":["number theory","math"],"src_uid":"42d0350a0a18760ce6d0d7a4d65135ec"}
{"text_full":"[DESCRIPTION]Polycarp likes arithmetic progressions. A sequence $$$[a_1, a_2, \\dots, a_n]$$$ is called an arithmetic progression if for each $$$i$$$ ($$$1 \\le i &lt; n$$$) the value $$$a_{i+1} - a_i$$$ is the same. For example, the sequences $$$[42]$$$, $$$[5, 5, 5]$$$, $$$[2, 11, 20, 29]$$$ and $$$[3, 2, 1, 0]$$$ are arithmetic progressions, but $$$[1, 0, 1]$$$, $$$[1, 3, 9]$$$ and $$$[2, 3, 1]$$$ are not.It follows from the definition that any sequence of length one or two is an arithmetic progression.Polycarp found some sequence of positive integers $$$[b_1, b_2, \\dots, b_n]$$$. He agrees to change each element by at most one. In the other words, for each element there are exactly three options: an element can be decreased by $$$1$$$, an element can be increased by $$$1$$$, an element can be left unchanged.Determine a minimum possible number of elements in $$$b$$$ which can be changed (by exactly one), so that the sequence $$$b$$$ becomes an arithmetic progression, or report that it is impossible.It is possible that the resulting sequence contains element equals $$$0$$$.[SOURCE CODE]import sys\n\nn = raw_input()\na = map(int,raw_input().split())\n\nans = sys.maxint\n\n\nif len(a) > 2:\n    check = [(0,0,0),\n            (1,0,1),\n            (0,1,1),\n            (-1,0,1),\n            (0,-1,1),\n            (1,-1,2),\n            (-1,1,2),\n            (1,1,2),\n            (-1,-1,2)]\n\n    for e in check:\n        diff = (a[1]+e[1]) - (a[0]+e[0]) \n        chg = e[2]\n        state = [e[0],e[1]]\n        valid = True \n        for i in range(2,len(a)):\n            if a[i] - (a[i-1]+state[i-1]) - diff >= 2 or a[i] - (a[i-1]+state[i-1]) - diff <= -2:\n                valid = False\n                break\n            else:\n                state.append(diff - (a[i] - (a[i-1]+state[i-1])) )\n                chg += abs(a[i] - (a[i-1]+state[i-1]) - diff)\n\n        if valid:\n            ans = min(chg,ans)\nelse:\n    ans = 0\n\n        \n\nprint -1 if ans == sys.maxint else ans","tags":["math"],"src_uid":"79b0794f81acc1c882649d96b1c7f8da"}
{"text_full":"[DESCRIPTION]The crowdedness of the discotheque would never stop our friends from having fun, but a bit more spaciousness won't hurt, will it?The discotheque can be seen as an infinite xy-plane, in which there are a total of n dancers. Once someone starts moving around, they will move only inside their own movement range, which is a circular area Ci described by a center (xi, yi) and a radius ri. No two ranges' borders have more than one common point, that is for every pair (i, j) (1 ≤ i &lt; j ≤ n) either ranges Ci and Cj are disjoint, or one of them is a subset of the other. Note that it's possible that two ranges' borders share a single common point, but no two dancers have exactly the same ranges.Tsukihi, being one of them, defines the spaciousness to be the area covered by an odd number of movement ranges of dancers who are moving. An example is shown below, with shaded regions representing the spaciousness if everyone moves at the same time.  But no one keeps moving for the whole night after all, so the whole night's time is divided into two halves — before midnight and after midnight. Every dancer moves around in one half, while sitting down with friends in the other. The spaciousness of two halves are calculated separately and their sum should, of course, be as large as possible. The following figure shows an optimal solution to the example above.  By different plans of who dances in the first half and who does in the other, different sums of spaciousness over two halves are achieved. You are to find the largest achievable value of this sum.[SOURCE CODE]import math\n\nclass circ:\n\tdef __init__(self, x, y, r):\n\t\tself.x = x*1.0\n\t\tself.y = y*1.0\n\t\tself.r = r*1.0\n\nn = 0\nn = int(input())\nvec = []\nfor i in range(n):\n\tst = input().split(' ')\n\ta = int(st[0])\n\tb = int(st[1])\n\tc = int(st[2])\n\tvec.append(circ(a,b,c))\n\ngr = [[] for i in range(n)]\npad = [-1 for i in range(n)]\nvis = [False for i in range(n)]\n\nfor i in range(n):\n\tfor k in range(n):\n\t\tif i == k:\n\t\t\tcontinue\n\t\tdist = math.hypot(vec[i].x - vec[k].x, vec[i].y - vec[k].y)\n\t\tif (dist < vec[k].r\n\t\t\tand vec[k].r > vec[i].r\n\t\t\tand (pad[i] < 0 or vec[k].r < vec[pad[i]].r)):\n\t\t\tpad[i] = k\n\nfor i in range(n):\n\tif pad[i] < 0:\n\t\tcontinue\n\tgr[pad[i]].append(i)\n\nst = []\nans = 0.0\nfor i in range(n):\n\tif pad[i] >= 0 or vis[i]:\n\t\tcontinue\n\tst.append((i, 0))\n\twhile len(st) > 0:\n\t\tnode, level = st.pop()\n\t\tvis[node] = True\n\t\tmult = -1.0\n\t\tif level == 0 or level%2 == 1:\n\t\t\tmult = 1.0\n\t\tans += (mult * (vec[node].r * vec[node].r * math.pi))\n\t\tfor next in gr[node]:\n\t\t\tst.append((next, level+1))\n\nprint(ans)","tags":["geometry","trees"],"src_uid":"56a13208f0a9b2fad23756f39acd64af"}
{"text_full":"[DESCRIPTION]Developers often face with regular expression patterns. A pattern is usually defined as a string consisting of characters and metacharacters that sets the rules for your search. These patterns are most often used to check whether a particular string meets the certain rules.In this task, a pattern will be a string consisting of small English letters and question marks ('?'). The question mark in the pattern is a metacharacter that denotes an arbitrary small letter of the English alphabet. We will assume that a string matches the pattern if we can transform the string into the pattern by replacing the question marks by the appropriate characters. For example, string aba matches patterns: ???, ??a, a?a, aba.Programmers that work for the R1 company love puzzling each other (and themselves) with riddles. One of them is as follows: you are given n patterns of the same length, you need to find a pattern that contains as few question marks as possible, and intersects with each of the given patterns. Two patterns intersect if there is a string that matches both the first and the second pattern. Can you solve this riddle?[SOURCE CODE]import sys\nimport itertools\n\nWILDCARD = '?'\nFILL = 'x'\n\n\ndef main():\n    pattern_count = int(sys.stdin.readline())\n    patterns = itertools.islice(sys.stdin, pattern_count)\n    result = intersect_patterns(p.strip() for p in patterns)\n    print(result)\n\n\ndef intersect_patterns(lines):\n    return ''.join(_intersect_patterns(lines))\n\n\ndef _intersect_patterns(lines):\n    first, *patterns = lines\n    for position, char in enumerate(first):\n        unique_chars = set(pattern[position] for pattern in patterns)\n        unique_chars.add(char)\n        unique_chars.discard(WILDCARD)\n        if not unique_chars:\n            yield FILL\n        elif len(unique_chars) == 1:\n            yield unique_chars.pop()\n        else:\n            yield WILDCARD\n\n\nif __name__ == '__main__':\n    main()","tags":["strings"],"src_uid":"a51d2e6e321d7db67687a594a2b85e47"}
{"text_full":"[DESCRIPTION]While resting on the ship after the \"Russian Code Cup\" a boy named Misha invented an interesting game. He promised to give his quadrocopter to whoever will be the first one to make a rectangular table of size n × m, consisting of positive integers such that the sum of the squares of numbers for each row and each column was also a square.Since checking the correctness of the table manually is difficult, Misha asks you to make each number in the table to not exceed 108.[SOURCE CODE]n, m = map(int, raw_input().split())\ndef f(k):\n    if k == 1:\n        return [1]\n    elif k == 2:\n        return [3, 4]\n    elif k % 2:\n        return [2] + [1] * (k - 2) + [(k + 1) \/ 2]\n    else:\n        return [1] * (k - 1) + [(k - 1)\/ 2]\nfor i in f(n):\n    for j in f(m):\n        print i * j,\n    print","tags":["math"],"src_uid":"c80cdf090685d40fd34c3fd082a81469"}
{"text_full":"[DESCRIPTION]A famous sculptor Cicasso goes to a world tour!Well, it is not actually a world-wide. But not everyone should have the opportunity to see works of sculptor, shouldn't he? Otherwise there will be no any exclusivity. So Cicasso will entirely hold the world tour in his native country — Berland.Cicasso is very devoted to his work and he wants to be distracted as little as possible. Therefore he will visit only four cities. These cities will be different, so no one could think that he has \"favourites\". Of course, to save money, he will chose the shortest paths between these cities. But as you have probably guessed, Cicasso is a weird person. Although he doesn't like to organize exhibitions, he likes to travel around the country and enjoy its scenery. So he wants the total distance which he will travel to be as large as possible. However, the sculptor is bad in planning, so he asks you for help. There are n cities and m one-way roads in Berland. You have to choose four different cities, which Cicasso will visit and also determine the order in which he will visit them. So that the total distance he will travel, if he visits cities in your order, starting from the first city in your list, and ending in the last, choosing each time the shortest route between a pair of cities — will be the largest. Note that intermediate routes may pass through the cities, which are assigned to the tour, as well as pass twice through the same city. For example, the tour can look like that: . Four cities in the order of visiting marked as overlines: [1, 5, 2, 4].Note that Berland is a high-tech country. So using nanotechnologies all roads were altered so that they have the same length. For the same reason moving using regular cars is not very popular in the country, and it can happen that there are such pairs of cities, one of which generally can not be reached by car from the other one. However, Cicasso is very conservative and cannot travel without the car. Choose cities so that the sculptor can make the tour using only the automobile. It is guaranteed that it is always possible to do.[SOURCE CODE]#!\/usr\/bin\/env python\nfrom __future__ import division, print_function\n\nimport os\nimport sys\nfrom io import BytesIO, IOBase\nfrom heapq import heappop, heappush\n\nif sys.version_info[0] < 3:\n    from __builtin__ import xrange as range\n    from future_builtins import ascii, filter, hex, map, oct, zip\n\n\nINF = float('inf')\n\n\n\ndef bfs(graph, start=0):\n    used = [False] * len(graph)\n    used[start] = True\n    dist = [0] * len(graph)\n    q = [start]\n    for v in q:\n        for w in graph[v]:\n            if not used[w]:\n                dist[w] = dist[v] + 1\n                used[w] = True\n                q.append(w)\n    return dist, q[-3:]\n\n\ndef main():\n    n, m = map(int, input().split())\n\n    rev_graph = [set() for _ in range(n)]\n    graph = [set() for _ in range(n)]\n    for _ in range(m):\n        u, v = map(int, input().split())\n        if u == v:\n            continue\n        graph[u - 1].add(v - 1)\n        rev_graph[v - 1].add(u - 1)\n\n\n    adj = [[0] * n for _ in range(n)]\n    best_to = [[0] * 3 for _ in range(n)]\n    best_from = [[0] * 3 for _ in range(n)]\n\n    for i in range(n):\n        adj[i], best_from[i] = bfs(graph, i)\n        _, best_to[i] = bfs(rev_graph, i)\n\n\n    best_score = 0\n    sol = (-1, -1, -1, -1)\n\n    for c2 in range(n):\n        for c3 in range(n):\n            if not adj[c2][c3] or c2 == c3:\n                continue\n\n            for c1 in best_to[c2]:\n                if c1 in [c2, c3]:\n                    continue\n\n                for c4 in best_from[c3]:\n                    if c4 in [c1, c2, c3]:\n                        continue\n\n                    score = adj[c1][c2] + adj[c2][c3] + adj[c3][c4]\n\n                    if score > best_score:\n                        best_score = score\n                        sol = (c1 + 1, c2 + 1, c3 + 1, c4 + 1)\n\n    print(*sol)\n\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\n\nif __name__ == \"__main__\":\n    main()","tags":["graphs"],"src_uid":"e01cf98c203b8845312ce30af70d3f2e"}
{"text_full":"[DESCRIPTION]Smart Beaver recently got interested in a new word game. The point is as follows: count the number of distinct good substrings of some string s. To determine if a string is good or not the game uses rules. Overall there are n rules. Each rule is described by a group of three (p, l, r), where p is a string and l and r (l ≤ r) are integers. We’ll say that string t complies with rule (p, l, r), if the number of occurrences of string t in string p lies between l and r, inclusive. For example, string \"ab\", complies with rules (\"ab\", 1, 2) and (\"aab\", 0, 1), but does not comply with rules (\"cd\", 1, 2) and (\"abab\", 0, 1).A substring s[l... r] (1 ≤ l ≤ r ≤ |s|) of string s = s1s2... s|s| (|s| is a length of s) is string slsl + 1... sr.Consider a number of occurrences  of string t in string p as a number of pairs of integers l, r (1 ≤ l ≤ r ≤ |p|) such that p[l... r] = t.We’ll say that string t is good if it complies with all n rules. Smart Beaver asks you to help him to write a program that can calculate the number of distinct good substrings of string s. Two substrings s[x... y] and s[z... w] are cosidered to be distinct iff s[x... y] ≠ s[z... w].[SOURCE CODE]def count(p, s):\n    start = 0\n    c = 0\n    while True:\n        try:\n            pos = s.index(p, start)\n            c += 1\n            start = pos + 1\n        except ValueError:\n            return c\n\ns = input()\nn = int(input())\n\npravs = []\nfor i in range(n):\n    p, l, r = input().split()\n    l = int(l); r = int(r)\n    pravs.append((p, l, r))\n\nvar = set()\nfor l in range(len(s)):\n    for r in range(l+1, len(s)+1):\n        pods = s[l:r]\n        for prav in pravs:\n            if not prav[1] <= count(pods, prav[0]) <= prav[2]:\n                break\n        else:\n            var.add(pods)\n\nprint(len(var))","tags":["strings"],"src_uid":"10f2f1df27cf61f11afb074dab01ebec"}
{"text_full":"[DESCRIPTION]You are given a set of n points on the plane. A line containing the origin is called good, if projection of the given set to this line forms a symmetric multiset of points. Find the total number of good lines.Multiset is a set where equal elements are allowed.Multiset is called symmetric, if there is a point P on the plane such that the multiset is centrally symmetric in respect of point P.[SOURCE CODE]from fractions import Fraction\nimport time\n\n\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\n    def to_tuple(self):\n        return (self.x, self.y)\n\n    def __repr__(self):\n        return \"Point({}, {})\".format(self.x, self.y)\n\n    def __eq__(self, other):\n        return self.to_tuple() == other.to_tuple()\n\n    def __hash__(self):\n        return hash(self.to_tuple())\n\n    def __neg__(self):\n        return Point(-self.x, -self.y)\n\n    def __add__(self, other):\n        return Point(self.x+other.x, self.y+other.y)\n\n    def __sub__(self, other):\n        return self+(-other)\n\n    def scalar_mul(self, mu):\n        return Point(mu*self.x, mu*self.y)\n\n    def int_divide(self, den):\n        return Point(self.x\/\/den, self.y\/\/den)\n\n\nclass Line:\n    def __init__(self, a, b, c):\n        # ax+by+c=0\n        self.a = a\n        self.b = b\n        self.c = c\n\n    def __repr__(self):\n        return \"{}*x + {}*y + {} = 0\".format(self.a, self.b, self.c)\n\n    @classmethod\n    def between_two_points(cls, P, Q):\n        return cls(P.y-Q.y, Q.x-P.x, P.x*Q.y-P.y*Q.x)\n\n    def evaluate(self, P):\n        return self.a*P.x+self.b*P.y+self.c\n\n    def direction(self):\n        if self.a == 0:\n            return (0, 1)\n        return (1, Fraction(self.b, self.a))\n\n\ndef abs_sgn(x):\n    if x == 0:\n        return 0, 0\n    if x < 0:\n        return -x, -1\n    return x, 1\n\n\ndef solve(tuple_points):\n    points = set()\n    center = Point(0, 0)\n    for cur in tuple_points:\n        cur = Point(*cur).scalar_mul(2*n)\n        center += cur\n        points.add(cur)\n\n    center = center.int_divide(n)\n    dcenter = center+center\n\n    sym_points_set = set()\n    for p in points:\n        sym_points_set.add(dcenter-p)\n    nosym = list(points - sym_points_set)\n\n    if len(nosym) == 0:\n        print(-1)\n        exit(0)\n\n    p0 = nosym[0]\n    good_lines = set()\n    for p in nosym:\n        m = (p+p0).int_divide(2)\n        line = Line.between_two_points(m, center)\n        distances = list(map(line.evaluate, nosym))\n\n        ok = True\n        mydict = {}\n        for dd in distances:\n            dda, sgn = abs_sgn(dd)\n            if dda not in mydict:\n                mydict[dda] = sgn\n            else:\n                mydict[dda] += sgn\n        for k in mydict:\n            if mydict[k] != 0:\n                ok = False\n                break\n        if ok:\n            good_lines.add(line.direction())\n\n    return len(good_lines)\n\n\n# This one is accepted on CF\nif __name__ == \"__main__\":\n    n = int(input())\n    pts = []\n    for i in range(n):\n        row = input().split(\" \")\n        cur = (int(row[0]), int(row[1]))\n        pts.append(cur)\n    print(solve(pts))","tags":["geometry"],"src_uid":"5d7ba962400c05433ee17c5658888e69"}
{"text_full":"[DESCRIPTION]Bash likes playing with arrays. He has an array a1, a2, ... an of n integers. He likes to guess the greatest common divisor (gcd) of different segments of the array. Of course, sometimes the guess is not correct. However, Bash will be satisfied if his guess is almost correct.Suppose he guesses that the gcd of the elements in the range [l, r] of a is x. He considers the guess to be almost correct if he can change at most one element in the segment such that the gcd of the segment is x after making the change. Note that when he guesses, he doesn't actually change the array — he just wonders if the gcd of the segment can be made x. Apart from this, he also sometimes makes changes to the array itself.Since he can't figure it out himself, Bash wants you to tell him which of his guesses are almost correct. Formally, you have to process q queries of one of the following forms:  1 l r x — Bash guesses that the gcd of the range [l, r] is x. Report if this guess is almost correct.  2 i y — Bash sets ai to y. Note: The array is 1-indexed.[SOURCE CODE]#!\/usr\/bin\/env python2\n\"\"\"\nThis file is part of https:\/\/github.com\/cheran-senthil\/PyRival\nCopyright 2019 Cheran Senthilkumar <hello@cheran.io>\n\n\"\"\"\nfrom __future__ import division, print_function\n\nimport itertools\nimport os\nimport sys\nfrom atexit import register\nfrom io import BytesIO\n\n\nclass dict(dict):\n    \"\"\"dict() -> new empty dictionary\"\"\"\n\n    def items(self):\n        \"\"\"D.items() -> a set-like object providing a view on D's items\"\"\"\n        return dict.iteritems(self)\n\n    def keys(self):\n        \"\"\"D.keys() -> a set-like object providing a view on D's keys\"\"\"\n        return dict.iterkeys(self)\n\n    def values(self):\n        \"\"\"D.values() -> an object providing a view on D's values\"\"\"\n        return dict.itervalues(self)\n\n\ndef gcd(x, y):\n    \"\"\"greatest common divisor of x and y\"\"\"\n    while y:\n        x, y = y, x % y\n    return x\n\n\nrange = xrange\n\nfilter = itertools.ifilter\nmap = itertools.imap\nzip = itertools.izip\n\ninput = BytesIO(os.read(0, os.fstat(0).st_size)).readline\nsys.stdout = BytesIO()\nregister(lambda: os.write(1, sys.stdout.getvalue()))\n\n\ndef main():\n    a = [0] * (524288 << 1 | 1)\n    n, arr = int(input()), [int(num) for num in input().split()]\n\n    for i in range(n):\n        p = i + 524289\n        a[p] = arr[i]\n        while p != 1:\n            p >>= 1\n            a[p] = gcd(a[p << 1], a[p << 1 | 1])\n\n    for i in range(int(input())):\n        q = [int(num) for num in input().split()]\n\n        if q[0] == 1:\n            p = 524288 + q[1]\n\n            while p != 1 and (a[p] % q[3] == 0):\n                if p & (p + 1) == 0:\n                    p = n + 524289\n                    break\n                p = (p + 1) >> 1\n\n            while p < 524288:\n                p <<= 1\n                p += int(a[p] % q[3] == 0)\n\n            if p - 524288 >= q[2]:\n                print('YES')\n            else:\n                p += 1\n\n                while p != 1 and (a[p] % q[3] == 0):\n                    if p & (p + 1) == 0:\n                        p = n + 524289\n                        break\n                    p = (p + 1) >> 1\n\n                while p < 524288:\n                    p <<= 1\n                    p += int(a[p] % q[3] == 0)\n\n                print('YES' if p - 524288 > q[2] else 'NO')\n\n        else:\n            p = q[1] + 524288\n            a[p] = q[2]\n\n            while p != 1:\n                p >>= 1\n                a[p] = gcd(a[p << 1], a[p << 1 | 1])\n\n\nif __name__ == '__main__':\n    main()","tags":["number theory"],"src_uid":"39e7083c9d16a8cb92fc93bd8185fad2"}
{"text_full":"[DESCRIPTION]Iahub likes trees very much. Recently he discovered an interesting tree named propagating tree. The tree consists of n nodes numbered from 1 to n, each node i having an initial value ai. The root of the tree is node 1.This tree has a special property: when a value val is added to a value of node i, the value -val is added to values of all the children of node i. Note that when you add value -val to a child of node i, you also add -(-val) to all children of the child of node i and so on. Look an example explanation to understand better how it works.This tree supports two types of queries:  \"1 x val\" — val is added to the value of node x;  \"2 x\" — print the current value of node x. In order to help Iahub understand the tree better, you must answer m queries of the preceding type.[SOURCE CODE]class BIT():\n    \"\"\"区間加算、一点取得クエリをそれぞれO(logN)で応えるデータ構造を構築する\n    add: 区間[begin, end)にvalを加える\n    get_val: i番目(0-indexed)の値を求める\n    \"\"\"\n    def __init__(self, n):\n        self.n = n\n        self.bit = [0] * (n + 1)\n\n    def get_val(self, i):\n        i = i + 1\n        s = 0\n        while i <= self.n:\n            s += self.bit[i]\n            i += i & -i\n        return s\n\n    def _add(self, i, val):\n        while i > 0:\n            self.bit[i] += val\n            i -= i & -i\n\n    def add(self, i, j, val):\n        self._add(j, val)\n        self._add(i, -val)\n\n\nfrom collections import deque\nimport sys\ninput = sys.stdin.readline\n\n\ndef eular_tour(tree: list, root: int):\n    \"\"\"頂点に対するオイラーツアーを行う\n    posの部分木に区間[begin[pos], end[pos])が対応する\n    \"\"\"\n    n = len(tree)\n    res = []\n    begin = [-1] * n\n    end = [-1] * n\n    visited = [False] * n\n    visited[root] = True\n    q = deque([root])\n    while q:\n        pos = q.pop()\n        res.append(pos)\n        end[pos] = len(res)\n        if begin[pos] == -1:\n            begin[pos] = len(res) - 1\n        for next_pos in tree[pos]:\n            if visited[next_pos]:\n                continue\n            else:\n                visited[next_pos] = True\n                q.append(pos)\n                q.append(next_pos)\n\n    return res, begin, end\n\nn, q = map(int, input().split())\ninit_cost = list(map(int, input().split()))\ninfo = [list(map(int, input().split())) for i in range(n-1)]\nquery = [list(map(int, input().split())) for i in range(q)]\n\ntree = [[] for i in range(n)]\nfor i in range(n-1):\n    a, b = info[i]\n    a -= 1\n    b -= 1\n    tree[a].append(b)\n    tree[b].append(a)\n\nres, begin, end = eular_tour(tree, 0)\neven_res = []\nodd_res = []\nfor i in range(len(res)):\n    if i % 2 == 0:\n        even_res.append(res[i])\n    else:\n        odd_res.append(res[i])\n\neven_bit = BIT(len(even_res))\nodd_bit = BIT(len(odd_res))\n\nfor i in range(q):\n    if query[i][0] == 1:\n        _, pos, cost = query[i]\n        pos -= 1\n        if begin[pos] % 2 == 0:\n            even_bit.add(begin[pos] \/\/ 2, (end[pos] + 1) \/\/ 2, cost)\n            odd_bit.add(begin[pos] \/\/ 2, end[pos] \/\/ 2, -cost)    \n        else:\n            odd_bit.add(begin[pos] \/\/ 2, end[pos] \/\/ 2, cost) \n            even_bit.add((begin[pos] + 1) \/\/ 2, end[pos] \/\/ 2, -cost) \n    else:\n        _, pos = query[i]\n        pos -= 1\n        if begin[pos] % 2 == 0:\n            ans = even_bit.get_val(begin[pos] \/\/ 2)\n        else:\n            ans = odd_bit.get_val(begin[pos] \/\/ 2)\n        print(ans + init_cost[pos])","tags":["trees"],"src_uid":"68b6b4f28649dd69e73197043130fa6f"}
{"text_full":"[DESCRIPTION]This is an interactive problem!Ehab has a hidden permutation $$$p$$$ of length $$$n$$$ consisting of the elements from $$$0$$$ to $$$n-1$$$. You, for some reason, want to figure out the permutation. To do that, you can give Ehab $$$2$$$ different indices $$$i$$$ and $$$j$$$, and he'll reply with $$$(p_i|p_j)$$$ where $$$|$$$ is the bitwise-or operation.Ehab has just enough free time to answer $$$4269$$$ questions, and while he's OK with answering that many questions, he's too lazy to play your silly games, so he'll fix the permutation beforehand and will not change it depending on your queries. Can you guess the permutation?[SOURCE CODE]from random import sample\nimport sys\n\nsys.setrecursionlimit(10 ** 6)\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep=\"\\n\")\ndef II(): return int(sys.stdin.readline())\ndef MI(): return map(int, sys.stdin.readline().split())\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef SI(): return sys.stdin.readline()[:-1]\n\nmemo={}\ndef ask(i,j):\n    if i>j:i,j=j,i\n    if (i,j) in memo:return memo[i,j]\n    print(\"?\",i+1,j+1,flush=True)\n    res=II()\n    memo[i,j]=res\n    return res\n\nn=II()\na,b=0,1\nfor c in sample(range(2,n),n-2):\n    ab=ask(a,b)\n    bc=ask(b,c)\n    if ab==bc:b=c\n    if ab>bc:a=c\n\nab=ask(a,b)\nfor (i,j),v in memo.items():\n    if ab&v!=ab:\n        if i in [a,b]:i=j\n        if i in [a,b]:continue\n        ac = ask(a, i)\n        bc = ask(b, i)\n        if ac < bc: z = a\n        else: z = b\n        break\nelse:\n    for c in sample(range(n),n):\n        if a==c or b==c:continue\n        ac=ask(a,c)\n        bc=ask(b,c)\n        if ac==bc:continue\n        if ac<bc:z=a\n        else:z=b\n        break\n\nans=[]\nfor i in range(n):\n    if i==z:ans.append(0)\n    else:ans.append(ask(z,i))\nprint(\"!\",*ans,flush=True)","tags":["probabilities"],"src_uid":"66e86d612d676068689ae714b453ef32"}
{"text_full":"[DESCRIPTION]There are n incoming messages for Vasya. The i-th message is going to be received after ti minutes. Each message has a cost, which equals to A initially. After being received, the cost of a message decreases by B each minute (it can become negative). Vasya can read any message after receiving it at any moment of time. After reading the message, Vasya's bank account receives the current cost of this message. Initially, Vasya's bank account is at 0.Also, each minute Vasya's bank account receives C·k, where k is the amount of received but unread messages.Vasya's messages are very important to him, and because of that he wants to have all messages read after T minutes.Determine the maximum amount of money Vasya's bank account can hold after T minutes.[SOURCE CODE]n, a, b, c, t = map(int, raw_input().split(\" \"))\nts = map(int, raw_input().split(\" \"))\n\ntotal = a*n\nif b <= c:\n    for i in xrange(n):\n        total += (t-ts[i])*(c-b)\n\nprint total","tags":["math"],"src_uid":"281b95c3686c94ae1c1e4e2a18b7fcc4"}
{"text_full":"[DESCRIPTION]You are given an array $$$a$$$ of length $$$n$$$ that has a special condition: every element in this array has at most 7 divisors. Find the length of the shortest non-empty subsequence of this array product of whose elements is a perfect square.A sequence $$$a$$$ is a subsequence of an array $$$b$$$ if $$$a$$$ can be obtained from $$$b$$$ by deletion of several (possibly, zero or all) elements.[SOURCE CODE]from sys import stdin \nfrom collections import deque, Counter, defaultdict\n\nN = int(input())\narr = list(map(int, stdin.readline().split()))\n\nMAX = 1_000_005\nlp = [0] * MAX\npr = []\npid = {1: 0}\nfor i in range(2, MAX):\n\tif not lp[i]:\n\t\tlp[i] = i\n\t\tpr.append(i)\n\t\tpid[i] = len(pr)\n\tfor p in pr:\n\t\tif p > lp[i] or i * p >= MAX:\n\t\t\tbreak\n\t\tlp[i * p] = p\n\n# lp is sieve, pr is a list of primes, pid is a dictionary keeping track of when the prime appears \nvertex = [[] for i in range(len(pid))]\nfor n in arr:\n\tnew = []\n\twhile n > 1:\n\t\tp, c = lp[n], 0\n\t\twhile lp[n] == p:\n\t\t\tn \/\/= p \n\t\t\tc ^= 1\n\t\tif c:\n\t\t\tnew.append(p)\n\n\tif not new:\n\t\tprint (1)\n\t\texit()\n\n\tnew += [1]*(2 - len(new))\n\tu, v = pid[new[0]], pid[new[1]]\n\tvertex[u].append(v)\n\tvertex[v].append(u)\n\n\ndef bfs_path(s):\n\t# s is the index for the prime number \n\n\tq = deque()\n\tv = [-1]*len(pid)\n\tv[s] = 0\n\tq.append((s, -1))\n\twhile q:\n\t\tc, p = q.pop()\n\n\t\tfor x in vertex[c]:\n\t\t\tif v[x] != -1:\n\t\t\t\tif x != p:\n\t\t\t\t\treturn v[x] + v[c] + 1\n\t\t\telse:\n\t\t\t\tv[x] = v[c] + 1\n\t\t\t\tq.appendleft((x, c))\n\n'''\n\n\tq = deque()\n\tvertices = vertex.keys()\n\tvi = dict(zip(vertices, range(len(vertices))))\n\tdist = [-1]*len(vertices)\n\tq.append(source)\n\tdist[vi[source]] = 0\n\tfar = 0\n\tans = float(\"inf\")\n\tfor v in vertex[source]:\n\t\tq = deque()\n\t\tq.append(v)\n\t\tdist = [-1]*len(vertices)\n\t\tdist[vi[source]] = 0\n\t\tdist[vi[v]] = 1\n\t\twhile len(q):\n\t\t\tcurrent = q.pop()\n\t\t\tfor v in vertex[current]:\n\t\t\t\t# don't want to repeat an edge \n\t\t\t\tif dist[vi[v]] in (-1, 0):\n\t\t\t\t\tif v == end and dist[vi[current]] > 1:\n\t\t\t\t\t\tif dist[vi[current]] + 1 < ans:\n\t\t\t\t\t\t\tans = dist[vi[current]] + 1\n\t\t\t\t\t\tbreak \n\t\t\t\t\telif v != end:\n\t\t\t\t\t\tdist[vi[v]] = dist[vi[current]] + 1\n\t\t\t\t\t\tif dist[vi[v]] - 1 > far:\n\t\t\t\t\t\t\tfar = dist[vi[v]]\n\t\t\t\t\t\tq.appendleft(v)\n\tif ans != float(\"inf\"):\n\t\treturn ans\n\telse:\n\t\treturn 0\n'''\n\n\n\n\nans = N + 1\nfor i in range(len(pid)):\n\tif i > 0 and pr[i - 1] > MAX**0.5:\n\t\tbreak\n\tans = min(ans, bfs_path(i) or ans)\n\nprint (ans if ans <= N else -1)","tags":["graphs","number theory"],"src_uid":"22a43ccaa9e5579dd193bc941855b47d"}
{"text_full":"[DESCRIPTION]Little girl Susie accidentally found her elder brother's notebook. She has many things to do, more important than solving problems, but she found this problem too interesting, so she wanted to know its solution and decided to ask you about it. So, the problem statement is as follows.Let's assume that we are given a connected weighted undirected graph G = (V, E) (here V is the set of vertices, E is the set of edges). The shortest-path tree from vertex u is such graph G1 = (V, E1) that is a tree with the set of edges E1 that is the subset of the set of edges of the initial graph E, and the lengths of the shortest paths from u to any vertex to G and to G1 are the same. You are given a connected weighted undirected graph G and vertex u. Your task is to find the shortest-path tree of the given graph from vertex u, the total weight of whose edges is minimum possible.[SOURCE CODE]import heapq\nn,m = map(int, input().split())\ng = [[] for i in range(n)]\nfor i in range(1,m+1):\n    x,y,z = map(int, input().split())\n    x -= 1\n    y -= 1\n    g[x].append((y,z,i))\n    g[y].append((x,z,i))\nv = int(input())-1\nq = [(0,0,v,0)]\ns = []\nu = [0] * n\na = 0\nwhile len(q) :\n    d,l,x,e = heapq.heappop(q)\n    if not u[x]:\n        u[x] = 1\n        s.append(str(e))\n        a += l\n        for i,k,f in g[x]:\n            if not u[i]:\n                heapq.heappush(q, (d+k,k,i,f))\nprint(a)\nprint(' '.join(s[1:]))","tags":["graphs"],"src_uid":"2232f2a26cb8ff71c1cda10ca0b73bbc"}
{"text_full":"[DESCRIPTION]Polycarp likes to play with numbers. He takes some integer number $$$x$$$, writes it down on the board, and then performs with it $$$n - 1$$$ operations of the two kinds:   divide the number $$$x$$$ by $$$3$$$ ($$$x$$$ must be divisible by $$$3$$$);  multiply the number $$$x$$$ by $$$2$$$. After each operation, Polycarp writes down the result on the board and replaces $$$x$$$ by the result. So there will be $$$n$$$ numbers on the board after all.You are given a sequence of length $$$n$$$ — the numbers that Polycarp wrote down. This sequence is given in arbitrary order, i.e. the order of the sequence can mismatch the order of the numbers written on the board.Your problem is to rearrange (reorder) elements of this sequence in such a way that it can match possible Polycarp's game in the order of the numbers written on the board. I.e. each next number will be exactly two times of the previous number or exactly one third of previous number.It is guaranteed that the answer exists.[SOURCE CODE]def f(n, b, c=0):\n    while n % b == 0:\n        n \/\/= b\n        c += 1\n    return c\nn, a = int(input()), [int(i) for i in input().split()]\nprint(*sorted(a, key = lambda x: (f(x, 2), -f(x, 3))))","tags":["math"],"src_uid":"f9375003a3b64bab17176a05764c20e8"}
{"text_full":"[DESCRIPTION]A tree is an undirected connected graph without cycles.Let's consider a rooted undirected tree with n vertices, numbered 1 through n. There are many ways to represent such a tree. One way is to create an array with n integers p1, p2, ..., pn, where pi denotes a parent of vertex i (here, for convenience a root is considered its own parent).    For this rooted tree the array p is [2, 3, 3, 2]. Given a sequence p1, p2, ..., pn, one is able to restore a tree:  There must be exactly one index r that pr = r. A vertex r is a root of the tree.  For all other n - 1 vertices i, there is an edge between vertex i and vertex pi. A sequence p1, p2, ..., pn is called valid if the described procedure generates some (any) rooted tree. For example, for n = 3 sequences (1,2,2), (2,3,1) and (2,1,3) are not valid.You are given a sequence a1, a2, ..., an, not necessarily valid. Your task is to change the minimum number of elements, in order to get a valid sequence. Print the minimum number of changes and an example of a valid sequence after that number of changes. If there are many valid sequences achievable in the minimum number of changes, print any of them.[SOURCE CODE]n=int(input())\na=list(map(int,input().split()))\npar=[]\nfor i in range(n):\n\tif a[i]==i+1:\n\t\tpar.append(i)\nv=[False for i in range(n)]\nfor i in par:\n\tv[i]=True\nccl=[]\nfor i in range(n):\n\tif v[i]:continue\n\ts=[i]\n\tv[i]=True\n\tp=set(s)\n\tt=True\n\twhile s and t:\n\t\tx=s.pop()\n\t\tj=a[x]-1\n\t\tif j in p:\n\t\t\tccl.append(j)\n\t\t\tt=False\n\t\telse:\n\t\t\ts.append(j)\n\t\t\tp.add(j)\n\t\tif v[j]:t=False\n\t\telse:v[j]=True\nif len(par)==0:\n\tprint(len(ccl))\n\tc=ccl[0]\n\ta[c]=c+1\n\tfor i in range(1,len(ccl)):\n\t\ta[ccl[i]]=c+1\n\tprint(*a)\nelse:\n\tprint(len(ccl)+len(par)-1)\n\tc=par[0]\n\tfor i in range(1,len(par)):\n\t\ta[par[i]]=c+1\n\tfor i in range(len(ccl)):\n\t\ta[ccl[i]]=c+1\n\tprint(*a)","tags":["graphs","trees"],"src_uid":"148a5ecd4afa1c7c60c46d9cb4a57208"}
{"text_full":"[DESCRIPTION]Nudist Beach is planning a military operation to attack the Life Fibers. In this operation, they will attack and capture several cities which are currently under the control of the Life Fibers.There are n cities, labeled from 1 to n, and m bidirectional roads between them. Currently, there are Life Fibers in every city. In addition, there are k cities that are fortresses of the Life Fibers that cannot be captured under any circumstances. So, the Nudist Beach can capture an arbitrary non-empty subset of cities with no fortresses.After the operation, Nudist Beach will have to defend the captured cities from counterattack. If they capture a city and it is connected to many Life Fiber controlled cities, it will be easily defeated. So, Nudist Beach would like to capture a set of cities such that for each captured city the ratio of Nudist Beach controlled neighbors among all neighbors of that city is as high as possible. More formally, they would like to capture a non-empty set of cities S with no fortresses of Life Fibers. The strength of a city  is defined as (number of neighbors of x in S) \/ (total number of neighbors of x). Here, two cities are called neighbors if they are connnected with a road. The goal is to maximize the strength of the weakest city in S.Given a description of the graph, and the cities with fortresses, find a non-empty subset that maximizes the strength of the weakest city.[SOURCE CODE]import heapq\n\ndef read_data():\n    '''\n    n: number of cities\n    m: number of roads\n    k: initial numuber of fortresses of Life Fibers\n    Es: list of edges\n    fs: fs[i] = True -> city i is under control of Life Fibers\n    gs: gs[i] number of edges connected to city i\n    hs: hs[i] number of adjacent cities under control of Life Fibers\n    '''\n    n, m, k = map(int, input().split())\n    Es = [[] for i in range(n)]\n    fs = [False] * n\n    gs = [0.0] * n\n    hs = [0.0] * n\n    fortresses = list(map(int, input().split()))\n    for f in fortresses:\n        fs[f-1] = True\n    for i in range(m):\n        a, b = map(int, input().split())\n        a -= 1\n        b -= 1\n        Es[a].append(b)\n        Es[b].append(a)\n        gs[a] += 1\n        gs[b] += 1\n        hs[a] += fs[b]\n        hs[b] += fs[a]\n    return n, m, k, fs, gs, hs, Es\n\n\ndef solve(n, m, k, fs, gs, hs, Es):\n    hq = [(-h\/g, i) for i, (g, h) in enumerate(zip(gs, hs))]\n    hq.sort()\n    f_diff = set()\n    while hq:\n        p, i = heapq.heappop(hq)\n        if fs[i] or i in f_diff:\n            continue\n        update_fs(fs, f_diff)\n        f_diff = set()\n        dfs(p, i, hq, f_diff, fs, gs, hs, Es)\n    return [i + 1 for i, f in enumerate(fs) if not f]\n\n\ndef update_fs(fs, f_diff):\n    for f in f_diff:\n        fs[f] = True\n\n\ndef dfs(p, i, hq, f_diff, fs, gs, hs, Es):\n    fifo = [i]\n    f_diff.add(i)\n    while fifo:\n        i = fifo.pop(-1)\n        for j in Es[i]:\n            if fs[j] or j in f_diff:\n                continue\n            hs[j] += 1\n            pj = -hs[j]\/gs[j]\n            if pj > p:\n                heapq.heappush(hq, (pj, j))\n            else:\n                fifo.append(j)\n                f_diff.add(j)\n\n\nif __name__ == '__main__':\n    n, m, k, fs, gs, hs, Es = read_data()\n    beaches = solve(n, m, k, fs, gs, hs, Es)\n    print(len(beaches))\n    print(*beaches)","tags":["graphs"],"src_uid":"0dd041c0665d3ec4c46c2c791c17192d"}
{"text_full":"[DESCRIPTION]After the war, the supersonic rocket became the most common public transportation.Each supersonic rocket consists of two \"engines\". Each engine is a set of \"power sources\". The first engine has $$$n$$$ power sources, and the second one has $$$m$$$ power sources. A power source can be described as a point $$$(x_i, y_i)$$$ on a 2-D plane. All points in each engine are different.You can manipulate each engine separately. There are two operations that you can do with each engine. You can do each operation as many times as you want. For every power source as a whole in that engine: $$$(x_i, y_i)$$$ becomes $$$(x_i+a, y_i+b)$$$, $$$a$$$ and $$$b$$$ can be any real numbers. In other words, all power sources will be shifted. For every power source as a whole in that engine: $$$(x_i, y_i)$$$ becomes $$$(x_i \\cos \\theta - y_i \\sin \\theta, x_i \\sin \\theta + y_i \\cos \\theta)$$$, $$$\\theta$$$ can be any real number. In other words, all power sources will be rotated.The engines work as follows: after the two engines are powered, their power sources are being combined (here power sources of different engines may coincide). If two power sources $$$A(x_a, y_a)$$$ and $$$B(x_b, y_b)$$$ exist, then for all real number $$$k$$$ that $$$0 \\lt k \\lt 1$$$, a new power source will be created $$$C_k(kx_a+(1-k)x_b,ky_a+(1-k)y_b)$$$. Then, this procedure will be repeated again with all new and old power sources. After that, the \"power field\" from all power sources will be generated (can be considered as an infinite set of all power sources occurred).A supersonic rocket is \"safe\" if and only if after you manipulate the engines, destroying any power source and then power the engine, the power field generated won't be changed (comparing to the situation where no power source erased). Two power fields are considered the same if and only if any power source in one field belongs to the other one as well.Given a supersonic rocket, check whether it is safe or not.[SOURCE CODE]import sys\n\n\n# > 0 anti-clock, < 0 clockwise, == 0 same line\ndef orientation(p1, p2, p3):\n    return (p2[0] - p1[0])*(p3[1] - p1[1]) - (p2[1] - p1[1])*(p3[0] - p1[0])\n\n\ndef dot(p1, p2, p3, p4):\n    return (p2[0]-p1[0])*(p4[0]-p3[0]) + (p2[1]-p1[1])*(p4[1]-p3[1])\n\n\ndef theta(p1, p2):\n    dx = p2[0] - p1[0]\n    dy = p2[1] - p1[1]\n    if abs(dx) < 0.1 and abs(dy) < 0.1:\n        t = 0\n    else:\n        t = dy\/(abs(dx) + abs(dy))\n        if abs(t) < 0.1 ** 10:\n            t = 0\n    if dx < 0:\n        t = 2 - t\n    elif dy < 0:\n        t = 4 + t\n\n    return t*90\n\n\ndef dist_sq(p1, p2):\n    return (p1[0] - p2[0])*(p1[0] - p2[0]) + (p1[1] - p2[1])*(p1[1] - p2[1])\n\n\ndef chull(points):\n    # let 0 element to be smallest, reorder elements\n    pi = [x for x in range(len(points))]\n    min_y = points[0][1]\n    min_x = points[0][0]\n    min_ind = 0\n    for i in range(len(points)):\n        if points[i][1] < min_y or points[i][1] == min_y and points[i][0] < min_x:\n            min_y = points[i][1]\n            min_x = points[i][0]\n            min_ind = i\n    pi[0] = min_ind\n    pi[min_ind] = 0\n    th = [theta(points[pi[0]], points[x]) for x in range(len(points))]\n    pi.sort(key=lambda x: th[x])\n    # process equals\n    unique = [pi[0], pi[1]]\n    for i in range(2, len(pi)):\n        if th[pi[i]] != th[unique[-1]]:\n            unique.append(pi[i])\n        else:\n            if dist_sq(points[pi[0]], points[unique[-1]]) < dist_sq(points[pi[0]], points[pi[i]]):\n                unique[-1] = pi[i] # put max\n    pi = unique\n    stack = []\n    for i in range(min(len(pi), 3)):\n        stack.append(points[pi[i]])\n    if len(stack) < 3:\n        return stack\n    for i in range(3, len(pi)):\n        while len(stack) >= 2:\n            o = orientation(stack[-2], stack[-1], points[pi[i]])\n            if o > 0:\n                stack.append(points[pi[i]])\n                break\n            elif o < 0:\n                stack.pop()\n            else:  # ==\n                if dist_sq(stack[-2], stack[-1]) < dist_sq(stack[-2], points[pi[i]]):\n                    stack.pop()\n                else:\n                    break  # skip i-th point\n    return stack\n\n\ndef z_func(s):\n    slen, l, r = len(s), 0, 0\n    z = [0]*slen\n    z[0] = slen\n    for i in range(1, slen):\n        if i <= r: z[i] = min(r-i+1, z[i-l])\n        while i+z[i] < slen and s[z[i]] == s[i+z[i]]: z[i] += 1\n        if i+z[i]-1 > r: l, r = i, i+z[i]-1\n    return z\n\nn,m = map(int, sys.stdin.readline().strip().split())\na = []\nfor _ in range(n):\n    x,y = map(int, sys.stdin.readline().strip().split())\n    a.append((x, y))\nb = []\nfor _ in range(m):\n    x, y = map(int, sys.stdin.readline().strip().split())\n    b.append((x, y))\n\nah = chull(a)\nbh = chull(b)\nif len(ah) == len(bh):\n    if len(ah) == 2:\n        if dist_sq(ah[0], ah[1]) == dist_sq(bh[0], bh[1]):\n            print('YES')\n        else:\n            print('NO')\n    else:\n        da = []\n        for i in range(len(ah)):\n            dot_a = dot(ah[i-2], ah[i-1], ah[i-1], ah[i])\n            da.append((dist_sq(ah[i], ah[i-1]), dot_a))\n        db = []\n        for i in range(len(bh)):\n            dot_b = dot(bh[i - 2], bh[i - 1], bh[i - 1], bh[i])\n            db.append((dist_sq(bh[i], bh[i-1]), dot_b))\n        l = r = 0\n        daab = []\n        daab.extend(db)\n        daab.append(-1)\n        daab.extend(da)\n        daab.extend(da)\n        zab = z_func(daab)\n        found = False\n        for i in range(len(db)+1, len(daab)-len(db)+1):\n            if zab[i] == len(db):\n                found = True\n                break\n        if found:\n            print('YES')\n        else:\n            print('NO')\nelse:\n    print('NO')","tags":["geometry","strings"],"src_uid":"aeda11f32911d256fb6263635b738e99"}
{"text_full":"[DESCRIPTION]One night, having had a hard day at work, Petya saw a nightmare. There was a binary search tree in the dream. But it was not the actual tree that scared Petya. The horrifying thing was that Petya couldn't search for elements in this tree. Petya tried many times to choose key and look for it in the tree, and each time he arrived at a wrong place. Petya has been racking his brains for long, choosing keys many times, but the result was no better. But the moment before Petya would start to despair, he had an epiphany: every time he was looking for keys, the tree didn't have the key, and occured exactly one mistake. \"That's not a problem!\", thought Petya. \"Why not count the expectation value of an element, which is found when I search for the key\". The moment he was about to do just that, however, Petya suddenly woke up.Thus, you are given a binary search tree, that is a tree containing some number written in the node. This number is called the node key. The number of children of every node of the tree is equal either to 0 or to 2. The nodes that have 0 children are called leaves and the nodes that have 2 children, are called inner. An inner node has the left child, that is the child whose key is less than the current node's key, and the right child, whose key is more than the current node's key. Also, a key of any node is strictly larger than all the keys of the left subtree of the node and strictly smaller than all the keys of the right subtree of the node.Also you are given a set of search keys, all of which are distinct and differ from the node keys contained in the tree. For each key from the set its search in the tree is realised. The search is arranged like this: initially we are located in the tree root, if the key of the current node is larger that our search key, then we move to the left child of the node, otherwise we go to the right child of the node and the process is repeated. As it is guaranteed that the search key is not contained in the tree, the search will always finish in some leaf. The key lying in the leaf is declared the search result.It is known for sure that during the search we make a mistake in comparing exactly once, that is we go the wrong way, but we won't make any mistakes later. All possible mistakes are equiprobable, that is we should consider all such searches where exactly one mistake occurs. Your task is to find the expectation (the average value) of the search result for every search key, considering that exactly one mistake occurs in the search. That is, for a set of paths containing exactly one mistake in the given key search, you should count the average value of keys containing in the leaves of those paths.[SOURCE CODE]from bisect import bisect_left as bl\nn = input()\nn+=1\nk = [0]*n\np = [0]*n\nma = [0]*n\nmi = [0]*n\nl = [0]*n\nr = [0]*n\nfor i in xrange(1,n):\n    pp,kk = map(int,raw_input().split())\n    p[i] = pp\n    ma[i] = mi[i] = k[i] = kk\nkn = input()\nfor i in xrange(1,n):\n    if p[i]<0: continue    \n    if k[p[i]]<k[i]: r[p[i]]=i\n    else: l[p[i]]=i\nq = [i for i in xrange(1,n) if not l[i]]\nv = [False]*n\nfor x in q: v[x] = True\nfor x in q:\n    if p[x]<0: continue\n    if v[p[x]]: continue\n    if l[p[x]] and (not v[l[p[x]]] or not v[r[p[x]]]): continue\n    v[p[x]] = True\n    q.append(p[x])\nfor i in q:\n    if not l[i]: continue\n    ma[i]=ma[r[i]]\n    mi[i]=mi[l[i]]\n    #ma[p[i]]=max(ma[p[i]],ma[i])\n    #mi[p[i]]=min(mi[p[i]],mi[i])\nen = [0]*n\nex = [0.]*n\nfor i in reversed(q):\n    if not l[i]: continue\n    en[r[i]]=en[l[i]]=en[i]+1\n    ex[l[i]]=ex[i]+mi[r[i]]\n    ex[r[i]]=ex[i]+ma[l[i]]\nk[0]=-1\nkp = [(v,i) for i,v in enumerate(k)]\nkp.sort()\nkpv = [x for x,y in kp]\nkpi = [y for x,y in kp]\nfor _ in xrange(kn):\n    x = input()\n    p = bl(kpv,x)-1\n    e = kpi[p]\n    if p<n-1:\n        if not e or l[e]:\n            e = kpi[p+1]\n    if l[e]: raise NotImplemented\n    print \"%.10f\"%(1.*ex[e]\/en[e])","tags":["probabilities","trees"],"src_uid":"afe77e7b2dd6d7940520d9844ab30cfd"}
{"text_full":"[DESCRIPTION]Valera has array a, consisting of n integers a0, a1, ..., an - 1, and function f(x), taking an integer from 0 to 2n - 1 as its single argument. Value f(x) is calculated by formula , where value bit(i) equals one if the binary representation of number x contains a 1 on the i-th position, and zero otherwise.For example, if n = 4 and x = 11 (11 = 20 + 21 + 23), then f(x) = a0 + a1 + a3.Help Valera find the maximum of function f(x) among all x, for which an inequality holds: 0 ≤ x ≤ m.[SOURCE CODE]m = int(input())\nlistValue = input().split()\nx = input().rstrip('\\n')\n\nvalues = [int(v) for v in listValue]\nreverse_x = list(x)\nreverse_int = [int(s) for s in reverse_x]\nreverse_list = [0] * m\nsum_list = 0\nfor i in range(m):\n    if reverse_x[i] == '1':\n        reverse_list[i] = max(reverse_list[i - 1] + values[i], sum_list)\n    else:\n        reverse_list[i] = reverse_list[i - 1]\n    sum_list += values[i]\n\nprint(reverse_list[-1])","tags":["number theory","math"],"src_uid":"9366e1626b33b4f4e49cf35200c0448f"}
{"text_full":"[DESCRIPTION]The Physical education teacher at SESC is a sort of mathematician too. His most favorite topic in mathematics is progressions. That is why the teacher wants the students lined up in non-decreasing height form an arithmetic progression.To achieve the goal, the gym teacher ordered a lot of magical buns from the dining room. The magic buns come in two types: when a student eats one magic bun of the first type, his height increases by one, when the student eats one magical bun of the second type, his height decreases by one. The physical education teacher, as expected, cares about the health of his students, so he does not want them to eat a lot of buns. More precisely, he wants the maximum number of buns eaten by some student to be minimum.Help the teacher, get the maximum number of buns that some pupils will have to eat to achieve the goal of the teacher. Also, get one of the possible ways for achieving the objective, namely, the height of the lowest student in the end and the step of the resulting progression.[SOURCE CODE]q = 10001\nn, a = int(input()), list(map(int, input().split()))\na.sort()\nfor i in range(40000 \/\/ (n - 1) + 1):\n    b = [a[j] - j * i for j in range(n)]\n    u, v = max(b), min(b)\n    p = (u - v + 1) \/\/ 2\n    if p < q: q, s, d = p, v + p, i\nprint(q)\nprint(s, d)","tags":["math"],"src_uid":"e46cfa0cf3b630516e7d7d056d79f114"}
{"text_full":"[DESCRIPTION]Misha walked through the snowy forest and he was so fascinated by the trees to decide to draw his own tree!Misha would like to construct a rooted tree with $$$n$$$ vertices, indexed from 1 to $$$n$$$, where the root has index 1. Every other vertex has a parent $$$p_i$$$, and $$$i$$$ is called a child of vertex $$$p_i$$$. Vertex $$$u$$$ belongs to the subtree of vertex $$$v$$$ iff $$$v$$$ is reachable from $$$u$$$ while iterating over the parents ($$$u$$$, $$$p_{u}$$$, $$$p_{p_{u}}$$$, ...). Clearly, $$$v$$$ belongs to its own subtree, and the number of vertices in the subtree is called the size of the subtree. Misha is only interested in trees where every vertex belongs to the subtree of vertex $$$1$$$.Below there is a tree with $$$6$$$ vertices. The subtree of vertex $$$2$$$ contains vertices $$$2$$$, $$$3$$$, $$$4$$$, $$$5$$$. Hence the size of its subtree is $$$4$$$.   The branching coefficient of the tree is defined as the maximum number of children in any vertex. For example, for the tree above the branching coefficient equals $$$2$$$. Your task is to construct a tree with $$$n$$$ vertices such that the sum of the subtree sizes for all vertices equals $$$s$$$, and the branching coefficient is minimum possible.[SOURCE CODE]import math\ndef f(n,k):\n    if k==1:\n        return (n*(n+1))\/\/2\n    a=math.floor(math.log(n,k))\n    b=sum(k**i for i in range(a+1))\n    c=sum((i+1)*k**i for i in range(a+1))\n    if n<b:\n        return c-(b-n)*(a+1)\n    else:\n        return c+(n-b)*(a+2)\nn,s=map(int,input().split())\nif s==(n*(n+1))\/\/2:\n    print(\"Yes\")\n    a=[str(i+1) for i in range(n-1)]\n    print(\" \".join(a))\nelif s>(n*(n+1))\/\/2:\n    print(\"No\")\nelif s<2*n-1:\n    print(\"No\")\nelse:\n    mini=1\n    maxi=n-1\n    curr=1\n    while True:\n        a,b=f(n,curr),f(n,curr+1)\n        if b>s:\n            mini=curr+1\n            curr=math.ceil((curr+maxi)\/2)\n        elif a<=s:\n            maxi=curr-1\n            curr=(curr+mini)\/\/2\n        else:\n            opt=curr+1\n            break\n    depths=[0,1]+[0]*(n-1)\n    ins=1\n    ind=2\n    while True:\n        a=min(opt**(ind-1),n-ins)\n        depths[ind]=a\n        ind+=1\n        ins+=a\n        if ins==n:\n            break\n    left=s-b\n    far=ind-1\n    bulk=ind-1\n    if depths[bulk]==1:\n        bulk-=1\n    while left>0:\n        if far+1-bulk<=left:\n            far+=1\n            left-=far-bulk\n            depths[far]+=1\n            depths[bulk]-=1\n            if depths[bulk]==1:\n                bulk-=1\n        else:\n            depths[bulk]-=1\n            depths[bulk+left]+=1\n            left=0\n    verts=[None]*far\n    sumi=0\n    for i in range(far):\n        verts[i]=list(range(sumi+1,sumi+1+depths[i+1]))\n        sumi+=depths[i+1]\n    out=\"\"\n    for i in range(1,far):\n        for j in range(len(verts[i])):\n            out+=str(verts[i-1][j\/\/opt])+\" \"\n    print(\"Yes\")\n    print(out)","tags":["graphs","trees"],"src_uid":"9abcb5481648a6485a818946f8f94d1d"}
{"text_full":"[DESCRIPTION]You are given an infinite periodic array a0, a1, ..., an - 1, ... with the period of length n. Formally, . A periodic subarray (l, s) (0 ≤ l &lt; n, 1 ≤ s &lt; n) of array a is an infinite periodic array with a period of length s that is a subsegment of array a, starting with position l.A periodic subarray (l, s) is superior, if when attaching it to the array a, starting from index l, any element of the subarray is larger than or equal to the corresponding element of array a. An example of attaching is given on the figure (top — infinite array a, bottom — its periodic subarray (l, s)):  Find the number of distinct pairs (l, s), corresponding to the superior periodic arrays.[SOURCE CODE]# -*- coding: utf-8 -*-\nimport fractions\nfrom collections import defaultdict\n\n\nif __name__ == '__main__':\n    n = int(raw_input())\n    a = map(int, raw_input().split())\n    a *= 2\n    inf = min(a) - 1\n    a[-1] = inf\n    result = 0\n\n    numbers_by_gcd = defaultdict(list)\n    for i in xrange(1, n):\n        numbers_by_gcd[fractions.gcd(i, n)].append(i)\n\n    for d in xrange(1, n):\n        if n % d != 0:\n            continue\n        m = [inf] * d\n        for i in xrange(n):\n            if a[i] > m[i % d]:\n                m[i % d] = a[i]\n        l = 0\n        r = 0\n        while l < n:\n            if a[r] < m[r % d]:\n                for i in numbers_by_gcd[d]:\n                    if i > r - l:\n                        break\n                    result += min(r - i, n - 1) - l + 1\n                l = r + 1\n            r += 1\n    print result","tags":["number theory"],"src_uid":"393ed779ea3ca8fdb63e8de1293eecd3"}
{"text_full":"[DESCRIPTION]Kuro has just learned about permutations and he is really excited to create a new permutation type. He has chosen $$$n$$$ distinct positive integers and put all of them in a set $$$S$$$. Now he defines a magical permutation to be: A permutation of integers from $$$0$$$ to $$$2^x - 1$$$, where $$$x$$$ is a non-negative integer.  The bitwise xor of any two consecutive elements in the permutation is an element in $$$S$$$.Since Kuro is really excited about magical permutations, he wants to create the longest magical permutation possible. In other words, he wants to find the largest non-negative integer $$$x$$$ such that there is a magical permutation of integers from $$$0$$$ to $$$2^x - 1$$$. Since he is a newbie in the subject, he wants you to help him find this value of $$$x$$$ and also the magical permutation for that $$$x$$$.[SOURCE CODE]def size(k):\n    return int(math.log2(k))\ndef v2(k):\n    if k%2==1:\n        return 0\n    else:\n        return 1+v2(k\/\/2)\nn=int(input())\ns=list(map(int,input().split()))\nimport math\ns.sort()\nused=[]\nuse=0\nfound={0:1}\ngood=0\nfor guy in s:\n    big=size(guy)\n    if guy not in found:\n        used.append(guy)\n        use+=1\n        new=[]\n        for boi in found:\n            new.append(boi^guy)\n        for guy in new:\n            found[guy]=1\n        if use==big+1:\n            good=use\nif good==0:\n    print(0)\n    print(0)\nelse:\n    useful=used[:good]\n    perm=[\"0\"]\n    curr=0\n    for i in range(2**good-1):\n        curr^=useful[v2(i+1)]\n        perm.append(str(curr))\n    print(good)\n    print(\" \".join(perm))","tags":["graphs","math"],"src_uid":"6b6231465a34d1585c356280802b2a88"}
{"text_full":"[DESCRIPTION]You are given a string $$$s$$$. Each character is either 0 or 1.You want all 1's in the string to form a contiguous subsegment. For example, if the string is 0, 1, 00111 or 01111100, then all 1's form a contiguous subsegment, and if the string is 0101, 100001 or 11111111111101, then this condition is not met.You may erase some (possibly none) 0's from the string. What is the minimum number of 0's that you have to erase?[SOURCE CODE]for _ in range(int(input())):\n    s = str(input())\n    n = len(s)\n    print(s.strip('0').count('0'))","tags":["strings"],"src_uid":"5de66fbb594bb317654366fd2290c4d3"}
{"text_full":"[DESCRIPTION]Lindsey Buckingham told Stevie Nicks \"Go your own way\". Nicks is now sad and wants to go away as quickly as possible, but she lives in a 2D hexagonal world.Consider a hexagonal tiling of the plane as on the picture below.  Nicks wishes to go from the cell marked $$$(0, 0)$$$ to a certain cell given by the coordinates. She may go from a hexagon to any of its six neighbors you want, but there is a cost associated with each of them. The costs depend only on the direction in which you travel. Going from $$$(0, 0)$$$ to $$$(1, 1)$$$ will take the exact same cost as going from $$$(-2, -1)$$$ to $$$(-1, 0)$$$. The costs are given in the input in the order $$$c_1$$$, $$$c_2$$$, $$$c_3$$$, $$$c_4$$$, $$$c_5$$$, $$$c_6$$$ as in the picture below.  Print the smallest cost of a path from the origin which has coordinates $$$(0, 0)$$$ to the given cell.[SOURCE CODE]import sys\ninput = sys.stdin.readline\n\ndef main():\n    x, y = map(int, input().split())\n    clst = list(map(int, input().split()))\n    clst[0] = min(clst[0], clst[5] + clst[1])\n    clst[1] = min(clst[1], clst[0] + clst[2])\n    clst[2] = min(clst[2], clst[1] + clst[3])\n    clst[3] = min(clst[3], clst[2] + clst[4])\n    clst[4] = min(clst[4], clst[3] + clst[5])\n    clst[5] = min(clst[5], clst[4] + clst[0])\n    directions = [(1, 1), (0, 1), (-1, 0), (-1, -1), (0, -1), (1, 0)]\n    ans = 10 ** 20\n    for i in range(6):\n        dx1, dy1 = directions[i]\n        dx2, dy2 = directions[(i + 1) % 6]\n        a = (x * dy2 - y * dx2) \/\/ (dx1 * dy2 - dy1 * dx2)\n        b = (x * dy1 - y * dx1) \/\/ (dx2 * dy1 - dy2 * dx1)\n        if a < 0 or b < 0:\n            continue\n        ans = min(ans, clst[i] * a + clst[(i + 1) % 6] * b)\n    print(ans)\n    \nfor _ in range(int(input())):\n    main()","tags":["math"],"src_uid":"7e6bc93543ad7bf80a019559b7bf99e0"}
{"text_full":"[DESCRIPTION]After observing the results of Spy Syndrome, Yash realised the errors of his ways. He now believes that a super spy such as Siddhant can't use a cipher as basic and ancient as Caesar cipher. After many weeks of observation of Siddhant’s sentences, Yash determined a new cipher technique.For a given sentence, the cipher is processed as:   Convert all letters of the sentence to lowercase.  Reverse each of the words of the sentence individually.  Remove all the spaces in the sentence. For example, when this cipher is applied to the sentenceKira is childish and he hates losingthe resulting string isariksihsidlihcdnaehsetahgnisolNow Yash is given some ciphered string and a list of words. Help him to find out any original sentence composed using only words from the list. Note, that any of the given words could be used in the sentence multiple times.[SOURCE CODE]#!\/usr\/bin\/env python3\n\n# http:\/\/codeforces.com\/contest\/633\/problem\/C\n\nfrom collections import deque\n\n# import sys\n# sys.setrecursionlimit(10001)\n\nn = int(input())\ns = input()\nm = int(input())\nwords = []\nfor i in range(0, m):\n    words.append(input())\n\ndict_words = {}\nfor word in words:\n    dict_words[word.lower()[::-1]] = word\n\ntrie_words = {}\nfor word in dict_words.keys():\n    d = trie_words\n    for letter in word:\n        d = d.setdefault(letter, {})\n    d['word'] = word\n\ndef find_sentence(s):\n    # stack = [0, '', dict_words, []] # position, used words so far, pos in trie we stopped on, children\n    roots = deque() # position, used words so far, pos in trie we stopped on, children\n\n    d = trie_words\n    for i in range(0, len(s)):\n        if not s[i] in d:\n            break;\n        d = d[s[i]]\n        if 'word' in d:\n            word = d['word']\n            new_root = [i + 1, word, None]\n            roots.append(new_root)\n            if i + 1 == len(s):\n                return new_root\n\n    while len(roots) > 0:\n        root = roots.popleft()\n        d = trie_words\n\n        for i in range(root[0], len(s)):\n            if not s[i] in d:\n                break;\n            d = d[s[i]]\n            if 'word' in d:\n                word = d['word']\n                new_root = [i + 1, word, root]\n                roots.appendleft(new_root)\n                if i + 1 == len(s):\n                    return new_root\n\nresult = find_sentence(s)\nwords = []\nwhile not result is None:\n    word = result[1]\n    words.append(dict_words[word])\n    result = result[2]\nprint(' '.join(reversed(words)))","tags":["strings"],"src_uid":"5d3fc6a6c4f53d53c38ab4387282a55c"}
{"text_full":"[DESCRIPTION]The problem was inspired by Pied Piper story. After a challenge from Hooli's compression competitor Nucleus, Richard pulled an all-nighter to invent a new approach to compression: middle-out.You are given two strings $$$s$$$ and $$$t$$$ of the same length $$$n$$$. Their characters are numbered from $$$1$$$ to $$$n$$$ from left to right (i.e. from the beginning to the end).In a single move you can do the following sequence of actions:  choose any valid index $$$i$$$ ($$$1 \\le i \\le n$$$),  move the $$$i$$$-th character of $$$s$$$ from its position to the beginning of the string or move the $$$i$$$-th character of $$$s$$$ from its position to the end of the string. Note, that the moves don't change the length of the string $$$s$$$. You can apply a move only to the string $$$s$$$.For example, if $$$s=$$$\"test\" in one move you can obtain:  if $$$i=1$$$ and you move to the beginning, then the result is \"test\" (the string doesn't change),  if $$$i=2$$$ and you move to the beginning, then the result is \"etst\",  if $$$i=3$$$ and you move to the beginning, then the result is \"stet\",  if $$$i=4$$$ and you move to the beginning, then the result is \"ttes\",  if $$$i=1$$$ and you move to the end, then the result is \"estt\",  if $$$i=2$$$ and you move to the end, then the result is \"tste\",  if $$$i=3$$$ and you move to the end, then the result is \"tets\",  if $$$i=4$$$ and you move to the end, then the result is \"test\" (the string doesn't change). You want to make the string $$$s$$$ equal to the string $$$t$$$. What is the minimum number of moves you need? If it is impossible to transform $$$s$$$ to $$$t$$$, print -1.[SOURCE CODE]q = int(input())\nfor x in range(q):   \n    n = int(input())\n    s = str(input())\n    t = str(input())\n    ss = sorted(s)\n    tt = sorted(t)\n    if ss != tt:\n        ans = -1\n    else:\n        ans = 1000000000\n        for i in range(n):\n            k = i\n            for j in range(n):\n                if k < n and s[j] == t[k]:\n                    k+=1\n                ans = min(ans, n - k + i)\n    print(ans)","tags":["strings"],"src_uid":"09eaa5ce235350bbc1a3d52441472c37"}
{"text_full":"[DESCRIPTION]The board has got a painted tree graph, consisting of n nodes. Let us remind you that a non-directed graph is called a tree if it is connected and doesn't contain any cycles.Each node of the graph is painted black or white in such a manner that there aren't two nodes of the same color, connected by an edge. Each edge contains its value written on it as a non-negative integer.A bad boy Vasya came up to the board and wrote number sv near each node v — the sum of values of all edges that are incident to this node. Then Vasya removed the edges and their values from the board.Your task is to restore the original tree by the node colors and numbers sv.[SOURCE CODE]n = input()\na = []\nb = []\nfor i in range(n):\n\tc, s = map(int, raw_input().split())\n\t[a, b][c] += [[s, i + 1]]\nr = []\nfor _ in range(1, n):\n\ts, i = a[-1]\n\tS, I = b[-1]\n\tv = min(s, S)\n\ta[-1][0] -= v\n\tb[-1][0] -= v\n\tr += [[i, I, v]]\n\t[b, a][s < S or s == S and len(a) > 1].pop()\nprint '\\n'.join(' '.join(map(str, x)) for x in r)","tags":["graphs","trees"],"src_uid":"b1ece35f190b13a3dfd64ab30c905765"}
{"text_full":"[DESCRIPTION]You are given a rooted tree on $$$n$$$ vertices, its root is the vertex number $$$1$$$. The $$$i$$$-th vertex contains a number $$$w_i$$$. Split it into the minimum possible number of vertical paths in such a way that each path contains no more than $$$L$$$ vertices and the sum of integers $$$w_i$$$ on each path does not exceed $$$S$$$. Each vertex should belong to exactly one path.A vertical path is a sequence of vertices $$$v_1, v_2, \\ldots, v_k$$$ where $$$v_i$$$ ($$$i \\ge 2$$$) is the parent of $$$v_{i - 1}$$$.[SOURCE CODE]def solve(n, l, s, www, children):\n    ans = 0\n    dp = [{} for _ in range(n)]\n    for v in range(n - 1, -1, -1):\n        cv = children[v]\n        if not cv:\n            dp[v][1] = www[v]\n            continue\n        ans += len(cv) - 1\n        wv = www[v]\n        if wv > s:\n            return -1\n        dv = dp[v]\n        for c in cv:\n            for lc, wc in dp[c].items():\n                if lc == l:\n                    continue\n                wt = wc + wv\n                if wt > s:\n                    continue\n                if lc + 1 not in dv:\n                    dv[lc + 1] = wt\n                else:\n                    dv[lc + 1] = min(dv[lc + 1], wt)\n        if not dv:\n            ans += 1\n            dv[1] = wv\n\n    return ans + 1\n\n\nn, l, s = list(map(int, input().split()))\nwww = list(map(int, input().split()))\nif n == 1:\n    print(-1 if www[0] > s else 1)\n    exit()\nchildren = [set() for _ in range(n)]\nfor i, p in enumerate(map(int, input().split())):\n    children[p - 1].add(i + 1)\nprint(solve(n, l, s, www, children))","tags":["trees"],"src_uid":"07600ef3a0e1d216699648b2d17189e8"}
{"text_full":"[DESCRIPTION]Tomash keeps wandering off and getting lost while he is walking along the streets of Berland. It's no surprise! In his home town, for any pair of intersections there is exactly one way to walk from one intersection to the other one. The capital of Berland is very different!Tomash has noticed that even simple cases of ambiguity confuse him. So, when he sees a group of four distinct intersections a, b, c and d, such that there are two paths from a to c — one through b and the other one through d, he calls the group a \"damn rhombus\". Note that pairs (a, b), (b, c), (a, d), (d, c) should be directly connected by the roads. Schematically, a damn rhombus is shown on the figure below:  Other roads between any of the intersections don't make the rhombus any more appealing to Tomash, so the four intersections remain a \"damn rhombus\" for him.Given that the capital of Berland has n intersections and m roads and all roads are unidirectional and are known in advance, find the number of \"damn rhombi\" in the city.When rhombi are compared, the order of intersections b and d doesn't matter.[SOURCE CODE]from __future__ import division, print_function\nimport bisect\nimport math\nimport itertools\nimport sys\nfrom atexit import register\n \nif sys.version_info[0] < 3:\n    from io import BytesIO as stream\nelse:\n    from io import StringIO as stream\n \n \nif sys.version_info[0] < 3:\n    class dict(dict):\n        \"\"\"dict() -> new empty dictionary\"\"\"\n        def items(self):\n            \"\"\"D.items() -> a set-like object providing a view on D's items\"\"\"\n            return dict.iteritems(self)\n \n        def keys(self):\n            \"\"\"D.keys() -> a set-like object providing a view on D's keys\"\"\"\n            return dict.iterkeys(self)\n \n        def values(self):\n            \"\"\"D.values() -> an object providing a view on D's values\"\"\"\n            return dict.itervalues(self)\n \n    input = raw_input\n    range = xrange\n \n    filter = itertools.ifilter\n    map = itertools.imap\n    zip = itertools.izip\n \n \ndef sync_with_stdio(sync=True):\n    \"\"\"Set whether the standard Python streams are allowed to buffer their I\/O.\n \n    Args:\n        sync (bool, optional): The new synchronization setting.\n \n    \"\"\"\n    global input, flush\n \n    if sync:\n        flush = sys.stdout.flush\n    else:\n        sys.stdin = stream(sys.stdin.read())\n        input = lambda: sys.stdin.readline().rstrip('\\r\\n')\n \n        sys.stdout = stream()\n        register(lambda: sys.__stdout__.write(sys.stdout.getvalue()))\n \ndef main():\n    \n\n    g=[]\n    n,m=map(int, input().split())\n    for i in range(n):\n        g.append([])\n    for j in range(m):\n        p,q=map(int, input().split())\n        g[p-1].append(q)\n    cnt=0\n    #print(g)\n    for i in range(n):\n        a=[0]*n\n        for j in range(len(g[i])):\n            for k in range(len(g[g[i][j]-1])):\n                a[g[g[i][j]-1][k]-1]+=1\n        #print(a)        \n        for t in range(n):\n            if t==i:\n                continue\n            j=a[t]\n            if j>1:\n                cnt+=(((j-1)*j)\/\/2)\n    print(cnt)            \n        \nif __name__ == '__main__':\n    sync_with_stdio(False)\n    main()","tags":["graphs"],"src_uid":"6e85f83d544eeb16f57523eb532abf04"}
{"text_full":"[DESCRIPTION]Roman planted a tree consisting of n vertices. Each vertex contains a lowercase English letter. Vertex 1 is the root of the tree, each of the n - 1 remaining vertices has a parent in the tree. Vertex is connected with its parent by an edge. The parent of vertex i is vertex pi, the parent index is always less than the index of the vertex (i.e., pi &lt; i).The depth of the vertex is the number of nodes on the path from the root to v along the edges. In particular, the depth of the root is equal to 1.We say that vertex u is in the subtree of vertex v, if we can get from u to v, moving from the vertex to the parent. In particular, vertex v is in its subtree.Roma gives you m queries, the i-th of which consists of two numbers vi, hi. Let's consider the vertices in the subtree vi located at depth hi. Determine whether you can use the letters written at these vertices to make a string that is a palindrome. The letters that are written in the vertexes, can be rearranged in any order to make a palindrome, but all letters should be used.[SOURCE CODE]from sys import stdin, stdout\nfrom itertools import repeat\ndef main():\n    n, m = map(int, stdin.readline().split())\n    a = map(int, stdin.readline().split(), repeat(10, n - 1))\n    last = [None] * (n + 10)\n    ne = [None] * (n + 10)\n    for i, x in enumerate(a, 2):\n        ne[i] = last[x]\n        last[x] = i\n    s = 'a' + stdin.readline().strip()\n    dat = map(int, stdin.read().split(), repeat(10, 2 * m))\n    h = dat[1::2]\n    lst = [None] * (n + 10)\n    xt = [None] * (m + 10)\n    for i, v in enumerate(dat[::2]):\n        xt[i] = lst[v]\n        lst[v] = i\n    di = {chr(ord('a') + i): 2 ** i for i in xrange(26)}\n    b = [0] * (n + 10)\n    res = [0] * m\n    st = [(1, 1)]\n    po = st.pop\n    pu = st.append\n    pe = st.extend\n    while st:\n        x, d = po()\n        if d:\n            pu((x, 0))\n            i = lst[x]\n            while i is not None:\n                res[i] ^= b[h[i]]\n                i = xt[i]\n            b[d] ^= di[s[x]]\n            d += 1\n            i = last[x]\n            while i is not None:\n                pu((i, d))\n                i = ne[i]\n        else:\n            i = lst[x]\n            while i is not None:\n                res[i] ^= b[h[i]]\n                i = xt[i]\n    ok = set(2 ** i for i in xrange(26))\n    ok.add(0)\n    ok = frozenset(ok)\n    res = [\"Yes\" if x in ok else \"No\" for x in res]\n    stdout.write('\\n'.join(res))\nmain()","tags":["graphs","trees"],"src_uid":"4c4ac8933f244b6ccd8b2a0bb9b254b7"}
{"text_full":"[DESCRIPTION]Amugae has a sentence consisting of $$$n$$$ words. He want to compress this sentence into one word. Amugae doesn't like repetitions, so when he merges two words into one word, he removes the longest prefix of the second word that coincides with a suffix of the first word. For example, he merges \"sample\" and \"please\" into \"samplease\".Amugae will merge his sentence left to right (i.e. first merge the first two words, then merge the result with the third word and so on). Write a program that prints the compressed word after the merging process ends.[SOURCE CODE]def kmp(s):\n    i,j = -1,0\n    fail    = [0]*len(s)\n    while j < len(s):\n        if i == -1 or s[j] == s[i]:\n            fail[j] = i\n            j   += 1\n            i   += 1\n        else:\n            i   = -1 if i == 0 else fail[i-1]+1\n    return fail[-1]+1\nn       = input()\nwords   = raw_input().split(\" \")\nout     = words[0]\nfor word in words[1:]:\n    com = min(len(word),len(out))\n    l   = kmp(word+\"_\"+out[-com:])\n    out += word[l:]\nprint out","tags":["strings"],"src_uid":"586341bdd33b1dc3ab8e7f9865b5f6f6"}
{"text_full":"[DESCRIPTION]We know that prime numbers are positive integers that have exactly two distinct positive divisors. Similarly, we'll call a positive integer t Т-prime, if t has exactly three distinct positive divisors.You are given an array of n positive integers. For each of them determine whether it is Т-prime or not.[SOURCE CODE]from math import sqrt\nn = int(input())\ns = [int(i) for i in input().split()]\nd = [1]*1000002\ne = set()\nfor i in range(2,1000002):\n\tif d[i]:\n\t\te.add(i**2)\n\t\tfor j in range(i**2,1000002,i):\n\t\t\td[j]=0\nfor i in range(n):\n\tif s[i] in e:\n\t\tprint(\"YES\")\n\telse:\n\t\tprint(\"NO\")","tags":["number theory","math"],"src_uid":"6cebf9af5cfbb949f22e8b336bf07044"}
{"text_full":"[DESCRIPTION]A permutation is a sequence of integers from $$$1$$$ to $$$n$$$ of length $$$n$$$ containing each number exactly once. For example, $$$[1]$$$, $$$[4, 3, 5, 1, 2]$$$, $$$[3, 2, 1]$$$ — are permutations, and $$$[1, 1]$$$, $$$[4, 3, 1]$$$, $$$[2, 3, 4]$$$ — no.Permutation $$$a$$$ is lexicographically smaller than permutation $$$b$$$ (they have the same length $$$n$$$), if in the first index $$$i$$$ in which they differ, $$$a[i] &lt; b[i]$$$. For example, the permutation $$$[1, 3, 2, 4]$$$ is lexicographically smaller than the permutation $$$[1, 3, 4, 2]$$$, because the first two elements are equal, and the third element in the first permutation is smaller than in the second.The next permutation for a permutation $$$a$$$ of length $$$n$$$ — is the lexicographically smallest permutation $$$b$$$ of length $$$n$$$ that lexicographically larger than $$$a$$$. For example:   for permutation $$$[2, 1, 4, 3]$$$ the next permutation is $$$[2, 3, 1, 4]$$$;  for permutation $$$[1, 2, 3]$$$ the next permutation is $$$[1, 3, 2]$$$;  for permutation $$$[2, 1]$$$ next permutation does not exist. You are given the number $$$n$$$ — the length of the initial permutation. The initial permutation has the form $$$a = [1, 2, \\ldots, n]$$$. In other words, $$$a[i] = i$$$ ($$$1 \\le i \\le n$$$).You need to process $$$q$$$ queries of two types:   $$$1$$$ $$$l$$$ $$$r$$$: query for the sum of all elements on the segment $$$[l, r]$$$. More formally, you need to find $$$a[l] + a[l + 1] + \\ldots + a[r]$$$.  $$$2$$$ $$$x$$$: $$$x$$$ times replace the current permutation with the next permutation. For example, if $$$x=2$$$ and the current permutation has the form $$$[1, 3, 4, 2]$$$, then we should perform such a chain of replacements $$$[1, 3, 4, 2] \\rightarrow [1, 4, 2, 3] \\rightarrow [1, 4, 3, 2]$$$. For each query of the $$$1$$$-st type output the required sum.[SOURCE CODE]import io,os;from math import *;input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\nmanual = 20;n,Q = map(int,input().split());after = min(manual, n);before = n -after;ind = 0\ndef unrankperm(i):\n\tunused = [i+1 for i in range(after)];r = []\n\tfor j in range(after)[::-1]:use = i \/\/ factorial(j);r.append(unused[use]);del unused[use];i -= use * factorial(j)\n\treturn r\np = unrankperm(ind)\nfor _ in range(Q):\n\tq = list(map(int,input().split()))\n\tif q[0] == 1:\n\t\tl,r = q[1:];amt = 0\n\t\tif l <= before:amt +=  (r * (r + 1) \/\/ 2 if r <= before else before * (before + 1) \/\/ 2);amt -= l * (l - 1) \/\/ 2;l = before + 1\n\t\tif r > before:amt += sum(p[l-1-before:r-before]) + (r - l + 1) * (before)\n\t\tprint(amt)\n\telse:ind += q[1];p = unrankperm(ind)","tags":["math"],"src_uid":"d458a65b351b2ba7f9891178ef1b64a1"}
{"text_full":"[DESCRIPTION]Vasya lagged behind at the University and got to the battlefield. Just joking! He's simply playing some computer game. The field is a flat platform with n trenches dug on it. The trenches are segments on a plane parallel to the coordinate axes. No two trenches intersect.There is a huge enemy laser far away from Vasya. The laser charges for a seconds, and then shoots continuously for b seconds. Then, it charges for a seconds again. Then it shoots continuously for b seconds again and so on. Vasya knows numbers a and b. He also knows that while the laser is shooting, Vasya must be in the trench, but while the laser is charging, Vasya can safely move around the field. The main thing is to have time to hide in the trench before the shot. If Vasya reaches the trench exactly at the moment when the laser starts shooting, we believe that Vasya managed to hide. Coincidentally, the length of any trench in meters numerically does not exceed b.Initially, Vasya is at point A. He needs to get to point B. Vasya moves at speed 1 meter per second in either direction. You can get in or out of the trench at any its point. Getting in or out of the trench takes no time. It is also possible to move in the trench, without leaving it.What is the minimum time Vasya needs to get from point A to point B, if at the initial time the laser has just started charging? If Vasya cannot get from point A to point B, print -1. If Vasya reaches point B at the moment when the laser begins to shoot, it is believed that Vasya managed to reach point B.[SOURCE CODE]import math\nR = lambda: map(int, raw_input().split())\na, b = R()\nAx, Ay, Bx, By = R()\nn = R()[0]\nx1, y1, x2, y2 = [Ax],[Ay],[Ax],[Ay]\n\nfor i in range(n):\n\t_t1, _t2, _t3, _t4 = R()\n\tif (_t1 > _t3): _t1, _t3 = _t3, _t1\t\t\n\tif (_t2 > _t4):_t2, _t4 = _t4, _t2\n\tx1.append(_t1)\n\ty1.append(_t2)\n\tx2.append(_t3)\n\ty2.append(_t4)\n\t\nx1.append(Bx)\ny1.append(By)\nx2.append(Bx)\ny2.append(By)\n\nkc = lambda x1, y1, x2, y2: (x1 - x2)**2 + (y1-y2)**2\nkc2 = lambda x, y: x*x + y*y\n\ndef can_go2(i, j):\n\td = min(kc(x1[i],y1[i], x1[j], y1[j]), kc(x1[i],y1[i], x2[j], y2[j]), kc(x1[i],y1[i], x1[j], y2[j]), kc(x1[i],y1[i], x2[j], y1[j]),\n\t\t\tkc(x1[i],y2[i], x1[j], y1[j]), kc(x1[i],y2[i], x2[j], y2[j]), kc(x1[i],y2[i], x1[j], y2[j]), kc(x1[i],y2[i], x2[j], y1[j]),\n\t\t\tkc(x2[i],y1[i], x1[j], y1[j]), kc(x2[i],y1[i], x2[j], y2[j]), kc(x2[i],y1[i], x1[j], y2[j]), kc(x2[i],y1[i], x2[j], y1[j]),\n\t\t\tkc(x2[i],y2[i], x1[j], y1[j]), kc(x2[i],y2[i], x2[j], y2[j]), kc(x2[i],y2[i], x1[j], y2[j]), kc(x2[i],y2[i], x2[j], y1[j]))\n\tif (x1[i]-x1[j]) * (x2[j]-x1[i]) >= 0 or (x2[i] - x1[j]) * (x2[j] - x2[i]) >=0:\n\t\td = min(d, math.fabs(y1[i] - y2[j]), math.fabs(y1[i] - y1[j]), math.fabs(y2[i] - y1[j]), math.fabs(y2[i] - y2[j]))\n\tif (y1[i]-y1[j]) * (y2[j]-y1[i]) >= 0 or (y2[i] - y1[j]) * (y2[j] - y2[i]) >=0:\n\t\td = min(d, math.fabs(x1[i] - x2[j]), math.fabs(x1[i] - x1[j]), math.fabs(x2[i] - x1[j]), math.fabs(x2[i] - x2[j]))\n\tif d <= a ** 2: return d\n\telse: return 0\n\t\ndef can_go(i, j):\n\td = kc2(max(0, max(x1[i],x1[j]) - min(x2[i], x2[j])), max(0, max(y1[i], y1[j]) - min(y2[i], y2[j])))\n\tif d <= a ** 2: return d\n\telse: return 0\n\ndres = [-1 for i in range(0, n+2)]\ndres[0] = 0\nq = [0]\nfirst, last = 0, 0\n\nwhile first <= last:\n\ti = q[first]\n\t#print \"BFS from %d\" % i\n\tfirst += 1\n\tfor j in range(1, n+1): \n\t\tif dres[j] == -1:\n\t\t\tif can_go(i, j) > 0:\t\n\t\t\t\t#print \"---Visit %d\" % j\n\t\t\t\tlast += 1\n\t\t\t\tq.append(j)\n\t\t\t\tdres[j] = dres[i] + 1\n\nres = 1000000000.0\nif can_go(0, n + 1) > 0: res = math.sqrt(kc(Ax, Ay, Bx, By))\n\nfor i in range(1, n + 1):\n\tif dres[i] > 0:\n\t\ttmp = can_go(i, n + 1)\n\t\tif tmp > 0: res = min(res, dres[i] * (a + b) + math.sqrt(tmp))\n\t\t\nif res == 1000000000.0: print \"-1\"\nelse: print \"%.10f\" % res","tags":["graphs","geometry"],"src_uid":"8eda3e355d2823b0c8f92e1628dc1b69"}
{"text_full":"[DESCRIPTION]Denis came to Nastya and discovered that she was not happy to see him... There is only one chance that she can become happy. Denis wants to buy all things that Nastya likes so she will certainly agree to talk to him. The map of the city where they live has a lot of squares, some of which are connected by roads. There is exactly one way between each pair of squares which does not visit any vertex twice. It turns out that the graph of the city is a tree.Denis is located at vertex $$$1$$$ at the time $$$0$$$. He wants to visit every vertex at least once and get back as soon as possible.Denis can walk one road in $$$1$$$ time. Unfortunately, the city is so large that it will take a very long time to visit all squares. Therefore, Denis took a desperate step. He pulled out his pocket time machine, which he constructed in his basement. With its help, Denis can change the time to any non-negative time, which is less than the current time.But the time machine has one feature. If the hero finds himself in the same place and at the same time twice, there will be an explosion of universal proportions and Nastya will stay unhappy. Therefore, Denis asks you to find him a route using a time machine that he will get around all squares and will return to the first and at the same time the maximum time in which he visited any square will be minimal.Formally, Denis's route can be represented as a sequence of pairs: $$$\\{v_1, t_1\\}, \\{v_2, t_2\\}, \\{v_3, t_3\\}, \\ldots, \\{v_k, t_k\\}$$$, where $$$v_i$$$ is number of square, and $$$t_i$$$ is time in which the boy is now.The following conditions must be met:  The route starts on square $$$1$$$ at time $$$0$$$, i.e. $$$v_1 = 1, t_1 = 0$$$ and ends on the square $$$1$$$, i.e. $$$v_k = 1$$$.  All transitions are divided into two types:   Being in the square change the time: $$$\\{ v_i, t_i \\} \\to \\{ v_{i+1}, t_{i+1} \\} : v_{i+1} = v_i, 0 \\leq t_{i+1} &lt; t_i$$$.  Walk along one of the roads: $$$\\{ v_i, t_i \\} \\to \\{ v_{i+1}, t_{i+1} \\}$$$. Herewith, $$$v_i$$$ and $$$v_{i+1}$$$ are connected by road, and $$$t_{i+1} = t_i + 1$$$   All pairs $$$\\{ v_i, t_i \\}$$$ must be different.  All squares are among $$$v_1, v_2, \\ldots, v_k$$$. You need to find a route such that the maximum time in any square will be minimal, that is, the route for which $$$\\max{(t_1, t_2, \\ldots, t_k)}$$$ will be the minimum possible.[SOURCE CODE]import sys\nrange = xrange\ninput = raw_input\n\nfrom types import GeneratorType\n\ndef bootstrap(f, stack=[]):\n    def wrappedfunc(*args, **kwargs):\n        if stack:\n            return f(*args, **kwargs)\n        else:\n            to = f(*args, **kwargs)\n            while True:\n                if type(to) is GeneratorType:\n                    stack.append(to)\n                    to = next(to)\n                else:\n                    stack.pop()\n                    if not stack:\n                        break\n                    to = stack[-1].send(to)\n            return to\n\n    return wrappedfunc\n\ninp = [int(x) for x in sys.stdin.read().split()]; ii = 0\nn = inp[ii]; ii += 1\ncoupl = [[] for _ in range(n)]\nfor _ in range(n - 1):\n    u = inp[ii] - 1; ii += 1\n    v = inp[ii] - 1; ii += 1\n    coupl[u].append(v)\n    coupl[v].append(u)\n\nbfs = [0]\nfor node in bfs:\n    for nei in coupl[node]:\n        del coupl[nei][coupl[nei].index(node)]\n        bfs.append(nei)\n\ntree = []\ntime = []\n\n@bootstrap\ndef dfs(i, t = 0):\n    tree.append(i)\n    time.append(t)\n\n    t0 = t\n    deg = len(coupl[i])\n\n    lower = max(min(t - 1, deg), 0)\n    upper = deg - lower\n\n    ind = 0\n    while ind < len(coupl[i]) and upper:\n        yield dfs(coupl[i][ind], t + 1)\n        t += 1\n        \n        tree.append(i)\n        time.append(t)\n\n        upper -= 1\n        ind += 1\n    \n    t = t0 - lower - 1\n\n    tree.append(i)\n    time.append(t)\n\n    while lower:\n        yield dfs(coupl[i][ind], t + 1)\n        t += 1\n        \n        tree.append(i)\n        time.append(t)\n        \n        lower -= 1\n        ind += 1\n    yield\n\ndfs(0,0)\n\nprint len(tree) - 1\nprint '\\n'.join('%d %d' % (tree[i] + 1, time[i]) for i in range(len(tree) - 1))","tags":["trees","graphs"],"src_uid":"b45e785361f3da9a56a0063cd4f97eaa"}
{"text_full":"[DESCRIPTION]There are k sensors located in the rectangular room of size n × m meters. The i-th sensor is located at point (xi, yi). All sensors are located at distinct points strictly inside the rectangle. Opposite corners of the room are located at points (0, 0) and (n, m). Walls of the room are parallel to coordinate axes.At the moment 0, from the point (0, 0) the laser ray is released in the direction of point (1, 1). The ray travels with a speed of  meters per second. Thus, the ray will reach the point (1, 1) in exactly one second after the start.When the ray meets the wall it's reflected by the rule that the angle of incidence is equal to the angle of reflection. If the ray reaches any of the four corners, it immediately stops.For each sensor you have to determine the first moment of time when the ray will pass through the point where this sensor is located. If the ray will never pass through this point, print  - 1 for such sensors.[SOURCE CODE]n, m, k = map(int,input().split())\ndm, dp = {}, {}\nvis = {}\nsensors = []\nborder = set()\nfor el in [(0, m), (n, 0), (0, 0), (n, m)]:\n    border.add(el)\n\nfor _ in range(k):\n    x, y = map(int, input().split())\n    if not (x - y) in dm:\n        dm[x - y] = []\n    dm[x - y].append((x, y))\n    if not (x + y) in dp:\n        dp[x + y] = []\n    dp[x + y].append((x, y))\n    vis[(x, y)] = -1\n    sensors.append((x,y))\n\nx, y = 0, 0\ntime = 0\nmove = (1,1)\nwhile True:\n    if move == (1,1):\n        v = min(n - x, m - y)\n        nxt = (x + v, y + v)\n        if nxt[0] == n:\n            move = (-1, 1)\n        else:\n            move = (1, -1)\n        if (x - y) in dm:\n            for sensor in dm[x - y]:\n                if vis[sensor] == -1:\n                    #print('doing', sensor)\n                    vis[sensor] = time + sensor[0] - x\n        time += v\n\n    elif move == (-1,-1):\n        v = min(x, y)\n        nxt = (x - v, y - v)\n        if nxt[0] == 0:\n            move = (1, -1)\n        else:\n            move = (-1, 1)\n        if (x - y) in dm:\n            for sensor in dm[x - y]:\n                if vis[sensor] == -1:\n                    #print('doing', sensor)\n                    vis[sensor] = time + x - sensor[0]\n        time += v\n\n    elif move == (-1,1):\n        v = min(x, m - y)\n        nxt = (x - v, y + v)\n        if nxt[0] == 0:\n            move = (1, 1)\n        else:\n            move = (-1, -1)\n        if (x + y) in dp:\n            for sensor in dp[x + y]:\n                if vis[sensor] == -1:\n                    #print('doing', sensor)\n                    vis[sensor] = time + x - sensor[0]\n        time += v\n\n    else:\n        v = min(n - x, y)\n        nxt = (x + v, y - v)\n        if nxt[0] == n:\n            move = (-1, -1)\n        else:\n            move = (1, 1)\n        if (x + y) in dp:\n            for sensor in dp[x + y]:\n                if vis[sensor] == -1:\n                    #print('doing', sensor)\n                    vis[sensor] = time + sensor[0] - x\n        time += v\n\n    if nxt in border:\n        break\n    else:\n        border.add(nxt)\n\n    x, y = nxt\n    #print('bum', x, y)\n\nfor i in range(k):\n    #print(sensors[i])\n    print(vis[sensors[i]])","tags":["number theory","math"],"src_uid":"27a521d4d59066e50e870e7934d4b190"}
{"text_full":"[DESCRIPTION]There are n cities in Berland, each of them has a unique id — an integer from 1 to n, the capital is the one with id 1. Now there is a serious problem in Berland with roads — there are no roads.That is why there was a decision to build n - 1 roads so that there will be exactly one simple path between each pair of cities.In the construction plan t integers a1, a2, ..., at were stated, where t equals to the distance from the capital to the most distant city, concerning new roads. ai equals the number of cities which should be at the distance i from the capital. The distance between two cities is the number of roads one has to pass on the way from one city to another. Also, it was decided that among all the cities except the capital there should be exactly k cities with exactly one road going from each of them. Such cities are dead-ends and can't be economically attractive. In calculation of these cities the capital is not taken into consideration regardless of the number of roads from it. Your task is to offer a plan of road's construction which satisfies all the described conditions or to inform that it is impossible.[SOURCE CODE]n, t, k = map(int, input().split())\na   =   list(map(int, input().split()))\np   =   {}\ncnt =   0\n\ncur   = 1\nfloor = [[1]]\n\nfor ak in a:\n    arr  = [cur+i for i in range(1, ak+1)]\n    floor.append(arr)\n    cur += ak\n    \nfor i in range(1, t+1):\n    cnt += len(floor[i]) - 1\n    \n    if i == t:\n        cnt += 1\n        \n    for u in floor[i]:\n        p[u] = floor[i-1][0]\n        \nfor i in range(2, t+1):\n    if cnt <= k :\n        break\n        \n    j      =  1\n    min_   =  min(len(floor[i]), len(floor[i-1]))\n    \n    while j < min_ and cnt > k:\n        p[floor[i][j]] = floor[i-1][j]\n        cnt-=1\n        j+=1\n    \nif cnt == k:\n    print(n)\n    print('\\n'.join([str(u) + ' ' + str(v) for u, v in p.items()]))\nelse:\n    print(-1)\n# 7 3 3\n# 2 3 1\n\n#14 5 6\n#4 4 2 2 1\n\n# 10 3 9 \n# 3 3 3","tags":["trees","graphs"],"src_uid":"7ebf821d51383f1633947a3b455190f6"}
{"text_full":"[DESCRIPTION]You are creating a level for a video game. The level consists of $$$n$$$ rooms placed in a circle. The rooms are numbered $$$1$$$ through $$$n$$$. Each room contains exactly one exit: completing the $$$j$$$-th room allows you to go the $$$(j+1)$$$-th room (and completing the $$$n$$$-th room allows you to go the $$$1$$$-st room).You are given the description of the multiset of $$$n$$$ chests: the $$$i$$$-th chest has treasure value $$$c_i$$$.Each chest can be of one of two types:   regular chest — when a player enters a room with this chest, he grabs the treasure and proceeds to the next room;  mimic chest — when a player enters a room with this chest, the chest eats him alive, and he loses. The player starts in a random room with each room having an equal probability of being chosen. The players earnings is equal to the total value of treasure chests he'd collected before he lost.You are allowed to choose the order the chests go into the rooms. For each $$$k$$$ from $$$1$$$ to $$$n$$$ place the chests into the rooms in such a way that:  each room contains exactly one chest;  exactly $$$k$$$ chests are mimics;  the expected value of players earnings is minimum possible. Please note that for each $$$k$$$ the placement is chosen independently.It can be shown that it is in the form of $$$\\frac{P}{Q}$$$ where $$$P$$$ and $$$Q$$$ are non-negative integers and $$$Q \\ne 0$$$. Report the values of $$$P \\cdot Q^{-1} \\pmod {998244353}$$$.[SOURCE CODE]#   Author: yumtam\n#   Created at: 2020-09-11 00:33\n\nfrom __future__ import division, print_function\n_interactive = False\n\ndef main():\n    n = int(input())\n    ar = [ModInt(int(c)) for c in input().split()]\n\n    ar.sort()\n    prfsum = [ModInt(0)]\n    for x in ar:\n        prfsum.append(prfsum[-1]+x)\n\n    def rsum(l, r):\n        return prfsum[r]-prfsum[l]\n\n    for d in range(1, n):\n        r = n-d\n        mult = ModInt(1)\n        ans = ModInt(0)\n        while True:\n            l = max(0, r-d)\n            ans = ans + mult*rsum(l, r)\n            r = l\n            mult += 1\n            if l == 0:\n                break\n\n        print(ans\/\/n, end=' ')\n    print(0)\n\n\n# Constants\nINF = float('inf')\nMOD = 998244353\n\n# Python3 equivalent names\nimport os, sys, itertools\nif sys.version_info[0] < 3:\n    input = raw_input\n    range = xrange\n\n    filter = itertools.ifilter\n    map = itertools.imap\n    zip = itertools.izip\n\n# print-flush in interactive problems\nif _interactive:\n    flush = sys.stdout.flush\n    def printf(*args, **kwargs):\n        print(*args, **kwargs)\n        flush()\n\n# Debug print, only works on local machine\nLOCAL = \"LOCAL_\" in os.environ\ndebug_print = (print) if LOCAL else (lambda *x, **y: None)\n\n# Fast IO\nif (not LOCAL) and (not _interactive):\n    from io import BytesIO\n    from atexit import register\n    sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))\n    sys.stdout = BytesIO()\n    register(lambda: os.write(1, sys.stdout.getvalue()))\n    input = lambda: sys.stdin.readline().rstrip('\\r\\n')\n\n# Some utility functions(Input, N-dimensional lists, ...)\ndef input_as_list():\n    return [int(x) for x in input().split()]\n\ndef input_with_offset(o):\n    return [int(x)+o for x in input().split()]\n\ndef input_as_matrix(n, m):\n    return [input_as_list() for _ in range(n)]\n\ndef array_of(f, *dim):\n    return [array_of(f, *dim[1:]) for _ in range(dim[0])] if dim else f()\n\n# Start of external code templates...\n# End of external code templates.\n\nfrom __pypy__.intop import *\nclass ModInt(int):\n    def __new__(cls, v): return int.__new__(cls, v%MOD)\n    def __add__(self, other): return ModInt(int_mod(int_add(self, other), MOD))\n    def __sub__(self, other): return ModInt(int_mod(int_sub(self, other), MOD))\n    def __mul__(self, other): return ModInt(int_mulmod(self, other, MOD))\n    def __div__(self, other): return ModInt(int_mulmod(self, pow(other, MOD-2, MOD), MOD))\n    __truediv__ = __floordiv__ = __div__\n    def __pow__(self, power, modulo=MOD): return ModInt(int.__pow__(self, power, modulo))\n\nmain()","tags":["probabilities","math"],"src_uid":"a3a14dbb486a26d015b69187f87c53d4"}
{"text_full":"[DESCRIPTION]Berland is going through tough times — the dirt price has dropped and that is a blow to the country's economy. Everybody knows that Berland is the top world dirt exporter!The President of Berland was forced to leave only k of the currently existing n subway stations.The subway stations are located on a straight line one after another, the trains consecutively visit the stations as they move. You can assume that the stations are on the Ox axis, the i-th station is at point with coordinate xi. In such case the distance between stations i and j is calculated by a simple formula |xi - xj|.Currently, the Ministry of Transport is choosing which stations to close and which ones to leave. Obviously, the residents of the capital won't be too enthusiastic about the innovation, so it was decided to show the best side to the people. The Ministry of Transport wants to choose such k stations that minimize the average commute time in the subway!Assuming that the train speed is constant (it is a fixed value), the average commute time in the subway is calculated as the sum of pairwise distances between stations, divided by the number of pairs (that is ) and divided by the speed of the train.Help the Minister of Transport to solve this difficult problem. Write a program that, given the location of the stations selects such k stations that the average commute time in the subway is minimized.[SOURCE CODE]n = int(raw_input())\nx = map(int, raw_input().split())\nk = int(raw_input())\norigin = {}\nfor i, e in enumerate(x):\n  origin[e] = i\nx.sort()\ns = [0] * n\nfor i,e in enumerate(x):\n  if i == 0:\n    s[i] = x[i]\n  else:\n    s[i] = s[i-1] + x[i]\nbestStart = 0\nbestAns = 0\nprevAns = bestAns\n\nfor i in range(1, n - k + 1):\n  diff = (k-1) * (x[i-1] + x[i+k-1]) - 2*(s[i+k-2] - s[i-1])\n  prevAns += diff\n  if prevAns < bestAns:\n    bestAns = prevAns\n    bestStart = i\nfor i in range(bestStart, bestStart + k):\n  print origin[x[i]] + 1,\nprint","tags":["math"],"src_uid":"321dfe3005c81bf00458e475202a83a8"}
{"text_full":"[DESCRIPTION]Pasha loves to send strictly positive integers to his friends. Pasha cares about security, therefore when he wants to send an integer $$$n$$$, he encrypts it in the following way: he picks three integers $$$a$$$, $$$b$$$ and $$$c$$$ such that $$$l \\leq a,b,c \\leq r$$$, and then he computes the encrypted value $$$m = n \\cdot a + b - c$$$.Unfortunately, an adversary intercepted the values $$$l$$$, $$$r$$$ and $$$m$$$. Is it possible to recover the original values of $$$a$$$, $$$b$$$ and $$$c$$$ from this information? More formally, you are asked to find any values of $$$a$$$, $$$b$$$ and $$$c$$$ such that  $$$a$$$, $$$b$$$ and $$$c$$$ are integers,  $$$l \\leq a, b, c \\leq r$$$,  there exists a strictly positive integer $$$n$$$, such that $$$n \\cdot a + b - c = m$$$.[SOURCE CODE]# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Tue Jul 21 01:33:02 2020\n\n@author: Manan Tyagi\n\"\"\"\nimport math\nt=int(input())\np=0\na=0\nwhile t:\n    t-=1\n    l,r,m=map(int,input().split())\n    mxd=r-l\n    if m<l:\n        pr=m-l\n        c=r\n        b=c+pr\n        a=l\n    elif m==l:\n        a=l\n        b=l\n        c=l\n        \n        \n        \n    else:\n        for i in range(r,l-1,-1):     #checking on every iteration\n                                    \n            n=math.floor(m\/i)\n            n1=math.ceil(m\/i)\n            f1=abs((n*i)-m)\n            f2=abs((n1*i)-m)\n            re=min(f1,f2)\n            if re<=mxd:\n                if re==f1:\n                    p=n\n                else:\n                    p=n1\n                a=i\n                break\n                \n               \n        \n        #print(p)\n        pr=m-(a*p)\n        #print(pr)\n        if pr>0:\n            c=l\n            b=c+pr\n        else:\n            c=r\n            b=c+pr\n            \n        \n    print(a,b,c)","tags":["number theory","math"],"src_uid":"39d8677b310bee8747c5112af95f0e33"}
{"text_full":"[DESCRIPTION]You are given a convex polygon. Count, please, the number of triangles that contain a given point in the plane and their vertices are the vertices of the polygon. It is guaranteed, that the point doesn't lie on the sides and the diagonals of the polygon.[SOURCE CODE]import sys\nimport gc\ngc.disable()\n\nrl = sys.stdin.readline\nn = int(rl())\np = [complex(float(x),float(y)) for x,y in map(str.split,map(rl,[-1]*n))]\npi = [c.conjugate() for c in p]\nfn = [0.5*x*(x-1) for x in xrange(0,n+1)]\nfnn = fn[::-1]\n\nfor jj in xrange(int(rl())):\n    a = complex(*map(float,rl().split()))    \n    pp = map(a.__rsub__,p)\n    pc = map(a.conjugate().__rsub__,pi)\n    i = 1\n    ri = 0    \n    b = pp[0]\n    try:        \n        for j,c in enumerate(pc):\n            while (b*c).imag<0: \n                ri += fn[j-i]\n                b=pp[i]\n                i+=1\n        for j,c in enumerate(pc):\n            while (b*c).imag<0: \n                ri += fnn[i-j]\n                b=pp[i]\n                i+=1\n    except:\n        print n*(n-1)*(n-2)\/6-int(ri)\n    else: \n        print 0","tags":["geometry"],"src_uid":"776706f09cd446bc144a2591e424e437"}
{"text_full":"[DESCRIPTION]You are given a directed graph with $$$n$$$ vertices and $$$m$$$ directed edges without self-loops or multiple edges.Let's denote the $$$k$$$-coloring of a digraph as following: you color each edge in one of $$$k$$$ colors. The $$$k$$$-coloring is good if and only if there no cycle formed by edges of same color.Find a good $$$k$$$-coloring of given digraph with minimum possible $$$k$$$.[SOURCE CODE]from __future__ import division, print_function\nimport math\ndef main():\n    from collections import defaultdict \n    from collections import deque\n    class Graph(): \n        def __init__(self,vertices): \n            self.graph = defaultdict(list) \n            self.V = vertices \n      \n        def addEdge(self,u,v): \n            self.graph[u].append(v) \n      \n        def isCyclicUtil(self, v, visited, recStack): \n            visited[v] = True\n            recStack[v] = True\n            for neighbour in self.graph[v]: \n                if visited[neighbour] == False: \n                    if self.isCyclicUtil(neighbour, visited, recStack) == True: \n                        return True\n                elif recStack[neighbour] == True: \n                    return True\n            recStack[v] = False\n            return False\n        def isCyclic(self): \n            visited = [False] * self.V \n            recStack = [False] * self.V \n            for node in range(self.V): \n                if visited[node] == False: \n                    if self.isCyclicUtil(node,visited,recStack) == True: \n                        return True\n            return False\n        def neigh(self,u):\n            return self.graph[u]\n    \n    n,m=map(int,input().split())\n    g=Graph(n)\n    pos={}\n    for i in range(m):\n        u,v=map(int,input().split())\n        g.addEdge(u-1,v-1)\n        pos[(u-1,v-1)]=i\n    if g.isCyclic()==1:\n        print(2)\n        result=[0]*m\n        for k in pos:\n            if k[0]<k[1]:\n                result[pos[k]]=1\n            else :\n                result[pos[k]]=2\n        print(\" \".join(str(x) for x in result))\n    else :\n        print(1)\n        for i in range(m):\n            print(1,end=\" \")\n                \n \n######## Python 2 and 3 footer by Pajenegod and c1729\n \n# Note because cf runs old PyPy3 version which doesn't have the sped up\n# unicode strings, PyPy3 strings will many times be slower than pypy2.\n# There is a way to get around this by using binary strings in PyPy3\n# but its syntax is different which makes it kind of a mess to use.\n \n# So on cf, use PyPy2 for best string performance.\n \npy2 = round(0.5)\nif py2:\n    from future_builtins import ascii, filter, hex, map, oct, zip\n    range = xrange\n \nimport os, sys\nfrom io import IOBase, BytesIO\n \nBUFSIZE = 8192\nclass FastIO(BytesIO):\n    newlines = 0\n \n    def __init__(self, file):\n        self._file = file\n        self._fd = file.fileno()\n        self.writable = \"x\" in file.mode or \"w\" in file.mode\n        self.write = super(FastIO, self).write if self.writable else None\n \n    def _fill(self):\n        s = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n        self.seek((self.tell(), self.seek(0,2), super(FastIO, self).write(s))[0])\n        return s\n \n    def read(self):\n        while self._fill(): pass\n        return super(FastIO,self).read()\n \n    def readline(self):\n        while self.newlines == 0:\n            s = self._fill(); self.newlines = s.count(b\"\\n\") + (not s)\n        self.newlines -= 1\n        return super(FastIO, self).readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.getvalue())\n            self.truncate(0), self.seek(0)\n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        if py2:\n            self.write = self.buffer.write\n            self.read = self.buffer.read\n            self.readline = self.buffer.readline\n        else:\n            self.write = lambda s:self.buffer.write(s.encode('ascii'))\n            self.read = lambda:self.buffer.read().decode('ascii')\n            self.readline = lambda:self.buffer.readline().decode('ascii')\n \n \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n')\n \n# Cout implemented in Python\nimport sys\nclass ostream:\n    def __lshift__(self,a):\n        sys.stdout.write(str(a))\n        return self\ncout = ostream()\nendl = '\\n'\n \n# Read all remaining integers in stdin, type is given by optional argument, this is fast\ndef readnumbers(zero = 0):\n    conv = ord if py2 else lambda x:x\n    A = []; numb = zero; sign = 1; i = 0; s = sys.stdin.buffer.read()\n    try:\n        while True:\n            if s[i] >= b'0' [0]:\n                numb = 10 * numb + conv(s[i]) - 48\n            elif s[i] == b'-' [0]: sign = -1\n            elif s[i] != b'\\r' [0]:\n                A.append(sign*numb)\n                numb = zero; sign = 1\n            i += 1\n    except:pass\n    if s and s[-1] >= b'0' [0]:\n        A.append(sign*numb)\n    return A\n \nif __name__== \"__main__\":\n  main()","tags":["graphs"],"src_uid":"9974ea401e2ec62f3c1e2317a23ee605"}
{"text_full":"[DESCRIPTION]You are given an array of $$$n$$$ integers. You need to split all integers into two groups so that the GCD of all integers in the first group is equal to one and the GCD of all integers in the second group is equal to one.The GCD of a group of integers is the largest non-negative integer that divides all the integers in the group.Both groups have to be non-empty.[SOURCE CODE]import sys\n\ndef gcd(l):\n\tif len(l)==0:\n\t\treturn 0\n\tif len(l)==1:\n\t\treturn l[0]\n\tif len(l)==2:                                   \n\t\tif l[1]==0:\n\t\t\treturn l[0]  \n\t\treturn gcd([l[1],l[0]%l[1]])\n\treturn gcd([gcd(l[:-1]),l[-1]])\n\t\t\ndef brute_force(l1,l2,l,sol):                   \n\tif len(l)==0:\n\t\tg1=gcd(l1)\n\t\tg2=gcd(l2)\n\t\treturn g1==1 and g2==1,sol\n\t\n\tres,s=brute_force(l1+[l[0]],l2,l[1:],sol+[1])\n\tif res:\n\t\treturn True,s\n\treturn brute_force(l1,l2+[l[0]],l[1:],sol+[2])\n\ndef factor(n):\n\tres=[]\n\ti=2\n\twhile i*i<=n:\n\t\tif n%i==0:\n\t\t\tres.append(i)\n\t\twhile n%i==0:\n\t\t\tn=int(n\/i)\n\t\ti+=1\n\n\tif n!=1:\n\t\tres.append(n)\n\n\treturn res\n\ndef dumpsol(sol):\n\tfor v in sol:\n\t\tprint(v,end=' ')\n\nn=int(sys.stdin.readline())\nl=sys.stdin.readline().strip().split(\" \")[0:n]\nl=[int(x) for x in l]\nif n<12:\n\tret,sol=brute_force([],[],l,[])\n\tif ret:\n\t\tprint(\"YES\")\n\t\tdumpsol(sol)\n\telse:\n\t\tprint(\"NO\")\n\tsys.exit()\n\nfactors={}\nfor i in range(10):\n\tfor key in factor(l[i]):\n\t\tfactors[key]=0\n\nflists={}\nfor f in factors:\n\tflists[f]=[]\n\tpos=0\n\tfound=False\n\tfor v in l:\n\t\tif v%f!=0:\n\t\t\tfound=True\n\t\t\tfactors[f]+=1\n\t\t\tflists[f].append(pos)\n\t\t\tif (factors[f]>9):\n\t\t\t\tbreak\n\t\tpos+=1\n\tif not found:\n\t\tprint(\"NO\")\n\t\tsys.exit()\n\noftf=[]\nisoftf={}\nfor f in factors:\n\tif factors[f]==0:\n\t\tprint(\"NO\")\n\t\tsys.exit()\n\n\tif factors[f]<10:\n\t\toftf.append(f)\n\t\tisoftf[f]=1\n\n#print(oftf)\n\nsol=[1 for i in range(len(l))]\nx=l[0]\nsol[0]=2\noxf=factor(x)\n#print(oxf)\nxf=[]\nnxf=0\nisxoftf={}\nfor f in oxf:\n\tif f in isoftf:\n\t\tnxf+=1\n\t\tisxoftf[f]=1\n\t\txf.append(f)\n\telse:\n\t\tsol[flists[f][0]]=2\n\nnonxf=[]\nfor f in oftf:\n\tif not f in isxoftf:\n\t\tnonxf.append(f)\n\nmasks={}\npos=0\n\n#print(xf)\n#print(nonxf)\n\nfor f in xf+nonxf:\n\tfor v in flists[f]:\n\t\tif not v in masks:\t\n\t\t\tmasks[v]=0\n\t\tmasks[v]|=1<<pos\n\tpos+=1\n\nvals=[{} for i in range(len(masks)+1)]\nvals[0][0]=0\npos=0\nmlist=[]\nfor mask in masks:\n\tmlist.append(mask)\n\tcmask=masks[mask]\n\tcmask1=cmask<<10\n\t#print(vals)\n\tfor v in vals[pos]:\n\t\tvals[pos+1][v|cmask]=v\n\t\t# first number is always in group2\n\t\tif (mask!=0):\n\t\t\tvals[pos+1][v|cmask1]=v\n\tpos+=1\t\n\n#print(vals)\n#print(masks)\n#print(sol)\n\ntest_val=((1<<len(xf))-1)|(((1<<len(oftf))-1)<<10)\n#print(test_val)\nfor v in vals[pos]:\n\tif (v&test_val)==test_val:\n\t\tprint(\"YES\")\n\n\t\t#print(pos)\n\t\twhile (pos!=0):\n\t\t\t#print(v)\n\t\t\t#print(vals[pos])\n\t\t\tnv=vals[pos][v]\n\t\t\t#print(nv)\n\t\t\tif (nv^v<1024 and nv^v!=0):\n\t\t\t\tsol[mlist[pos-1]]=2\n\t\t\tv=nv\n\t\t\tpos-=1\n\n\t\tdumpsol(sol)\n\t\tsys.exit()\n\nprint(\"NO\")\n\n#print(oftf)\n#print(masks)","tags":["number theory","probabilities"],"src_uid":"973ef4e00b0489261fce852af11aa569"}
{"text_full":"[DESCRIPTION]Two players play the following game. Initially, the players have a knife and a rectangular sheet of paper, divided into equal square grid cells of unit size. The players make moves in turn, the player who can't make a move loses. In one move, a player can take the knife and cut the paper along any segment of the grid line (not necessarily from border to border). The part of the paper, that touches the knife at least once, is considered cut. There is one limit not to turn the game into an infinite cycle: each move has to cut the paper, that is the knife has to touch the part of the paper that is not cut before.Obviously, the game ends when the entire sheet is cut into 1 × 1 blocks. During the game, the pieces of the sheet are not allowed to move. It is also prohibited to cut along the border. The coordinates of the ends of each cut must be integers.You are given an n × m piece of paper, somebody has already made k cuts there. Your task is to determine who will win if the players start to play on this sheet. You can consider that both players play optimally well. If the first player wins, you also need to find the winning first move.[SOURCE CODE]from sys import stdin\nfrom collections import defaultdict\ndef emp(l, a):\n    cnt = pos = x = 0\n    for y in a:\n        if y[1]:\n            cnt -= 1\n        else:\n            if not cnt:\n                x += y[0] - pos\n            cnt += 1\n        pos = y[0]\n    x += l - pos\n    return x\ndef check(x, b):\n    return x ^ b < x\ndef f(x, b):\n    return x - (x ^ b)\ndef main():\n    n, m, k = map(int, stdin.readline().split())\n    xcut = defaultdict(list)\n    ycut = defaultdict(list)\n    for i in xrange(k):\n        xb, yb, xe, ye = map(int, stdin.readline().split())\n        if xb == xe:\n            xcut[xb].extend([(min(yb, ye), 0), (max(yb, ye), 1)])\n        else:\n            ycut[yb].extend([(min(xb, xe), 0), (max(xb, xe), 1)])\n    b = 0\n    xb = dict()\n    yb = dict()\n    for t in xcut.keys():\n        xcut[t].sort()\n        xb[t] = emp(m, xcut[t])\n        b ^= xb[t]\n    if (n - 1 - len(xcut)) % 2:\n        b ^= m\n    for t in ycut.keys():\n        ycut[t].sort()\n        yb[t] = emp(n, ycut[t])\n        b ^= yb[t]\n    if (m - 1 - len(ycut)) % 2:\n        b ^= n\n    if b == 0:\n        print \"SECOND\"\n        return\n    else:\n        print \"FIRST\"\n        if n - 1 - len(xcut) and check(m, b):\n            for i in xrange(1, n):\n                if i not in xcut:\n                    print i, 0, i, f(m, b)\n                    return\n        if m - 1 - len(ycut) and check(n, b):\n            for i in xrange(1, m):\n                if i not in ycut:\n                    print 0, i, f(n, b), i\n                    return\n        for t, a in xcut.items():\n            if not check(xb[t], b): continue\n            c = f(xb[t], b)\n            cnt = pos = x = 0\n            for y in a:\n                if y[1] == 0:\n                    if cnt == 0:\n                        if x <= c <= x + y[0] - pos:\n                            print t, 0, t, pos + c - x\n                            return\n                        x += y[0] - pos\n                    cnt += 1\n                else:\n                    cnt -= 1\n                pos = y[0]\n            print t, 0, t, pos + c - x\n            return\n        for t, a in ycut.items():\n            if not check(yb[t], b): continue\n            c = f(yb[t], b)\n            cnt = pos = x = 0\n            for y in a:\n                if y[1] == 0:\n                    if cnt == 0:\n                        if x <= c <= x + y[0] - pos:\n                            print 0, t, pos + c - x, t\n                            return\n                        x += y[0] - pos\n                    cnt += 1\n                else:\n                    cnt -= 1\n                    pos = y[0]\n            print 0, t, pos + c - x, t\n            return\nmain()","tags":["games"],"src_uid":"a7fa7a5ab71690fb3b5301bebc19956b"}
{"text_full":"[DESCRIPTION]You know that the Martians use a number system with base k. Digit b (0 ≤ b &lt; k) is considered lucky, as the first contact between the Martians and the Earthlings occurred in year b (by Martian chronology).A digital root d(x) of number x is a number that consists of a single digit, resulting after cascading summing of all digits of number x. Word \"cascading\" means that if the first summing gives us a number that consists of several digits, then we sum up all digits again, and again, until we get a one digit number.For example, d(35047) = d((3 + 5 + 0 + 4)7) = d(157) = d((1 + 5)7) = d(67) = 67. In this sample the calculations are performed in the 7-base notation.If a number's digital root equals b, the Martians also call this number lucky.You have string s, which consists of n digits in the k-base notation system. Your task is to find, how many distinct substrings of the given string are lucky numbers. Leading zeroes are permitted in the numbers.Note that substring s[i... j] of the string s = a1a2... an (1 ≤ i ≤ j ≤ n) is the string aiai + 1... aj. Two substrings s[i1... j1] and s[i2... j2] of the string s are different if either i1 ≠ i2 or j1 ≠ j2.[SOURCE CODE]k, b, n = map(int, input().split())\n\ndigits = list(map(int, input().split()))\n\ndef ans0():\n    j = -1\n    answer = 0 \n    for i in range(n):\n        if digits[i] != 0 or i < j:\n            continue\n        j = i\n        while j < n and digits[j] == 0:\n            j += 1\n\n        r = j - i\n        answer += r * (r + 1) \/\/ 2\n\n    return answer\n\nif b == 0:\n    print(ans0())\nelse:\n    count = dict()\n    count[0] = 1\n    pref_sum = 0\n    answer = 0\n\n    if b == k - 1:\n        b = 0\n        answer -= ans0()\n\n    for d in digits:\n        pref_sum = (pref_sum + d) % (k - 1)\n\n        need = (pref_sum - b) % (k - 1)\n\n        answer += count.get(need, 0)\n\n        count[pref_sum] = count.get(pref_sum, 0) + 1\n\n    print(answer)","tags":["number theory","math"],"src_uid":"bbc2683d207f147a2a0abedc67ff157a"}
{"text_full":"[DESCRIPTION]Simon has an array a1, a2, ..., an, consisting of n positive integers. Today Simon asked you to find a pair of integers l, r (1 ≤ l ≤ r ≤ n), such that the following conditions hold:  there is integer j (l ≤ j ≤ r), such that all integers al, al + 1, ..., ar are divisible by aj;  value r - l takes the maximum value among all pairs for which condition 1 is true; Help Simon, find the required pair of numbers (l, r). If there are multiple required pairs find all of them.[SOURCE CODE]n = int(input()) + 1\nt = [1] + list(map(int, input().split())) + [1]\np = [True] * n\ns, q = 0, list(range(1, n))\nfor i in range(1, n):\n    if p[i]:\n        a = b = i\n        d = t[i]\n        if d == 1: \n            s, q = n - 2, [1]\n            break\n        while t[a - 1] % d == 0: a -= 1\n        while t[b + 1] % d == 0:\n            b += 1\n            p[b] = False\n        d = b - a\n        if d > s: s, q = d, [a]\n        elif d == s != 0: q.append(a)\nprint(len(q), s)\nprint(' '.join(map(str, q)))","tags":["math"],"src_uid":"da517ae908ba466da8ded87cec12a9fa"}
{"text_full":"[DESCRIPTION]There is a square grid of size $$$n \\times n$$$. Some cells are colored in black, all others are colored in white. In one operation you can select some rectangle and color all its cells in white. It costs $$$\\min(h, w)$$$ to color a rectangle of size $$$h \\times w$$$. You are to make all cells white for minimum total cost.The square is large, so we give it to you in a compressed way. The set of black cells is the union of $$$m$$$ rectangles.[SOURCE CODE]import sys\nfrom collections import defaultdict\n\nclass MaxFlow(object):\n    def __init__(self):\n        self.edges = defaultdict(lambda: defaultdict(lambda: 0))\n\n    def add_edge(self, u, v, capacity=float('inf')):\n        self.edges[u][v] = capacity\n\n    def bfs(self, s, t):\n        open_q = [s]\n\n        visited = set()\n        parent = dict()\n        while open_q:\n            close_q = []\n            for node in open_q:\n                for v, capacity in self.edges[node].items():\n                    if v not in visited and capacity > 0:\n                        close_q.append(v)\n                        parent[v] = node\n                        visited.add(v)\n                        if v == t:\n                            result = []\n                            n2 = v\n                            n1 = node\n                            while n1 != s:\n                                result.append((n1, n2))\n                                n2 = n1\n                                n1 = parent[n1]\n                            result.append((n1, n2))\n                            return result\n\n            open_q = close_q\n\n        return None\n\n    def solve(self, s, t):\n        flow = 0\n        route = self.bfs(s, t)\n        while route is not None:\n            new_flow = float('inf')\n            for _, (n1, n2) in enumerate(route):\n                new_flow = min(new_flow, self.edges[n1][n2])\n            for _, (n1, n2) in enumerate(route):\n                self.edges[n1][n2] -= new_flow\n                self.edges[n2][n1] += new_flow\n            flow += new_flow\n\n            route = self.bfs(s, t)\n\n        return flow\n\n    def __str__(self):\n        result = \"{ \"\n        for k, v in self.edges.items():\n            result += str(k) + \":\" + str(dict(v)) + \", \"\n        result += \"}\"\n        return result\n\n\ndef main():\n    (n, m) = tuple([int(x) for x in input().split()])\n    r = []\n    xs = set()\n    ys = set()\n    for i in range(m):\n        (x1, y1, x2, y2) = tuple(int(x) for x in input().split())\n        r.append((x1, y1, x2, y2))\n        xs.add(x1)\n        xs.add(x2 + 1)\n        ys.add(y1)\n        ys.add(y2 + 1)\n\n    xx = sorted(xs)\n    yy = sorted(ys)\n    xsize = len(xs)\n    ysize = len(ys)\n    grid = []\n    for i in range(ysize):\n        grid.append([False] * xsize)\n\n    for rect in r:\n        x1 = rect[0]\n        y1 = rect[1]\n        x2 = rect[2]\n        y2 = rect[3]\n        for i, y in enumerate(yy):\n            for j, x in enumerate(xx):\n                if x1 <= x and y1 <= y and x2 >= x and y2 >= y:\n                    grid[i][j] = True\n\n    f = MaxFlow()\n    for i in range(len(yy)):\n        for j in range(len(xx)):\n            if grid[i][j]:\n                f.add_edge(1 + i, len(yy) + 1 + j, float('inf'))\n    for i in range(len(yy) - 1):\n        f.add_edge(0, i + 1, yy[i + 1] - yy[i])\n    for i in range(len(xx) - 1):\n        f.add_edge(len(yy) + 1 + i, len(xx) + len(yy) + 1, xx[i + 1] - xx[i])\n\n    # print(xx)\n    # print(yy)\n    # print(f)\n    print(f.solve(0, len(xx) + len(yy) + 1))\n\n\nif __name__ == '__main__':\n    main()","tags":["graphs"],"src_uid":"3fba1fbbcb6ef38a446de1b0565dccc2"}
{"text_full":"[DESCRIPTION]One of Timofey's birthday presents is a colourbook in a shape of an infinite plane. On the plane n rectangles with sides parallel to coordinate axes are situated. All sides of the rectangles have odd length. Rectangles cannot intersect, but they can touch each other.Help Timofey to color his rectangles in 4 different colors in such a way that every two rectangles touching each other by side would have different color, or determine that it is impossible.Two rectangles intersect if their intersection has positive area. Two rectangles touch by sides if there is a pair of sides such that their intersection has non-zero length    The picture corresponds to the first example[SOURCE CODE]'''plan\n    noticed that if both upperle\n'''\nfrom sys import stdin, stdout\n# n = int(stdin.readline().rstrip())\n# n = int(input())\n\nall_lines = stdin.read().split('\\n')\nstdout.write('YES\\n')\nfor line in all_lines[1:-1]:\n    x1, y1, x2, y2 = (int(x) % 2 for x in line.split())\n    num = 2 * x2 + y2 + 1\n    # stdout.write(str(x2) + ' ' + str(y2) + '\\n')\n    stdout.write(str(num) + '\\n')\n#stdout.flush()\n#exit()\n\n\n# for i in range(n):\n    # coordinates.append([int(x) % 2 for x in input().split()])\n# for i in range(n):\n    # coordinates.append([int(x) % 2 for x in stdin.readline().rstrip().split()])\n# stdout.write('YES\\n')\n# for coordinate in coordinates:\n    # x1, y1, x2, y2 = coordinate\n    # stdout.write(str(2 * x2 + y2 + 1) + '\\n')","tags":["geometry"],"src_uid":"b6608fadf1677e5cb78b6ed092a23777"}
{"text_full":"[DESCRIPTION]You are given two integers $$$n$$$ and $$$d$$$. You need to construct a rooted binary tree consisting of $$$n$$$ vertices with a root at the vertex $$$1$$$ and the sum of depths of all vertices equals to $$$d$$$.A tree is a connected graph without cycles. A rooted tree has a special vertex called the root. A parent of a vertex $$$v$$$ is the last different from $$$v$$$ vertex on the path from the root to the vertex $$$v$$$. The depth of the vertex $$$v$$$ is the length of the path from the root to the vertex $$$v$$$. Children of vertex $$$v$$$ are all vertices for which $$$v$$$ is the parent. The binary tree is such a tree that no vertex has more than $$$2$$$ children.You have to answer $$$t$$$ independent test cases.[SOURCE CODE]import sys\n\nsys.setrecursionlimit(10 ** 6)\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep=\"\\n\")\ndef II(): return int(sys.stdin.readline())\ndef MI(): return map(int, sys.stdin.readline().split())\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef SI(): return sys.stdin.readline()[:-1]\n\ndef main():\n    t=II()\n    for _ in range(t):\n        n,d=MI()\n        s=n*(n-1)\/\/2\n        diff=s-d\n        if d>s:\n            print(\"NO\")\n            continue\n        aa=[1]*n\n        l=1\n        for r in range(n-1,-1,-1):\n            if l>=r:break\n            if diff==0:break\n            to=max(r-diff,l)\n            aa[r]=0\n            aa[to]+=1\n            diff-=r-to\n            if aa[l]==1<<l:l+=1\n        if diff:\n            print(\"NO\")\n            continue\n        #print(aa)\n        ans=[]\n        pa=1\n        st=1\n        for a in aa[1:]:\n            for i in range(a):\n                ans.append(st+i%pa)\n            st+=pa\n            pa=a\n        print(\"YES\")\n        print(*ans)\n\nmain()","tags":["trees"],"src_uid":"bb8f933f438e2c7c091716cc42dc0060"}
{"text_full":"[DESCRIPTION]A and B are preparing themselves for programming contests.The University where A and B study is a set of rooms connected by corridors. Overall, the University has n rooms connected by n - 1 corridors so that you can get from any room to any other one by moving along the corridors. The rooms are numbered from 1 to n.Every day А and B write contests in some rooms of their university, and after each contest they gather together in the same room and discuss problems. A and B want the distance from the rooms where problems are discussed to the rooms where contests are written to be equal. The distance between two rooms is the number of edges on the shortest path between them.As they write contests in new rooms every day, they asked you to help them find the number of possible rooms to discuss problems for each of the following m days.[SOURCE CODE]from sys import stdin, stdout\ndef main():\n    n = int(stdin.readline())\n    to = [0]\n    xt = [0]\n    last = [0] * (n + 1)\n    toa = to.append\n    xta = xt.append\n    c = 1\n    for _ in xrange(n - 1):\n        a, b = map(int, stdin.readline().split())\n        xta(last[a])\n        last[a] = c\n        toa(b)\n        c += 1\n        xta(last[b])\n        last[b] = c\n        toa(a)\n        c += 1\n    st = [1]\n    done = [0] * (n + 1)\n    par = [0] * (n + 1)\n    cn = [1] * (n + 1)\n    dep = [0] * (n + 1)\n    pp = st.pop\n    pu = st.append\n    while st:\n        x = pp()\n        if done[x] == 1:\n            done[x] = 2\n            y = last[x]\n            while y:\n                if done[to[y]] == 2:\n                    cn[x] += cn[to[y]]\n                y = xt[y]\n        elif not done[x]:\n            done[x] = 1\n            y = last[x]\n            pu(x)\n            while y:\n                if not done[to[y]]:\n                    pu(to[y])\n                    par[to[y]] = x\n                    dep[to[y]] = dep[x] + 1\n                y = xt[y]\n    par[1] = 1\n    pa = [par]\n    ppa = par\n    pu = pa.append\n    N = n.bit_length()\n    for j in xrange(N):\n        npa = [ppa[ppa[i]] for i in xrange(n + 1)]\n        pu(npa)\n        ppa = npa\n    m = int(stdin.readline())\n    ans = []\n    pu = ans.append\n    for _ in xrange(m):\n        a, b = map(int, stdin.readline().split())\n        if a == b:\n            pu(n)\n            continue\n        if dep[a] > dep[b]:\n            a, b = b, a\n        x, y = a, b\n        z = dep[y] - dep[x]\n        for j in xrange(N):\n            if z >> j & 1:\n                y = pa[j][y]\n        if x != y:\n            for j in xrange(N - 1, -1, -1):\n                if pa[j][x] != pa[j][y]:\n                    x, y = pa[j][x], pa[j][y]\n            t = pa[0][x]\n        else:\n            t = x\n        z = dep[a] - 2 * dep[t] + dep[b]\n        if z % 2:\n            pu(0)\n            continue\n        z \/= 2\n        z -= 1\n        y = b\n        for j in xrange(N):\n            if z >> j & 1:\n                y = pa[j][y]\n        x = cn[par[y]] - cn[y]\n        if dep[a] == dep[b]:\n            y = a\n            for j in xrange(N):\n                if z >> j & 1:\n                    y = pa[j][y]\n            x -= cn[y]\n            x += n - cn[par[y]]\n        pu(x)\n    stdout.write('\\n'.join(map(str, ans)))\nmain()","tags":["trees"],"src_uid":"89bf97a548fe12921102e77dda63283a"}
{"text_full":"[DESCRIPTION]You are given a connected weighted undirected graph without any loops and multiple edges. Let us remind you that a graph's spanning tree is defined as an acyclic connected subgraph of the given graph that includes all of the graph's vertexes. The weight of a tree is defined as the sum of weights of the edges that the given tree contains. The minimum spanning tree (MST) of a graph is defined as the graph's spanning tree having the minimum possible weight. For any connected graph obviously exists the minimum spanning tree, but in the general case, a graph's minimum spanning tree is not unique.Your task is to determine the following for each edge of the given graph: whether it is either included in any MST, or included at least in one MST, or not included in any MST.[SOURCE CODE]import sys, threading\nfrom heapq import heappop, heappush\n#from mygraph import MyGraph\nfrom collections import defaultdict\n\nn_nodes, n_edges = map(int, input().split())\n\nedges = list()\n\nresults = defaultdict(lambda: 'any')\nhighest = defaultdict(lambda: -1)\nto_check = defaultdict(list)\ngraph = defaultdict(list)\n\nclass UDFS:\n\n    def __init__(self, n):\n        self.n = n\n\n        # index is the node\n        self.parents = [i for i in range(n)]\n        self.ranks = [0 for i in range(n)]\n\n    def __str__(self):\n        '''\n        Group -> Node\n        '''\n        return '\\n'.join(f'{e} -> {i}' for i, e in enumerate(self.parents))\n\n    def get_group(self, a):\n        if a == self.parents[a]:\n            return a\n\n        # Side effect for balancing the tree\n        self.parents[a] = self.get_group(self.parents[a])\n\n        return self.parents[a]\n\n    def is_parent(self, n):\n        return n == self.get_group(n)\n\n    def is_same_group(self, a, b):\n        return self.get_group(a) == self.get_group(b)\n\n    def join(self, a, b):\n        parent_a = self.get_group(a)\n        parent_b = self.get_group(b)\n\n        if self.ranks[parent_a] > self.ranks[parent_b]:\n            self.parents[parent_b] = parent_a\n        else:\n            self.parents[parent_a] = parent_b\n\n            self.ranks[parent_b] += int(\n                self.ranks[parent_a] == self.ranks[parent_b]\n            )\n\n    def count(self):\n        '''\n        Returns number of groups\n        '''\n        count = 0\n        for n in range(self.n):\n            count += self.is_parent(n)\n\n        return count\n\n#def get_graph(nodes, label):\n#    graph = MyGraph(graph_type='graph', size='20,11.25!', ratio='fill',label=label, fontsize=40)\n#    \n#    for v in range(1,nodes+1):\n#        graph.add_nodes(v)\n#\n#    return graph\n#\n#def make_original_graph(nodes, edges):\n#    original_graph = get_graph(nodes, \"Grafo Original\") \n#\n#    for r in range(edges):\n#            a, b, w = map(int, input('\\tInsira dois nós e o peso da aresta que existe entre eles: ').split())\n#            original_graph.link(a, b, str(w))\n#\n#    img_name = \"original_graph\"\n#\n#    original_graph.save_img(img_name)\n#    \n#    print(f\"O grafo original foi salvo em {img_name}.png!\")\n#\n#def make_edges_in_mst_graph(nodes, edges):\n#    edges_graph = get_graph(nodes, \"Arestas em MSTs\") \n#\n#    for r in range(edges):\n#            edges_graph.link(a, b, str(w))\n#\n#    img_name = \"edges_in_mst\"\n#\n#    edges_graph.save_img(img_name)\n#    \n#    print(f\"O grafo com a ocorrências das arestas em MSTs foi salvo em {img_name}.png!\")\n\ndef dfs(a, depth, p):\n    global edges\n    global results\n    global highest\n    global graph\n\n    if highest[a] != -1:\n        return highest[a];\n\n    minimum = depth\n    highest[a] = depth\n\n    for (w, a, b, i) in graph[a]:\n        ##print('@', w, a, b, i, depth)\n        if i == p:\n            continue\n\n        nextt = dfs(b, depth + 1, i)\n\n        if nextt <= depth:\n            results[i] = 'at least one'\n        else:\n            results[i] = 'any'\n\n        minimum = min(minimum, nextt)\n        highest[a] = minimum\n\n    return highest[a]\n\ndef main():\n    global edges\n    global results\n    global highest\n    global graph\n\n    for i in range(n_edges):\n        a, b, w = map(int, input().split())\n        edges.append((w, a-1, b-1, i))\n\n    edges = sorted(edges, key=lambda x: x[0])\n\n    dsu = UDFS(n_nodes)\n\n    i = 0\n    while i < n_edges:\n        counter = 0\n        j = i\n        while j < n_edges and edges[j][0] == edges[i][0]:\n            if dsu.get_group(edges[j][1]) == dsu.get_group(edges[j][2]):\n                results[edges[j][3]] = 'none'\n            else:\n                to_check[counter] = edges[j]\n                counter += 1\n            j += 1\n            \n        for k in range(counter):\n            w, a, b, i = to_check[k]\n\n            ra = dsu.get_group(a)\n            rb = dsu.get_group(b)\n\n            graph[ra].append((w, ra, rb, i))\n            graph[rb].append((w, rb, ra, i))\n\n        for k in range(counter):\n            #print('To check:', to_check[k][:-1], k)\n            dfs(to_check[k][1], 0, -1)\n\n        for k in range(counter):\n            w, a, b, i = to_check[k]\n\n            ra = dsu.get_group(a)\n            rb = dsu.get_group(b)\n\n            dsu.join(ra, rb)\n\n            graph[ra] = list()\n            graph[rb] = list()\n\n            highest[ra] = -1\n            highest[rb] = -1\n\n        counter = 0\n        i = j\n\n    for i in range(n_edges):\n        print(results[i])\n\nif __name__ == \"__main__\":\n    sys.setrecursionlimit(2**32\/\/2-1)\n    threading.stack_size(1 << 27)\n\n    thread = threading.Thread(target=main)\n    thread.start()\n    thread.join()","tags":["graphs"],"src_uid":"be83ef61283f104dcb00612ae11f2e93"}
{"text_full":"[DESCRIPTION]We'll call an array of n non-negative integers a[1], a[2], ..., a[n] interesting, if it meets m constraints. The i-th of the m constraints consists of three integers li, ri, qi (1 ≤ li ≤ ri ≤ n) meaning that value  should be equal to qi. Your task is to find any interesting array of n elements or state that such array doesn't exist.Expression x&amp;y means the bitwise AND of numbers x and y. In programming languages C++, Java and Python this operation is represented as \"&amp;\", in Pascal — as \"and\".[SOURCE CODE]import os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\nMAX = 1000001\nbitscount = 30\n\nprefix_count = [[0]*(10**5+1) for i in range(30)]\n\n\ndef findPrefixCount(arr, n):\n    for i in range(0, bitscount):\n\n        prefix_count[i][0] = ((arr[0] >> i) & 1)\n\n        for j in range(1, n):\n            prefix_count[i][j] = ((arr[j] >> i) & 1)\n            prefix_count[i][j] += prefix_count[i][j - 1]\n\n\n\n\ndef rangeOr(l, r):\n    ans = 0\n    for i in range(bitscount):\n\n        x = 0\n\n        if (l == 0):\n            x = prefix_count[i][r]\n        else:\n            x = prefix_count[i][r] - prefix_count[i][l - 1]\n\n            # Condition for ith bit\n        # of answer to be set\n        if (x == r - l + 1):\n            ans = (ans | (1 << i))\n\n    return ans\n\n\n\n\n\n\n\n\n\n\nn, m = map(int, input().split())\na = [[0] * n for i in range(30)]\nquery = []\nfor i in range(m):\n    l, r, q = map(int, input().split())\n    query.append([l-1, r-1, q])\n    c = bin(q)[2:][::-1]\n    b = []\n    for j in c:\n        b.append(int(j))\n    j = 0\n    while (j < len(b)):\n        if b[j] == 1:\n            a[j][l - 1] += 1\n            if r != n:\n                a[j][r] -= 1\n        j += 1\nfor i in range(30):\n    j = 1\n    while (j < n):\n        a[i][j] += a[i][j - 1]\n        j += 1\n    j = 0\n    while (j < n):\n        if a[i][j] > 0:\n            a[i][j] = 1\n        j += 1\nres=[]\nfor i in range(n):\n    s = \"\"\n    j=29\n    while(j>=0):\n        s += str(a[j][i])\n        j+=-1\n    res.append(int(s,2))\nfindPrefixCount(res, n)\nf=0\nfor j in query:\n    if rangeOr(j[0],j[1])!=j[2]:\n        f=1\n        break\nif f==1:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n    print(*res)","tags":["trees"],"src_uid":"0b204773f8d06362b7569bd82224b218"}
{"text_full":"[DESCRIPTION]Rats have bred to hundreds and hundreds in the basement of the store, owned by Vasily Petrovich. Vasily Petrovich may have not noticed their presence, but they got into the habit of sneaking into the warehouse and stealing food from there. Vasily Petrovich cannot put up with it anymore, he has to destroy the rats in the basement. Since mousetraps are outdated and do not help, and rat poison can poison inattentive people as well as rats, he chose a radical way: to blow up two grenades in the basement (he does not have more).In this problem, we will present the shop basement as a rectangular table of n × m cells. Some of the cells are occupied by walls, and the rest of them are empty. Vasily has been watching the rats and he found out that at a certain time they go to sleep, and all the time they sleep in the same places. He wants to blow up a grenade when this convenient time comes. On the plan of his basement, he marked cells with sleeping rats in them. Naturally, these cells are not occupied by walls.Grenades can only blow up in a cell that is not occupied by a wall. The blast wave from a grenade distributes as follows. We assume that the grenade blast occurs at time 0. During this initial time only the cell where the grenade blew up gets 'clear'. If at time t some cell is clear, then at time t + 1 those side-neighbouring cells which are not occupied by the walls get clear too (some of them could have been cleared before). The blast wave distributes for exactly d seconds, then it dies immediately.    An example of a distributing blast wave: Picture 1 shows the situation before the blast, and the following pictures show \"clear\" cells by time 0,1,2,3 and 4. Thus, the blast wave on the picture distributes for d = 4 seconds. Vasily Petrovich wonders, whether he can choose two cells to blast the grenades so as to clear all cells with sleeping rats. Write the program that finds it out.[SOURCE CODE]#! \/usr\/bin\/env python2\n \nimport Queue\n \ninFile = open(\"input.txt\", 'r')\noutFile = open(\"output.txt\", 'w')\n \nn, m, d = map(int, inFile.readline().strip().split(' '))\nmat = map(lambda x: x.strip(), inFile.readlines())\nmv = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n \ndef findRats():\n    ret = []\n    for i in xrange(n):\n        for j in xrange(m):\n            if mat[i][j] == 'R':\n                ret.append((i, j))\n    return ret\n \ndef bfs(bgn, mat, d):\n    q = Queue.Queue()\n    q.put(bgn)\n    c = {bgn:0}\n    ret = set()\n    while not q.empty():\n        now = q.get()\n        ret.add(now)\n        if c[now] < d:\n            for mi in mv:\n                then = (now[0] + mi[0], now[1] + mi[1])\n                if then[0] < n and then[0] >= 0 and \\\n                        then[1] < m and then[1] >= 0:\n                    if mat[then[0]][then[1]] != 'X':\n                        if then not in c:\n                            q.put(then)\n                            c[then] = c[now] + 1\n    return ret\n \ndef find(firsts, locs):\n    for first in firsts:\n        others = []\n        for loc in locs:\n            if first not in loc:\n                others.append(loc)\n        if len(others) == 0:\n            ans = [first]\n            for i in xrange(n):\n                for j in xrange(m):\n                    if (i, j) != first:\n                        if mat[i][j] != 'X':\n                            ans.append((i, j))\n                            return ans\n            return -1\n        seconds = reduce(lambda x, y: x & y, others)\n        for second in seconds:\n            if second != first:\n                return (first, second)\n    return -1\n \nrats = findRats()\nif len(rats) > ((d + 1) * 2) ** 2:\n    outFile.write('-1\\n')\nelse:\n    locs = []\n    for r in rats:\n        locs.append(bfs(r, mat, d))\n    ans = find(locs[0], locs[1:])\n    if ans == -1:\n        outFile.write('-1\\n')\n    else:\n        outFile.write(\"{:d} {:d} {:d} {:d}\". \\\n                          format(ans[0][0] + 1,\n                                 ans[0][1] + 1,\n                                 ans[1][0] + 1, \n                                 ans[1][1] + 1))","tags":["graphs"],"src_uid":"1ec5d3bafda09d0230fe14a6029ce421"}
{"text_full":"[DESCRIPTION]Everyone knows that DNA strands consist of nucleotides. There are four types of nucleotides: \"A\", \"T\", \"G\", \"C\". A DNA strand is a sequence of nucleotides. Scientists decided to track evolution of a rare species, which DNA strand was string s initially. Evolution of the species is described as a sequence of changes in the DNA. Every change is a change of some nucleotide, for example, the following change can happen in DNA strand \"AAGC\": the second nucleotide can change to \"T\" so that the resulting DNA strand is \"ATGC\".Scientists know that some segments of the DNA strand can be affected by some unknown infections. They can represent an infection as a sequence of nucleotides. Scientists are interested if there are any changes caused by some infections. Thus they sometimes want to know the value of impact of some infection to some segment of the DNA. This value is computed as follows:  Let the infection be represented as a string e, and let scientists be interested in DNA strand segment starting from position l to position r, inclusive.  Prefix of the string eee... (i.e. the string that consists of infinitely many repeats of string e) is written under the string s from position l to position r, inclusive.  The value of impact is the number of positions where letter of string s coincided with the letter written under it. Being a developer, Innokenty is interested in bioinformatics also, so the scientists asked him for help. Innokenty is busy preparing VK Cup, so he decided to delegate the problem to the competitors. Help the scientists![SOURCE CODE]import sys\nrange = xrange\ninput = raw_input\n\nclass segtree:\n    def __init__(s, data):\n        s.n = len(data)\n        s.m = 1\n        while s.m < s.n: s.m *= 2\n        s.data = [0]*s.m\n        s.data += data\n        for i in reversed(range(2, s.n + s.m)):\n            s.data[i >> 1] += s.data[i]\n\n    def add(s, i, x):\n        i += s.m\n        while i:\n            s.data[i] += x\n            i >>= 1\n\n    def summa(s, l, r):\n        l += s.m\n        r += s.m\n\n        tot = 0\n        while l<r:\n            if l & 1:\n                tot += s.data[l]\n                l += 1\n            if r & 1:\n                tot += s.data[r - 1]\n\n            l >>= 1\n            r >>= 1\n        return tot\n\ndef trans(x):\n    if x == 'A':\n        return 0\n    elif x == 'C':\n        return 1\n    elif x == 'G':\n        return 2\n    return 3\n\ninp = sys.stdin.read().split()\nii = 0\n\nS = [trans(x) for x in inp[ii]]\nii += 1\n\nsegs =  [\n            [\n                [\n                    segtree([+(s==c) for s in S[j::i]]) for c in range(4)\n                ] \n                for j in range(i)\n            ] \n            for i in range(11)\n        ]\n\nq = int(inp[ii])\nii += 1\nout = []\nfor _ in range(q):\n    c = inp[ii]\n    ii += 1\n    if c == '1':\n        ind = int(inp[ii]) - 1\n        ii += 1\n        char = trans(inp[ii])\n        ii += 1\n\n        old_char = S[ind]\n        for i in range(1,11):\n            seg = segs[i][ind % i]\n            seg[old_char].add(ind \/\/ i, -1)\n            seg[char].add(ind \/\/ i, 1)\n\n        S[ind] = char\n    else:\n        l = int(inp[ii]) - 1\n        ii += 1\n        r = int(inp[ii])\n        ii += 1\n\n        e = inp[ii]\n        ii += 1\n\n        tot = 0\n\n        i = len(e)\n        for k in range(i):\n            L = l + k\n            start = L\/\/i\n            length = (r - L + i - 1)\/\/i\n            tot += segs[i][L % i][trans(e[k])].summa(start, start + length)\n        out.append(tot)\n\nprint '\\n'.join(str(x) for x in out)","tags":["strings"],"src_uid":"951b6dfb8d9839857c0c8abd550e9b15"}
{"text_full":"[DESCRIPTION]They say that Berland has exactly two problems, fools and roads. Besides, Berland has n cities, populated by the fools and connected by the roads. All Berland roads are bidirectional. As there are many fools in Berland, between each pair of cities there is a path (or else the fools would get upset). Also, between each pair of cities there is no more than one simple path (or else the fools would get lost). But that is not the end of Berland's special features. In this country fools sometimes visit each other and thus spoil the roads. The fools aren't very smart, so they always use only the simple paths.A simple path is the path which goes through every Berland city not more than once.The Berland government knows the paths which the fools use. Help the government count for each road, how many distinct fools can go on it.Note how the fools' paths are given in the input.[SOURCE CODE]# solved using sparse table\nfrom math import log2\n\ndef construct(root):\n    stack = [root]\n    while stack:\n        u = stack.pop()\n        for v in edges[u]:\n            if v != parents[u]:\n                parents[v] = u\n                levels[v] = levels[u] + 1\n                stack.append(v)\n    table.append(parents)\n    k = 1\n    while (1 << k) < n:\n        new_row = [0] * n\n        for i in range(n):\n            new_row[i] = table[k-1][table[k-1][i]]\n        table.append(new_row)\n        k += 1\n\n\ndef getlca(a, b):  # range MINIMUM query\n    depth_gap = levels[b] - levels[a]\n    if depth_gap < 0: # make sure node b is at a deeper level than node a\n        a, b = b, a\n        depth_gap = -depth_gap\n    if depth_gap != 0:  ## traverse upward from a so that both a and b are at the same level\n        k = int(log2(depth_gap))\n        while depth_gap:\n            if (depth_gap) >= (2**k):\n                b = table[k][b]\n                depth_gap = levels[b] - levels[a]\n            k -= 1\n    if b == a:\n        return a\n    for k in range(logn, -1, -1):\n        if table[k][a] != table[k][b]:\n            a, b = table[k][a], table[k][b]\n    return table[0][a]\n\n\ndef travel(a, b):\n    lca = getlca(a, b)\n    tally[a] += 1\n    tally[b] += 1\n    tally[lca] -= 2\n\n\ndef sum_subtree(root):\n    stack = []\n    for v in edges[root]:\n        stack.append([v, 0])\n    while stack:\n        u, i = stack[-1]\n        if i == len(edges[u]):\n            tally[parents[u]] += tally[u]\n            stack.pop()\n        else:\n            v = edges[u][i]\n            stack[-1][1] += 1\n            if v != parents[u]:\n                stack.append([v, 0])\n\n\ndef count_fools(u, v):\n    if levels[u] > levels[v]:\n        return tally[u]\n    else:\n        return tally[v]\n\n\nn = int(input())\nlogn = int(log2(n))\nedges = [[] for _ in range(n)]\nedges_list = []\nfor i in range(n-1):\n    u, v = map(int, input().split())\n    u, v = u-1, v-1     # adjusting index convention for convenience\n    edges[u].append(v)\n    edges[v].append(u)\n    edges_list.append((u, v))\nparents = [0] * n\nlevels = [0] * n\ntable = []\nroot = 0\nconstruct(root\/\/2)\ntally = [0] * n\nk = int(input())\nfor _ in range(k):\n    a, b = map(int, input().split())\n    travel(a-1, b-1)\nsum_subtree(root)\nfor u, v in edges_list:\n    print(count_fools(u, v), end=' ')\nprint()","tags":["trees"],"src_uid":"d192964daea30c02e7886cab220fd942"}
{"text_full":"[DESCRIPTION]Recently Petya walked in the forest and found a magic stick.Since Petya really likes numbers, the first thing he learned was spells for changing numbers. So far, he knows only two spells that can be applied to a positive integer:   If the chosen number $$$a$$$ is even, then the spell will turn it into $$$\\frac{3a}{2}$$$;  If the chosen number $$$a$$$ is greater than one, then the spell will turn it into $$$a-1$$$. Note that if the number is even and greater than one, then Petya can choose which spell to apply.Petya now has only one number $$$x$$$. He wants to know if his favorite number $$$y$$$ can be obtained from $$$x$$$ using the spells he knows. The spells can be used any number of times in any order. It is not required to use spells, Petya can leave $$$x$$$ as it is.[SOURCE CODE]for _ in range(int(input())):\n    x, y = map(int, input().split())\n    if x >= y:\n        print(\"YES\")\n    elif x <= 3 and y > 3:\n        print(\"NO\")\n    elif x <= 3 and x > 0 and x % 2:\n        print(\"NO\")\n    else:\n        print(\"YES\")","tags":["math"],"src_uid":"b3978805756262e17df738e049830427"}
{"text_full":"[DESCRIPTION]A famous gang of pirates, Sea Dogs, has come back to their hideout from one of their extravagant plunders. They want to split their treasure fairly amongst themselves, that is why You, their trusted financial advisor, devised a game to help them:All of them take a sit at their round table, some of them with the golden coins they have just stolen. At each iteration of the game if one of them has equal or more than 2 coins, he is eligible to the splitting and he gives one coin to each pirate sitting next to him. If there are more candidates (pirates with equal or more than 2 coins) then You are the one that chooses which one of them will do the splitting in that iteration. The game ends when there are no more candidates eligible to do the splitting. Pirates can call it a day, only when the game ends. Since they are beings with a finite amount of time at their disposal, they would prefer if the game that they are playing can end after finite iterations, and if so, they call it a good game. On the other hand, if no matter how You do the splitting, the game cannot end in finite iterations, they call it a bad game. Can You help them figure out before they start playing if the game will be good or bad?[SOURCE CODE]import os\nimport sys\nfrom io import BytesIO, IOBase\n\n\ndef main():\n    pass\n\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\nn, k = map(int, input().split())\ncoins = 0\npos = 0\nfor _ in range(k):\n    a, b = map(int, input().split())\n    coins += b\n    pos += a * b\n    pos %= n\nif coins < n or coins == n and (pos - (n*n-n)\/\/2) % n == 0:\n    print(1)\nelse:\n    print(-1)","tags":["math"],"src_uid":"bde1f233c7a49850c6b906af37982c27"}
{"text_full":"[DESCRIPTION]A very unusual citizen lives in a far away kingdom — Dwarf Gracula. However, his unusual name is not the weirdest thing (besides, everyone long ago got used to calling him simply Dwarf Greg). What is special about Dwarf Greg — he's been living for over 200 years; besides, he lives in a crypt on an abandoned cemetery and nobody has ever seen him out in daytime. Moreover, nobody has ever seen Greg buy himself any food. That's why nobody got particularly surprised when after the infernal dragon's tragic death cattle continued to disappear from fields. The people in the neighborhood were long sure that the harmless dragon was never responsible for disappearing cattle (considering that the dragon used to be sincere about his vegetarian views). But even that's not the worst part of the whole story.The worst part is that merely several minutes ago Dwarf Greg in some unintelligible way got inside your house and asked you to help him solve a problem. The point is that a short time ago Greg decided to order a new coffin (knowing his peculiar character, you are not surprised at all). But the problem is: a very long in both directions L-shaped corridor leads to Greg's crypt, and you can't drag just any coffin through that corridor. That's why he asked you to help.  You've formalized the task on a plane like this: let the corridor's width before and after the turn be equal to a and b correspondingly (see the picture). The corridor turns directly at a right angle, the coffin is a rectangle whose length and width are equal to l and w (l ≥ w) correspondingly. Dwarf Greg has already determined the coffin's length (l), which is based on his height; your task is to determine the coffin's maximally possible width (w), at which it can be brought to the crypt. Besides, due to its large mass (pure marble!) the coffin is equipped with rotating wheels; therefore it is impossible to lift it off the ground, however, arbitrary moves and rotations of the coffin in the plane become possible. The coffin may be rotated arbitrarily just before you drag it into crypt and move through the corridor.Greg promised that if you help him, he will grant you immortality (I wonder how?). And if you don't, well... trust me, you don't want to know what happens if you don't help him...[SOURCE CODE]EPS = 1e-8\n\ndef cross(a, b):\n    return (a[0] * b[1]) - (a[1] * b[0])\n\ndef f(a, b, l, x):\n    y = (l*l - x*x)**0.5\n    return cross( (a-x, b), (-x, y) )\n\ndef main():\n    a, b, l = map(int, raw_input().split())\n\n    if a > b:\n        a, b = b, a\n\n    if l <= a and a <= b:\n        print \"%.9lf\" % l\n    elif a < l and l <= b:\n        print \"%.9lf\" % a\n    else:\n        lo = 0.0\n        hi = float(l)\n\n        while (hi - lo) > EPS:\n            x1 = lo + (hi-lo)\/3.0\n            x2 = lo + (hi-lo)*2.0\/3.0\n\n            if f(a, b, l, x1) > f(a, b, l, x2):\n                lo = x1\n            else:\n                hi = x2\n\n        ans = f(a, b, l, lo) \/ l \n\n        if ans < EPS:\n            print \"My poor head =(\"\n        else:\n            print \"%.9lf\" % ans\n\nif __name__ == \"__main__\":\n    main()","tags":["geometry"],"src_uid":"c4b0f9263e18aac26124829cf3d880b6"}
{"text_full":"[DESCRIPTION]You are given a complete bipartite graph with $$$2n$$$ nodes, with $$$n$$$ nodes on each side of the bipartition. Nodes $$$1$$$ through $$$n$$$ are on one side of the bipartition, and nodes $$$n+1$$$ to $$$2n$$$ are on the other side. You are also given an $$$n \\times n$$$ matrix $$$a$$$ describing the edge weights. $$$a_{ij}$$$ denotes the weight of the edge between nodes $$$i$$$ and $$$j+n$$$. Each edge has a distinct weight.Alice and Bob are playing a game on this graph. First Alice chooses to play as either \"increasing\" or \"decreasing\" for herself, and Bob gets the other choice. Then she places a token on any node of the graph. Bob then moves the token along any edge incident to that node. They now take turns playing the following game, with Alice going first.The current player must move the token from the current vertex to some adjacent unvisited vertex. Let $$$w$$$ be the last weight of the last edge that was traversed. The edge that is traversed must be strictly greater than $$$w$$$ if the player is playing as \"increasing\", otherwise, it must be strictly less. The first player unable to make a move loses.You are given $$$n$$$ and the edge weights of the graph. You can choose to play as either Alice or Bob, and you will play against the judge. You must win all the games for your answer to be judged correct.[SOURCE CODE]import sys\n\ndef stable_marriage(p1, p2):\n    n = len(p1)\n    ret = [-1 for __ in xrange(2*n)]\n\n    free = [True for __ in xrange(n)]\n    nfree = n\n    def engage(m,w):\n        ret[w+n] = m\n        ret[m] = w+n\n        free[m] = False\n\n    while nfree > 0:\n        m = next(i for i in xrange(n) if free[i])\n        idx = 0\n        while free[m]:\n            w = p1[m][idx]\n            if ret[w+n] == -1:\n                engage(m,w)\n                nfree -= 1\n            else:\n                m1 = ret[w+n]\n                if p2[w].index(m) < p2[w].index(m1):\n                    free[m1] = True\n                    ret[m1] = -1\n                    engage(m,w)\n            idx += 1\n    return ret\n\ndef process_one():\n    n = int(raw_input())\n    grid = [map(int, raw_input().split()) for __ in xrange(n)]\n\n    print \"B\"\n    sys.stdout.flush()\n\n    x,d = raw_input().split()\n    d = int(d)\n\n    sign = -1 if ((x == 'I') ^ (d <= n)) else 1\n\n    partner = stable_marriage(\n        [sorted(range(n), key=lambda x: +sign*grid[i][x]) for i in xrange(n)],\n        [sorted(range(n), key=lambda x: -sign*grid[x][i]) for i in xrange(n)],\n    )\n\n    while True:\n        if d == -1: return\n        if d == -2: sys.exit(0)\n        print partner[d-1]+1\n        sys.stdout.flush()\n        d = int(raw_input())\n\nt = int(raw_input())\nfor ___ in xrange(t):\n    process_one()","tags":["games"],"src_uid":"299c209b070e510e7ed3b525f51fec8a"}
{"text_full":"[DESCRIPTION]Creatnx has $$$n$$$ mirrors, numbered from $$$1$$$ to $$$n$$$. Every day, Creatnx asks exactly one mirror \"Am I beautiful?\". The $$$i$$$-th mirror will tell Creatnx that he is beautiful with probability $$$\\frac{p_i}{100}$$$ for all $$$1 \\le i \\le n$$$.Some mirrors are called checkpoints. Initially, only the $$$1$$$st mirror is a checkpoint. It remains a checkpoint all the time.Creatnx asks the mirrors one by one, starting from the $$$1$$$-st mirror. Every day, if he asks $$$i$$$-th mirror, there are two possibilities:  The $$$i$$$-th mirror tells Creatnx that he is beautiful. In this case, if $$$i = n$$$ Creatnx will stop and become happy, otherwise he will continue asking the $$$i+1$$$-th mirror next day;  In the other case, Creatnx will feel upset. The next day, Creatnx will start asking from the checkpoint with a maximal number that is less or equal to $$$i$$$. There are some changes occur over time: some mirrors become new checkpoints and some mirrors are no longer checkpoints. You are given $$$q$$$ queries, each query is represented by an integer $$$u$$$: If the $$$u$$$-th mirror isn't a checkpoint then we set it as a checkpoint. Otherwise, the $$$u$$$-th mirror is no longer a checkpoint.After each query, you need to calculate the expected number of days until Creatnx becomes happy.Each of this numbers should be found by modulo $$$998244353$$$. Formally, let $$$M = 998244353$$$. It can be shown that the answer can be expressed as an irreducible fraction $$$\\frac{p}{q}$$$, where $$$p$$$ and $$$q$$$ are integers and $$$q \\not \\equiv 0 \\pmod{M}$$$. Output the integer equal to $$$p \\cdot q^{-1} \\bmod M$$$. In other words, output such an integer $$$x$$$ that $$$0 \\le x &lt; M$$$ and $$$x \\cdot q \\equiv p \\pmod{M}$$$.[SOURCE CODE]from __future__ import division, print_function\n\ndef main():\n    n, qs = input_as_list()\n    cpn = ceil_power_of_2(n)\n    st = array_of(int, n+1)\n    switch = array_of(bool, n)\n\n    def update(i, v):\n        while i < n:\n            st[i] += v\n            i |= i+1\n\n    def query(i):\n        res = 0\n        while i > 0:\n            res += st[i-1]\n            i &= i-1\n        return res\n\n    def lower_bound(s):\n        if s <= 0: return -1\n        pos = 0\n        pw = cpn\n        while pw > 0:\n            if (pos + pw <= n) and (st[pos + pw-1] < s):\n                pos += pw\n                s -= st[pos-1]\n            pw \/\/= 2\n        return pos\n\n    def insert(i):\n        update(i, +1)\n\n    def remove(i):\n        update(i, -1)\n\n    def find_by_order(i):\n        return lower_bound(i)\n\n    def order_of(i):\n        return query(i)\n\n    def lr(i):\n        o = order_of(i)\n        l = find_by_order(o)\n        r = find_by_order(o+1)\n        return l, r\n\n    ar = input_as_list()\n    s1 = [0]\n    for x in ar:\n        v = s1[-1]+1\n        v = mulmod(v, 100)\n        v = divmod(v, x)\n        s1.append(v)\n    s2 = [1]\n    for x in ar:\n        v = s2[-1]\n        v = mulmod(v, 100)\n        v = divmod(v, x)\n        s2.append(v)\n\n    def f(l, r):\n        if r <= l:\n            return 0\n        a = s1[r]\n        b = mulmod(s1[l], s2[r])\n        b = divmod(b, s2[l])\n        return (a-b)%MOD\n\n    insert(0)\n    insert(n)\n    ans = s1[-1]\n    for _ in range(qs):\n        q = int(input())-1\n        if switch[q]:\n            remove(q)\n            l, r = lr(q)\n            ans = (ans + f(l, r)) % MOD\n            ans = (ans - f(l, q)) % MOD\n            ans = (ans - f(q, r)) % MOD\n        else:\n            l, r = lr(q)\n            ans = (ans - f(l, r)) % MOD\n            ans = (ans + f(l, q)) % MOD\n            ans = (ans + f(q, r)) % MOD\n            insert(q)\n        switch[q] ^= True\n        print(ans)\n\n\nINF = float('inf')\nMOD = 998244353\n__interactive = False\n\nimport os, sys\nfrom atexit import register\nfrom io import BytesIO\nimport itertools\nimport __pypy__\n\nif sys.version_info[0] < 3:\n    input = raw_input\n    range = xrange\n\n    filter = itertools.ifilter\n    map = itertools.imap\n    zip = itertools.izip\n\nif \"LOCAL_\" in os.environ:\n    debug_print = print\nelse:\n    if not __interactive:\n        sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))\n        sys.stdout = BytesIO()\n        register(lambda: os.write(1, sys.stdout.getvalue()))\n\n        input = lambda: sys.stdin.readline().rstrip('\\r\\n')\n    debug_print = lambda *x, **y: None\n\nflush = sys.stdout.flush\n\ndef mulmod(x, y):\n    return __pypy__.intop.int_mulmod(x, y, MOD)\n\ndef modinv(x):\n    return pow(x, MOD-2, MOD)\n\ndef divmod(x, y):\n    return mulmod(x, modinv(y))\n\ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n    \ndef input_as_list():\n    return list(map(int, input().split()))\n\ndef input_with_offset(o):\n    return list(map(lambda x:int(x)+o, input().split()))\n    \ndef input_as_matrix(n, m):\n    return [input_as_list() for _ in range(n)]\n    \ndef array_of(f, *dim):\n    return [array_of(f, *dim[1:]) for _ in range(dim[0])] if dim else f()\n\ndef range_with_count(start, step, count):\n    return range(start, start + step * count, step)\n\ndef indices(l, start=0, end=0):\n    return range(start, len(l)+end)\n\ndef ceil_power_of_2(n):\n    \"\"\" [0, 1, 2, 4, 4, 8, 8, 8, 8, 16, 16, ...] \"\"\"\n    return 2 ** ((n - 1).bit_length())\n\ndef ceil_div(x, r):\n    \"\"\" = ceil(x \/ r) \"\"\"\n    return (x + r - 1) \/\/ r\n    \nmain()","tags":["probabilities"],"src_uid":"1461fca52a0310fff725b476bfbd3b29"}
{"text_full":"[DESCRIPTION]A big football championship will occur soon! $$$n$$$ teams will compete in it, and each pair of teams will play exactly one game against each other.There are two possible outcomes of a game:  the game may result in a tie, then both teams get $$$1$$$ point;  one team might win in a game, then the winning team gets $$$3$$$ points and the losing team gets $$$0$$$ points. The score of a team is the number of points it gained during all games that it played.You are interested in a hypothetical situation when all teams get the same score at the end of the championship. A simple example of that situation is when all games result in ties, but you want to minimize the number of ties as well.Your task is to describe a situation (choose the result of each game) so that all teams get the same score, and the number of ties is the minimum possible.[SOURCE CODE]for _ in range(int(input())):\r\n    n = int(input())\r\n    if n % 2 == 1:\r\n        cnt = 1\r\n        for i in range(n * (n - 1) \/\/ 2):\r\n            print(cnt, end=\" \")\r\n            if cnt == 1:\r\n                cnt = -1\r\n            else:\r\n                cnt = 1\r\n        print()\r\n    else:\r\n        for i in range(n):\r\n            for j in range(i + 1, n):\r\n                if j - i == n \/ 2:\r\n                    print(0, end=\" \")\r\n                elif j - i <= (n - 2) \/ 2:\r\n                    print(1, end=\" \")\r\n                else:\r\n                    print(-1, end=\" \")\r\n        print()","tags":["graphs","math"],"src_uid":"a89c585ebd9608141399c813385c04c6"}
{"text_full":"[DESCRIPTION]Suppose you are living with two cats: A and B. There are $$$n$$$ napping spots where both cats usually sleep.Your cats like to sleep and also like all these spots, so they change napping spot each hour cyclically:   Cat A changes its napping place in order: $$$n, n - 1, n - 2, \\dots, 3, 2, 1, n, n - 1, \\dots$$$ In other words, at the first hour it's on the spot $$$n$$$ and then goes in decreasing order cyclically;  Cat B changes its napping place in order: $$$1, 2, 3, \\dots, n - 1, n, 1, 2, \\dots$$$ In other words, at the first hour it's on the spot $$$1$$$ and then goes in increasing order cyclically. The cat B is much younger, so they have a strict hierarchy: A and B don't lie together. In other words, if both cats'd like to go in spot $$$x$$$ then the A takes this place and B moves to the next place in its order (if $$$x &lt; n$$$ then to $$$x + 1$$$, but if $$$x = n$$$ then to $$$1$$$). Cat B follows his order, so it won't return to the skipped spot $$$x$$$ after A frees it, but will move to the spot $$$x + 2$$$ and so on.Calculate, where cat B will be at hour $$$k$$$?[SOURCE CODE]import io,os\r\ninput=io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\r\n#print(os.fstat(0).st_size)\r\nfor _ in range(int(input())):\r\n    n,k=map(int,input().split())\r\n    k-=1\r\n    print((k+n%2*(k\/\/(n\/\/2)))%n+1)","tags":["math","number theory"],"src_uid":"2e837d3afc48177516578a950e957586"}
{"text_full":"[DESCRIPTION]Stanley lives in a country that consists of $$$n$$$ cities (he lives in city $$$1$$$). There are bidirectional roads between some of the cities, and you know how long it takes to ride through each of them. Additionally, there is a flight between each pair of cities, the flight between cities $$$u$$$ and $$$v$$$ takes $$$(u - v)^2$$$ time.Stanley is quite afraid of flying because of watching \"Sully: Miracle on the Hudson\" recently, so he can take at most $$$k$$$ flights. Stanley wants to know the minimum time of a journey to each of the $$$n$$$ cities from the city $$$1$$$.[SOURCE CODE]from sys import stdin\r\ninput=lambda :stdin.readline()[:-1]\r\n\r\nn,m,k=map(int,input().split())\r\nedge=[[] for i in range(n)]\r\nfor _ in range(m):\r\n  a,b,c=map(int,input().split())\r\n  a,b=a-1,b-1\r\n  edge[a].append((b,c))\r\n  edge[b].append((a,c))\r\n\r\nfrom heapq import heappop,heappush\r\n\r\nmask=(1<<17)-1\r\ndef dijkstra():\r\n  hq=[]\r\n  for i in range(n):\r\n    if dist[i]!=inf:\r\n      heappush(hq,(dist[i]<<17)+i)\r\n  seen=[0]*n\r\n  while hq:\r\n    x=heappop(hq)\r\n    w,v=x>>17,x&mask\r\n    if dist[v]<w:\r\n      continue\r\n    seen[v]=True\r\n    for to,cost in edge[v]:\r\n      if seen[to]==False and dist[v]+cost<dist[to]:\r\n        dist[to]=dist[v]+cost\r\n        heappush(hq,(dist[to]<<17)+to)\r\n\r\nfrom collections import deque\r\n\r\nclass ConvexHullTrick():\r\n  # 追加する直線の傾きが単調\r\n  # 計算する x 座標が単調\r\n  # O(N+Q)\r\n  \r\n  def __init__(self):\r\n    self.deq=deque()\r\n  \r\n  def check(self,f1,f2,f3):\r\n    return (f2[0]-f1[0])*(f3[1]-f2[1])>=(f2[1]-f1[1])*(f3[0]-f2[0])\r\n  \r\n  def f(self,f1,x):\r\n    return f1[0]*x+f1[1]\r\n  \r\n  # add f_i(x)=a*x+b\r\n  def add_line(self,a,b):\r\n    f1=(a,b)\r\n    while len(self.deq)>=2 and self.check(self.deq[-2],self.deq[-1],f1):\r\n      self.deq.pop()\r\n    self.deq.append(f1)\r\n  \r\n  # min f_i(x)\r\n  def query(self,x):\r\n    while len(self.deq)>=2 and self.f(self.deq[0],x)>=self.f(self.deq[1],x):\r\n      self.deq.popleft()\r\n    return self.f(self.deq[0],x)\r\n\r\n\r\ninf=1<<60\r\ndist=[inf]*n\r\ndist[0]=0\r\ndijkstra()\r\n\r\nfor _ in range(k):\r\n  CHT=ConvexHullTrick()\r\n  for i in range(n):\r\n    CHT.add_line(-2*i,dist[i]+i*i)\r\n  \r\n  for i in range(n):\r\n    dist[i]=CHT.query(i)+i*i\r\n  dijkstra()\r\n\r\nprint(*dist)","tags":["geometry","graphs"],"src_uid":"261b22421590cf6bb1d602e1dc7e0243"}
{"text_full":"[DESCRIPTION]For an array $$$b$$$ of $$$n$$$ integers, the extreme value of this array is the minimum number of times (possibly, zero) the following operation has to be performed to make $$$b$$$ non-decreasing:   Select an index $$$i$$$ such that $$$1 \\le i \\le |b|$$$, where $$$|b|$$$ is the current length of $$$b$$$.  Replace $$$b_i$$$ with two elements $$$x$$$ and $$$y$$$ such that $$$x$$$ and $$$y$$$ both are positive integers and $$$x + y = b_i$$$.  This way, the array $$$b$$$ changes and the next operation is performed on this modified array. For example, if $$$b = [2, 4, 3]$$$ and index $$$2$$$ gets selected, then the possible arrays after this operation are $$$[2, \\underline{1}, \\underline{3}, 3]$$$, $$$[2, \\underline{2}, \\underline{2}, 3]$$$, or $$$[2, \\underline{3}, \\underline{1}, 3]$$$. And consequently, for this array, this single operation is enough to make it non-decreasing: $$$[2, 4, 3] \\rightarrow [2, \\underline{2}, \\underline{2}, 3]$$$.It's easy to see that every array of positive integers can be made non-decreasing this way.YouKn0wWho has an array $$$a$$$ of $$$n$$$ integers. Help him find the sum of extreme values of all nonempty subarrays of $$$a$$$ modulo $$$998\\,244\\,353$$$. If a subarray appears in $$$a$$$ multiple times, its extreme value should be counted the number of times it appears.An array $$$d$$$ is a subarray of an array $$$c$$$ if $$$d$$$ can be obtained from $$$c$$$ by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.[SOURCE CODE]import sys\r\n\r\ninput = sys.stdin.readline\r\nMOD = 998244353\r\n\r\n\r\n\r\nt=int(input())\r\nfor _ in range(t):\r\n    n = int(input())\r\n    A = list(map(int, input().split()))\r\n    cnt = {}\r\n    ans = 0\r\n\r\n    for l in range(n - 1, -1, -1):\r\n        cnt2 = {}\r\n        a = A[l]\r\n        for k, v in cnt.items():\r\n\r\n            tmp = (a + k - 1) \/\/ k    # k: y  ; tmp : K or ceil(ar[i]\/y) ;\r\n            x = a \/\/ tmp\r\n            if x in cnt2:\r\n                cnt2[x] += v\r\n            else:\r\n                cnt2[x] = v\r\n            ans += (tmp - 1) * (l + 1) * v\r\n            ans %= MOD\r\n        cnt = cnt2\r\n        if a in cnt:\r\n            cnt[a] += 1\r\n        else:\r\n            cnt[a] = 1\r\n\r\n    print(ans)","tags":["number theory"],"src_uid":"f760f108c66f695e1e51dc6470d29ce7"}
{"text_full":"[DESCRIPTION]After Fox Ciel got off a bus, she found that the bus she was on was a wrong bus and she lost her way in a strange town. However, she fortunately met her friend Beaver Taro and asked which way to go to her castle. Taro's response to her was a string s, and she tried to remember the string s correctly.However, Ciel feels n strings b1, b2, ... , bn are really boring, and unfortunately she dislikes to remember a string that contains a boring substring. To make the thing worse, what she can remember is only the contiguous substring of s.Determine the longest contiguous substring of s that does not contain any boring string, so that she can remember the longest part of Taro's response.[SOURCE CODE]s = raw_input().strip()\nkeys = [ None for i in range(int(raw_input())) ]\nfor i in range(len(keys)):\n    keys[i] = raw_input().strip()\nbest_length, best_pos = 0, 0\n\ndef kosher(left, right):\n    pos_range = range(right - 1, left - 1, -1)\n    for key in keys:\n        if len(key) > right - left:\n            continue\n        for pos in pos_range:\n            key_pos = len(key) - right + pos\n            if key_pos == -1 or key[key_pos] != s[pos]:\n                break\n            if key_pos == 0:\n                return False\n    return True\n\nleft, right = 0, 0\nwhile True:\n        if kosher(left, right + 1):\n            right += 1\n            length = right - left\n            if length > best_length:\n                best_length = length\n                best_pos = left\n            if right == len(s):\n                break\n        else:\n            left += 1\n\nprint('%d %d' % (best_length, best_pos))","tags":["strings"],"src_uid":"b5f5fc50e36b2afa3b5f16dacdf5710b"}
{"text_full":"[DESCRIPTION]You are given a multiset (i. e. a set that can contain multiple equal integers) containing $$$2n$$$ integers. Determine if you can split it into exactly $$$n$$$ pairs (i. e. each element should be in exactly one pair) so that the sum of the two elements in each pair is odd (i. e. when divided by $$$2$$$, the remainder is $$$1$$$).[SOURCE CODE]for _ in range(int(input())):\r\n    n = int(input())\r\n    # n, m = map(int, input().split())\r\n    arr = sorted(list(map(int, input().split())))\r\n\r\n    odd = 0\r\n    even = 0\r\n\r\n    for i in range(n*2):\r\n        if arr[i] % 2 == 0:\r\n            even += 1\r\n        else:\r\n            odd += 1\r\n\r\n    if odd == 2 and even == 0:\r\n        print(\"No\")\r\n    elif odd == even:\r\n        print(\"Yes\")\r\n    else:\r\n        print(\"No\")","tags":["math"],"src_uid":"d5bd27c969d9cd910f13baa53c247871"}
{"text_full":"[DESCRIPTION]This version of the problem differs from the next one only in the constraint on $$$n$$$.A tree is a connected undirected graph without cycles. A weighted tree has a weight assigned to each edge. The distance between two vertices is the minimum sum of weights on the path connecting them.You are given a weighted tree with $$$n$$$ vertices, each edge has a weight of $$$1$$$. Denote $$$d(v)$$$ as the distance between vertex $$$1$$$ and vertex $$$v$$$.Let $$$f(x)$$$ be the minimum possible value of $$$\\max\\limits_{1 \\leq v \\leq n} \\ {d(v)}$$$ if you can temporarily add an edge with weight $$$x$$$ between any two vertices $$$a$$$ and $$$b$$$ $$$(1 \\le a, b \\le n)$$$. Note that after this operation, the graph is no longer a tree.For each integer $$$x$$$ from $$$1$$$ to $$$n$$$, find $$$f(x)$$$.[SOURCE CODE]from sys import stdin\r\ninp = stdin.readline\r\n\r\nt = int(inp())\r\n\r\nfor _ in range(t):\r\n    n = int(inp())\r\n    tree = {i: [set(), 0, 0] for i in range(1, n+1)}\r\n\r\n    for i in range(n-1):\r\n        a, b = map(int, inp().split())\r\n        tree[a][0].add(b)\r\n        tree[b][0].add(a)\r\n\r\n    layer = 0\r\n    arr = [set(tree[1][0])]\r\n    branch = [1]\r\n    dist = 0\r\n    dBranch = []\r\n\r\n    while True:\r\n        if not arr[layer]:\r\n            if layer > dist:\r\n                dBranch = branch[:]\r\n                dist = layer\r\n\r\n            for c in tree[branch[layer]][0]:\r\n                if c != branch[layer-1] or layer == 0:\r\n                    if tree[c][1] + 1 > tree[branch[layer]][1]:\r\n                        tree[branch[layer]][2] = tree[branch[layer]][1]\r\n                        tree[branch[layer]][1] = tree[c][1] + 1\r\n                    elif tree[c][1] + 1 > tree[branch[layer]][2]:\r\n                        tree[branch[layer]][2] = tree[c][1] + 1\r\n\r\n            layer -= 1\r\n\r\n            if layer == -1:\r\n                break\r\n\r\n            arr.pop()\r\n            branch.pop()\r\n\r\n        else:\r\n            current = arr[layer].pop()\r\n            arr.append(set(tree[current][0]))\r\n            branch.append(current)\r\n            arr[layer+1].discard(branch[layer])\r\n            layer += 1\r\n\r\n    longest = []\r\n    for i in range(len(dBranch)):\r\n        longest.append([i + (dist - tree[dBranch[i]][2] - i)\/\/2, tree[dBranch[i]][2], i])\r\n\r\n    longest.sort()\r\n\r\n    ans = [0]*n\r\n    x = 0\r\n    last = 0\r\n\r\n    for c in longest:\r\n        while x+1 < 2*c[2] - c[0]:\r\n            ans[x] = max(dist - c[0] + x + 1, last)\r\n            x += 1\r\n        last = max(c[1]+c[2], last)\r\n\r\n    while x < n:\r\n        ans[x] = dist\r\n        x += 1\r\n\r\n    print(*ans)","tags":["graphs","trees"],"src_uid":"d7c2789c5fb216f1de4a99657ffafb4d"}
{"text_full":"[DESCRIPTION]Igor is in 11th grade. Tomorrow he will have to write an informatics test by the strictest teacher in the school, Pavel Denisovich. Igor knows how the test will be conducted: first of all, the teacher will give each student two positive integers $$$a$$$ and $$$b$$$ ($$$a &lt; b$$$). After that, the student can apply any of the following operations any number of times:   $$$a := a + 1$$$ (increase $$$a$$$ by $$$1$$$),  $$$b := b + 1$$$ (increase $$$b$$$ by $$$1$$$),  $$$a := a \\ | \\ b$$$ (replace $$$a$$$ with the bitwise OR of $$$a$$$ and $$$b$$$). To get full marks on the test, the student has to tell the teacher the minimum required number of operations to make $$$a$$$ and $$$b$$$ equal.Igor already knows which numbers the teacher will give him. Help him figure out what is the minimum number of operations needed to make $$$a$$$ equal to $$$b$$$.[SOURCE CODE]for _ in range(int(input())):\r\n    a, b = map(int, input().split())\r\n    ans = b - a\r\n    for i in range(0,a+1):\r\n        if (a+i)|b==b:\r\n            ans = min(ans, i+1)\r\n            break\r\n    for i in range(b+1):\r\n        if (b+i)|a==(b+i):\r\n            ans = min(ans,i+1)\r\n            break\r\n    print(ans)","tags":["math"],"src_uid":"eed751c881767ecd978a728d980da594"}
{"text_full":"[DESCRIPTION]Alice and Bob are playing a game. They start with a positive integer $$$n$$$ and take alternating turns doing operations on it. Each turn a player can subtract from $$$n$$$ one of its divisors that isn't $$$1$$$ or $$$n$$$. The player who cannot make a move on his\/her turn loses. Alice always moves first.Note that they subtract a divisor of the current number in each turn.You are asked to find out who will win the game if both players play optimally.[SOURCE CODE]import sys\n\ninput = sys.stdin.readline\ninf = float('inf')\n\n\ndef getInt():\n    return int(input())\n\n\ndef getStr():\n    return input().strip()\n\n\ndef getList(split=True):\n    s = getStr()\n    if split:\n        s = s.split()\n    return map(int, s)\n\n\nt = getInt()\n# t = 1\n\nM = 10 ** 9 + 7\n\nA = {2**i for i in range(1, 32, 2)}\n\n\ndef solve():\n    # if x is a power of 2 then Alice loose\n    # if x is odd of x is  2 to the power off odd number then Alice loose else she will win\n    x = getInt()\n\n    if x & 1 or x in A:\n        print(\"Bob\")\n    else:\n        print(\"Alice\")\n\n\nfor _ in range(t):\n    solve()","tags":["games","math","number theory"],"src_uid":"255ee92f5b860eacd9d6321195072734"}
{"text_full":"[DESCRIPTION]Kirill lives on a connected undirected graph of $$$n$$$ vertices and $$$m$$$ edges at vertex $$$1$$$. One fine evening he gathered $$$f$$$ friends, the $$$i$$$-th friend lives at the vertex $$$h_i$$$. So all friends are now in the vertex $$$1$$$, the $$$i$$$-th friend must get to his home to the vertex $$$h_i$$$.The evening is about to end and it is time to leave. It turned out that $$$k$$$ ($$$k \\le 6$$$) of his friends have no cars, and they would have to walk if no one gives them a ride. One friend with a car can give a ride to any number of friends without cars, but only if he can give them a ride by driving along one of the shortest paths to his house.For example, in the graph below, a friend from vertex $$$h_i=5$$$ can give a ride to friends from the following sets of vertices: $$$[2, 3]$$$, $$$[2, 4]$$$, $$$[2]$$$, $$$[3]$$$, $$$[4]$$$, but can't give a ride to friend from vertex $$$6$$$ or a set $$$[3, 4]$$$.    The vertices where friends without cars live are highlighted in green, and with cars — in red. Kirill wants as few friends as possible to have to walk. Help him find the minimum possible number.[SOURCE CODE]from collections import deque\r\n \r\n \r\ndef solve():\r\n    n, m = map(int, input().split())\r\n    sl = [[] for _ in range(n)]\r\n    for _ in range(m):\r\n        u, v = map(int, input().split())\r\n        u -= 1\r\n        v -= 1\r\n        sl[u] += [v]\r\n        sl[v] += [u]\r\n    f = int(input())\r\n    h = [int(x) - 1 for x in input().split()]\r\n    mask = [0] * n\r\n    k = int(input())\r\n    p = [int(x) - 1 for x in input().split()] + [-1]\r\n    for i in range(k):\r\n        mask[h[p[i]]] += 1 << i\r\n    vars = [set() for _ in range(n)]\r\n    dist = [-1] * n\r\n    dist[0] = 0\r\n    vars[0].add(mask[0])\r\n    q = deque([0])\r\n    while len(q) > 0:\r\n        v = q.popleft()\r\n        for u in sl[v]:\r\n            if dist[u] == -1:\r\n                dist[u] = dist[v] + 1\r\n                q.append(u)\r\n            if dist[u] == dist[v] + 1:\r\n                for msk in vars[v]:\r\n                    vars[u].add(msk | mask[u])\r\n    backpack = [False] * (1 << k)\r\n    backpack[0] = True\r\n    j = 0\r\n    for i in range(f):\r\n        if i == p[j]:\r\n            j += 1\r\n            continue\r\n        nw = backpack.copy()\r\n        for msk in range(1 << k):\r\n            if not backpack[msk]:\r\n                continue\r\n            for var in vars[h[i]]:\r\n                nw[msk | var] = True\r\n        backpack = nw\r\n    mn = k\r\n    for msk in range(1 << k):\r\n        if not backpack[msk]:\r\n            continue\r\n        ans = 0\r\n        for b in range(k):\r\n            if msk & (1 << b) == 0:\r\n                ans += 1\r\n        mn = min(mn, ans)\r\n    print(mn)\r\n \r\n \r\nt = int(input())\r\nfor _ in range(t):\r\n    solve()","tags":["graphs"],"src_uid":"81122f1a525ac6e80b1d9c2adc735f6f"}
{"text_full":"[DESCRIPTION]You are given an array $$$a$$$ consisting of $$$n$$$ positive integers, and an array $$$b$$$, with length $$$n$$$. Initially $$$b_i=0$$$ for each $$$1 \\leq i \\leq n$$$.In one move you can choose an integer $$$i$$$ ($$$1 \\leq i \\leq n$$$), and add $$$a_i$$$ to $$$b_i$$$ or subtract $$$a_i$$$ from $$$b_i$$$. What is the minimum number of moves needed to make $$$b$$$ increasing (that is, every element is strictly greater than every element before it)?[SOURCE CODE]n = int(input())\r\na = list(map(int, input().split()))\r\nMin = 1e18\r\nfor l in range(n - 1):\r\n    m = a[l]\r\n    answer = 1\r\n    for i in range(l-1, -1, -1):\r\n        answer += (m + a[i]) \/\/ a[i]\r\n        m = a[i] * ((m + a[i]) \/\/ a[i])\r\n   # if l + 1 < n:\r\n    m = 0\r\n    for i in range(l + 2, n):\r\n        answer += (m + a[i]) \/\/ a[i]\r\n        m = a[i] * ((m + a[i]) \/\/ a[i])\r\n    Min = min(answer, Min)\r\nprint(Min)","tags":["math"],"src_uid":"da2fb0ea61808905a133021223f6148d"}
{"text_full":"[DESCRIPTION]You are playing a game on a $$$n \\times m$$$ grid, in which the computer has selected some cell $$$(x, y)$$$ of the grid, and you have to determine which one. To do so, you will choose some $$$k$$$ and some $$$k$$$ cells $$$(x_1, y_1),\\, (x_2, y_2), \\ldots, (x_k, y_k)$$$, and give them to the computer. In response, you will get $$$k$$$ numbers $$$b_1,\\, b_2, \\ldots b_k$$$, where $$$b_i$$$ is the manhattan distance from $$$(x_i, y_i)$$$ to the hidden cell $$$(x, y)$$$ (so you know which distance corresponds to which of $$$k$$$ input cells). After receiving these $$$b_1,\\, b_2, \\ldots, b_k$$$, you have to be able to determine the hidden cell. What is the smallest $$$k$$$ for which is it possible to always guess the hidden cell correctly, no matter what cell computer chooses?As a reminder, the manhattan distance between cells $$$(a_1, b_1)$$$ and $$$(a_2, b_2)$$$ is equal to $$$|a_1-a_2|+|b_1-b_2|$$$.[SOURCE CODE]import math\r\n\r\nN = int(input())\r\nfor tt in range(N):\r\n    ss = input().split(' ')\r\n    a,b = int(ss[0]),int(ss[1])\r\n    st = {}\r\n    if a == 1 and b == 1:\r\n        print(0)\r\n        continue\r\n    elif a == 1 or b == 1:\r\n        print(1)\r\n        continue\r\n    \r\n    t = min(a,b)\r\n    print(2)","tags":["math"],"src_uid":"e5a01ebfdca3af987e93b68c96268c16"}
{"text_full":"[DESCRIPTION]Lee was planning to get closer to Mashtali's heart to proceed with his evil plan(which we're not aware of, yet), so he decided to beautify Mashtali's graph. But he made several rules for himself. And also he was too busy with his plans that he didn't have time for such minor tasks, so he asked you for help.Mashtali's graph is an undirected weighted graph with $$$n$$$ vertices and $$$m$$$ edges with weights equal to either $$$1$$$ or $$$2$$$. Lee wants to direct the edges of Mashtali's graph so that it will be as beautiful as possible.Lee thinks that the beauty of a directed weighted graph is equal to the number of its Oddysey vertices. A vertex $$$v$$$ is an Oddysey vertex if $$$|d^+(v) - d^-(v)| = 1$$$, where $$$d^+(v)$$$ is the sum of weights of the outgoing from $$$v$$$ edges, and $$$d^-(v)$$$ is the sum of the weights of the incoming to $$$v$$$ edges.Find the largest possible beauty of a graph that Lee can achieve by directing the edges of Mashtali's graph. In addition, find any way to achieve it.Note that you have to orient each edge.[SOURCE CODE]import sys\r\ninput = sys.stdin.readline\r\n\r\nn, m = map(int, input().split())\r\nadj1 = [[] for _ in range(n)]\r\nadj2 = [[] for _ in range(n)]\r\n\r\nedges = []\r\n\r\noutv = 0\r\noutvv = 0\r\n\r\ndeg1 = [0] * n\r\ndeg2 = [0] * n\r\nparO = []\r\nparP = []\r\nfor e in range(m):\r\n    u, v, w = map(int, input().split())\r\n    u -= 1\r\n    v -= 1\r\n\r\n    parO.append(u)\r\n    parP.append(v)\r\n    \r\n    if w == 1:\r\n        adj1[u].append((v,e))\r\n        adj1[v].append((u,e))\r\n        deg1[u] += 1\r\n        deg1[v] += 1\r\n    else:\r\n        adj2[u].append((v,e))\r\n        adj2[v].append((u,e))\r\n        deg2[u] += 1\r\n        deg2[v] += 1\r\n\r\nused = [False] * m\r\n\r\n# w = 1\r\np1 = []\r\np1e = []\r\nfor curr in range(n):\r\n    if deg1[curr] % 2 == 0:\r\n        continue\r\n    else:\r\n        outvv += 1\r\n    \r\n    u = curr\r\n    path = [u]\r\n    pe = []\r\n    while adj1[u]:\r\n        v, e = adj1[u].pop()\r\n        if not used[e]:\r\n            path.append(v)\r\n            pe.append(e)\r\n            u = v\r\n            used[e] = True\r\n    if len(path) > 1:\r\n        outv += 1\r\n        p1.append(path)\r\n        p1e.append(pe)\r\n\r\ncurr = 0\r\nwhile curr < n:\r\n    u = curr\r\n    path = [u]\r\n    pe = []\r\n    while adj1[u]:\r\n        v, e = adj1[u].pop()\r\n        if not used[e]:\r\n            path.append(v)\r\n            pe.append(e)\r\n            u = v\r\n            used[e] = True\r\n    if len(path) > 1:\r\n        p1.append(path)\r\n        p1e.append(pe)\r\n    else:\r\n        curr += 1\r\n\r\n# w = 2\r\np2 = []\r\np2e = []\r\nfor curr in range(n):\r\n    if deg2[curr] % 2 == 0:\r\n        continue\r\n    u = curr\r\n    path = [u]\r\n    pe = []\r\n    while adj2[u]:\r\n        v, e = adj2[u].pop()\r\n        if not used[e]:\r\n            path.append(v)\r\n            pe.append(e)\r\n            u = v\r\n            used[e] = True\r\n    if len(path) > 1:\r\n        p2.append(path)\r\n        p2e.append(pe)\r\n        \r\ncurr = 0\r\nwhile curr < n:\r\n    u = curr\r\n    path = [u]\r\n    pe = []\r\n    while adj2[u]:\r\n        v, e = adj2[u].pop()\r\n        if not used[e]:\r\n            path.append(v)\r\n            pe.append(e)\r\n            u = v\r\n            used[e] = True\r\n    if len(path) > 1:\r\n        p2.append(path)\r\n        p2e.append(pe)\r\n    else:\r\n        curr += 1\r\n\r\nassert(all(used))\r\n\r\nadj3 = list(range(n))\r\nadj4 = list(range(n))\r\nfor p in p1:\r\n    if p[0] != p[-1]:\r\n        adj3[p[0]] = p[-1]\r\n        adj3[p[-1]] = p[0]\r\nfor p in p2:\r\n    if p[0] != p[-1]:\r\n        adj4[p[0]] = p[-1]\r\n        adj4[p[-1]] = p[0]\r\n\r\ncolors = [0] * n\r\nfor i in range(n):\r\n    if colors[i] == 0:\r\n        stack = [i]\r\n        colors[i] = 1\r\n        while stack:\r\n            nex = stack.pop()\r\n            if colors[adj3[nex]] == 0:\r\n                colors[adj3[nex]] = -colors[nex]\r\n                stack.append(adj3[nex])\r\n            if colors[adj4[nex]] == 0:\r\n                colors[adj4[nex]] = -colors[nex]\r\n                stack.append(adj4[nex])\r\n\r\npar = [-1] * m\r\nfor i in range(len(p1)):\r\n    p = p1[i]\r\n    pe = p1e[i]\r\n    \r\n    assert p[0] == p[-1] or colors[p[0]] != colors[p[-1]]\r\n    \r\n    if colors[p[0]] == 1:\r\n        for v, e in zip(p[:-1], pe):\r\n            par[e] = v\r\n    else:\r\n        for v, e in zip(p[1:], pe):\r\n            par[e] = v\r\n\r\nfor i in range(len(p2)):\r\n    p = p2[i]\r\n    pe = p2e[i]\r\n\r\n    assert p[0] == p[-1] or colors[p[0]] != colors[p[-1]]\r\n    \r\n    if colors[p[0]] == -1:\r\n        for v, e in zip(p[:-1], pe):\r\n            par[e] = v\r\n    else:\r\n        for v, e in zip(p[1:], pe):\r\n            par[e] = v\r\n\r\nout = []\r\nfor i in range(m):\r\n    assert par[i] != -1\r\n    if par[i] == parO[i]:\r\n        out.append(1)\r\n    else:\r\n        assert par[i] == parP[i]\r\n        out.append(2)\r\n\r\nassert outvv == 2 * outv\r\nprint(2 * outv)\r\nprint(''.join(map(str,out)))","tags":["graphs"],"src_uid":"ad3f798f00cc9f3e3c9df932c2459ca3"}
{"text_full":"[DESCRIPTION]On the great island of Baltia, there live $$$N$$$ people, numbered from $$$1$$$ to $$$N$$$. There are exactly $$$M$$$ pairs of people that are friends with each other. The people of Baltia want to organize a successful party, but they have very strict rules on what a party is and when the party is successful. On the island of Baltia, a party is a gathering of exactly $$$5$$$ people. The party is considered to be successful if either all the people at the party are friends with each other (so that they can all talk to each other without having to worry about talking to someone they are not friends with) or no two people at the party are friends with each other (so that everyone can just be on their phones without anyone else bothering them). Please help the people of Baltia organize a successful party or tell them that it's impossible to do so.[SOURCE CODE]import sys\r\ninput = sys.stdin.buffer.readline \r\n\r\ndef process(n, G):\r\n    n = min(n, 1000)\r\n    M = [[0 for j in range(n+1)] for i in range(n+1)]\r\n    for u, v in G:\r\n        if max(u, v) <= n:\r\n            M[u][v] = 1\r\n            M[v][u] = 1\r\n    all_connect = []\r\n    no_connect = []\r\n    if M[1][2] == 1:\r\n        all_connect.append([1, 2])\r\n    else:\r\n        no_connect.append([1, 2])\r\n    for i in range(3, n+1):\r\n        new_all_connect = []\r\n        new_no_connect = []\r\n        for i2 in range(1, i):\r\n            if M[i][i2]==1:\r\n                new_all_connect.append([i2, i])\r\n            else:\r\n                new_no_connect.append([i2, i])\r\n        for x in all_connect:\r\n            new_all_connect.append(x)\r\n            works = True\r\n            for y in x:\r\n                if M[i][y]==0:\r\n                    works = False\r\n                    break \r\n            if works:\r\n                if len(x+[i])==5:\r\n                    return x+[i]\r\n                new_all_connect.append(x+[i])\r\n        for x in no_connect:\r\n            new_no_connect.append(x)\r\n            works = True\r\n            for y in x:\r\n                if M[i][y]==1:\r\n                    works = False\r\n                    break \r\n            if works:\r\n                if len(x+[i])==5:\r\n                    return x+[i]\r\n                new_no_connect.append(x+[i])\r\n        all_connect = new_all_connect\r\n        no_connect = new_no_connect\r\n    return [-1]\r\n\r\nn, m = [int(x) for x in input().split()]\r\nG = []\r\nfor i in range(m):\r\n    u, v = [int(x) for x in input().split()]\r\n    G.append([u, v])\r\nanswer = process(n, G)\r\nsys.stdout.write(' '.join(map(str, answer))+'\\n')","tags":["math","probabilities"],"src_uid":"d42405469c82e35361d708a689b54f47"}
{"text_full":"[DESCRIPTION]The derby between Milan and Inter is happening soon, and you have been chosen as the assistant referee for the match, also known as linesman. Your task is to move along the touch-line, namely the side of the field, always looking very carefully at the match to check for offside positions and other offences.Football is an extremely serious matter in Italy, and thus it is fundamental that you keep very close track of the ball for as much time as possible. This means that you want to maximise the number of kicks which you monitor closely. You are able to monitor closely a kick if, when it happens, you are in the position along the touch-line with minimum distance from the place where the kick happens.Fortunately, expert analysts have been able to accurately predict all the kicks which will occur during the game. That is, you have been given two lists of integers, $$$t_1, \\ldots, t_n$$$ and $$$a_1, \\ldots, a_n$$$, indicating that $$$t_i$$$ seconds after the beginning of the match the ball will be kicked and you can monitor closely such kick if you are at the position $$$a_i$$$ along the touch-line. At the beginning of the game you start at position $$$0$$$ and the maximum speed at which you can walk along the touch-line is $$$v$$$ units per second (i.e., you can change your position by at most $$$v$$$ each second). What is the maximum number of kicks that you can monitor closely?[SOURCE CODE]from bisect import bisect_right,bisect_left\r\nn,v = map(int,input().split())\r\nt = [*map(int,input().split())]\r\na = [*map(int,input().split())]\r\nres = []\r\nfor i in range(n):\r\n    xi,yi = t[i]*v+a[i],t[i]*v-a[i]\r\n    if(xi>=0 and yi>=0):\r\n        res.append((xi,yi))\r\nres.sort()\r\ndp = [float(\"inf\")]*(n+3)\r\ndp[0] = 0\r\ndp[n+2] = 0\r\nfor i in range(len(res)):\r\n    pos = bisect_right(dp,res[i][1],0,n+2)\r\n    dp[pos] = res[i][1]\r\nfor i in range(n,-1,-1):\r\n    if(dp[i]!=float(\"inf\")):\r\n        print(i)\r\n        break","tags":["math"],"src_uid":"2bb43eb088051e08a678f7a97ef1eeff"}
{"text_full":"[DESCRIPTION]A wild basilisk just appeared at your doorstep. You are not entirely sure what a basilisk is and you wonder whether it evolved from your favorite animal, the weasel. How can you find out whether basilisks evolved from weasels? Certainly, a good first step is to sequence both of their DNAs. Then you can try to check whether there is a sequence of possible mutations from the DNA of the weasel to the DNA of the basilisk. Your friend Ron is a talented alchemist and has studied DNA sequences in many of his experiments. He has found out that DNA strings consist of the letters A, B and C and that single mutations can only remove or add substrings at any position in the string (a substring is a contiguous sequence of characters). The substrings that can be removed or added by a mutation are AA, BB, CC, ABAB or BCBC. During a sequence of mutations a DNA string may even become empty.Ron has agreed to sequence the DNA of the weasel and the basilisk for you, but finding out whether there is a sequence of possible mutations that leads from one to the other is too difficult for him, so you have to do it on your own.[SOURCE CODE]strings = ['AA', 'BB', 'CC', 'ABAB', 'BCBC']\r\nreduction = [['AA', ''], ['BB', ''], ['CC', ''], ['ABAB', ''], ['BCBC', ''],\r\n             ['CB', 'BC'], ['AB', 'BA']]  # move all Bs left\r\n\r\n# def simulator():\r\n#     s = 'CA'\r\n#     # get all possible outcomes from s\r\n#     l = len(s)\r\n#     vi = set()\r\n#     vi.add(s)\r\n#     st = [s]\r\n#     while st:\r\n#         s = st.pop()\r\n#         n = len(s)\r\n#         for s2 in strings:\r\n#             for i in range(n + 1):\r\n#                 # remove\r\n#                 if s[i: i + len(s2)] == s2:\r\n#                     s3 = s[:i] + s[i + len(s2):]\r\n#                     if s3 not in vi:\r\n#                         st.append(s3)\r\n#                         vi.add(s3)\r\n#                 # add\r\n#                 s3 = s[: i] + s2 + s[i:]\r\n#                 # if s3 == 'ABAB':\r\n#                 #     print('s2:{}'.format(s2))\r\n#                 if len(s3) <= l + 8 and s3 not in vi:\r\n#                     st.append(s3)\r\n#                     vi.add(s3)\r\n#     for s in vi:\r\n#         if len(s) <= l + 2:\r\n#             print(s)\r\n# simulator()\r\n\r\ndef reduce_string(s):\r\n    changed = 1\r\n    while changed == 1:\r\n        changed = 0\r\n        for complex_form, reduced_form in reduction:\r\n            if complex_form in s:\r\n                s = s.replace(complex_form, reduced_form)\r\n                changed = 1\r\n    return s\r\n\r\ndef main():\r\n    \r\n    T = int(input())\r\n    allans = []\r\n    for _ in range(T):\r\n        s = input()\r\n        t = input()\r\n        \r\n        s2 = reduce_string(s)\r\n        t2 = reduce_string(t)\r\n        # print('s:{} t:{} s2:{} t2:{}'.format(s, t, s2, t2))\r\n        if s2 == t2:\r\n            ans = 'YES'\r\n        else:\r\n            ans = 'NO'\r\n        allans.append(ans)\r\n    multiLineArrayPrint(allans)\r\n        \r\n    \r\n    return\r\n\r\nimport sys\r\n# input=sys.stdin.buffer.readline #FOR READING PURE INTEGER INPUTS (space separation ok)\r\ninput=lambda: sys.stdin.readline().rstrip(\"\\r\\n\") #FOR READING STRING\/TEXT INPUTS.\r\n \r\ndef oneLineArrayPrint(arr):\r\n    print(' '.join([str(x) for x in arr]))\r\ndef multiLineArrayPrint(arr):\r\n    print('\\n'.join([str(x) for x in arr]))\r\ndef multiLineArrayOfArraysPrint(arr):\r\n    print('\\n'.join([' '.join([str(x) for x in y]) for y in arr]))\r\n \r\ndef readIntArr():\r\n    return [int(x) for x in input().split()]\r\n# def readFloatArr():\r\n#     return [float(x) for x in input().split()]\r\n \r\ndef makeArr(defaultValFactory,dimensionArr): # eg. makeArr(lambda:0,[n,m])\r\n    dv=defaultValFactory;da=dimensionArr\r\n    if len(da)==1:return [dv() for _ in range(da[0])]\r\n    else:return [makeArr(dv,da[1:]) for _ in range(da[0])]\r\n \r\ndef queryInteractive(a, b, c):\r\n    print('? {} {} {}'.format(a, b, c))\r\n    sys.stdout.flush()\r\n    return int(input())\r\n \r\ndef answerInteractive(x1, x2):\r\n    print('! {} {}'.format(x1, x2))\r\n    sys.stdout.flush()\r\n \r\ninf=float('inf')\r\n# MOD=10**9+7\r\n# MOD=998244353\r\n \r\nfrom math import gcd,floor,ceil\r\nimport math\r\n# from math import floor,ceil # for Python2\r\n \r\nfor _abc in range(1):\r\n    main()","tags":["strings"],"src_uid":"b3c08abbaeec9ecbcc71fe34336d039a"}
{"text_full":"[DESCRIPTION]There are $$$n$$$ people, numbered from $$$1$$$ to $$$n$$$, sitting at a round table. Person $$$i+1$$$ is sitting to the right of person $$$i$$$ (with person $$$1$$$ sitting to the right of person $$$n$$$).You have come up with a better seating arrangement, which is given as a permutation $$$p_1, p_2, \\dots, p_n$$$. More specifically, you want to change the seats of the people so that at the end person $$$p_{i+1}$$$ is sitting to the right of person $$$p_i$$$ (with person $$$p_1$$$ sitting to the right of person $$$p_n$$$). Notice that for each seating arrangement there are $$$n$$$ permutations that describe it (which can be obtained by rotations).In order to achieve that, you can swap two people sitting at adjacent places; but there is a catch: for all $$$1 \\le x \\le n-1$$$ you cannot swap person $$$x$$$ and person $$$x+1$$$ (notice that you can swap person $$$n$$$ and person $$$1$$$). What is the minimum number of swaps necessary? It can be proven that any arrangement can be achieved.[SOURCE CODE]import sys\r\ninput = sys.stdin.readline\r\n\r\nclass SegmentTree:\r\n    def __init__(self, data, default=0, func=lambda x, y: x + y):\r\n        \"\"\"initialize the segment tree with data\"\"\"\r\n        self._default = default\r\n        self._func = func\r\n        self._len = len(data)\r\n        self._size = _size = 1 << (self._len - 1).bit_length()\r\n\r\n        self.data = [default] * (2 * _size)\r\n        self.data[_size:_size + self._len] = data\r\n        for i in reversed(range(_size)):\r\n            self.data[i] = func(self.data[i + i], self.data[i + i + 1])\r\n\r\n    def __delitem__(self, idx):\r\n        self[idx] = self._default\r\n\r\n    def __getitem__(self, idx):\r\n        return self.data[idx + self._size]\r\n\r\n    def __setitem__(self, idx, value):\r\n        idx += self._size\r\n        self.data[idx] = value\r\n        idx >>= 1\r\n        while idx:\r\n            self.data[idx] = self._func(self.data[2 * idx], self.data[2 * idx + 1])\r\n            idx >>= 1\r\n\r\n    def __len__(self):\r\n        return self._len\r\n\r\n    def query(self, start, stop):\r\n        \"\"\"func of data[start, stop)\"\"\"\r\n        start += self._size\r\n        stop += self._size\r\n\r\n        res_left = res_right = self._default\r\n        while start < stop:\r\n            if start & 1:\r\n                res_left = self._func(res_left, self.data[start])\r\n                start += 1\r\n            if stop & 1:\r\n                stop -= 1\r\n                res_right = self._func(self.data[stop], res_right)\r\n            start >>= 1\r\n            stop >>= 1\r\n\r\n        return self._func(res_left, res_right)\r\n\r\n    def __repr__(self):\r\n        return \"SegmentTree({0})\".format(self.data)\r\n\r\n    def clear(self, i):\r\n        if i >= self._size:\r\n            self.data[i] = 0\r\n\r\n        if self.data[i]:\r\n            self.data[i] = 0\r\n            self.clear(i + i)\r\n            self.clear(i + i + 1)\r\n\r\nSZ = 200005\r\n\r\nST = SegmentTree([0] * (2 * SZ))\r\n\r\nt = int(input())\r\nout = []\r\nfor _ in range(t):\r\n    n = int(input())\r\n    l = list(map(int, input().split()))\r\n    p = [0] * n\r\n    for i in range(n):\r\n        p[l[i] - 1] = i\r\n    res = 0\r\n\r\n    for i in range(n - 1):\r\n        l = p[i]\r\n        r = p[i + 1]\r\n        \r\n        if r < l:\r\n            r += SZ\r\n\r\n        seen = ST.query(l, r)\r\n        tot = (p[i + 1] - p[i] - 1) % n\r\n\r\n        res += (i + 1) * (tot - seen)\r\n        #print(tot, seen)\r\n            \r\n        ST[p[i]] = 1\r\n        ST[p[i] + SZ] = 1\r\n\r\n    out.append(res)\r\n    ST.clear(1)\r\n    #print(ST)\r\n        \r\n\r\nprint('\\n'.join(map(str, out)))","tags":["math"],"src_uid":"fa11eb753c2cae620c139030f5ca5850"}
{"text_full":"[DESCRIPTION]You are given a binary string (i. e. a string consisting of characters 0 and\/or 1) $$$s$$$ of length $$$n$$$. You can perform the following operation with the string $$$s$$$ at most once: choose a substring (a contiguous subsequence) of $$$s$$$ having exactly $$$k$$$ characters 1 in it, and shuffle it (reorder the characters in the substring as you wish).Calculate the number of different strings which can be obtained from $$$s$$$ by performing this operation at most once.[SOURCE CODE]import os,sys\r\nfrom io import BytesIO, IOBase\r\n\r\nfrom collections import defaultdict,deque,Counter\r\nfrom bisect import bisect_left,bisect_right\r\nfrom heapq import heappush,heappop\r\nfrom functools import lru_cache\r\nfrom itertools import accumulate\r\nimport math\r\nfrom tkinter import N\r\n\r\n# Fast IO Region\r\nBUFSIZE = 8192\r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\n\r\n# for _ in range(int(input())):\r\n#     n = int(input())\r\n#     a = list(map(int, input().split(' ')))\r\n\r\n# for _ in range(int(input())):\r\n#     a, b, c = list(map(int, input().split(' ')))\r\n#     if (a == b and c % 2 == 0) or (b == c and a % 2 == 0) or (a == c and b % 2 == 0):\r\n#         print('YES')\r\n#         continue\r\n#     s = [a, b, c]\r\n#     s.sort()\r\n#     if s[0] + s[1] == s[2]:\r\n#         print('YES')\r\n#         continue\r\n#     print('NO')\r\n\r\n# for _ in range(int(input())):\r\n#     n = int(input())\r\n#     a = list(map(int, input().split(' ')))\r\n#     s = input()\r\n#     cnt = s.count('0')\r\n#     ans = [0] * n\r\n#     hi = []\r\n#     lo = []\r\n#     for i in range(n):\r\n#         if s[i] == '1':\r\n#             if a[i] > cnt:\r\n#                 ans[i] = a[i]\r\n#             else:\r\n#                 hi.append(a[i])\r\n#                 ans[i] = -1\r\n#         else:\r\n#             if a[i] <= cnt:\r\n#                 ans[i] = a[i]\r\n#             else:\r\n#                 lo.append(a[i])\r\n#                 ans[i] = -2\r\n#     for i in range(n):\r\n#         if ans[i] == -1:\r\n#             ans[i] = lo.pop()\r\n#         elif ans[i] == -2:\r\n#             ans[i] = hi.pop()\r\n#     print(*ans)\r\n\r\n# for _ in range(int(input())):\r\n#     n, k = list(map(int, input().split(' ')))\r\n#     a = list(map(int, input().split(' ')))\r\n#     a.sort()\r\n#     pre = list(accumulate(a))\r\n#     ans = float('inf')\r\n#     for i in range(n):\r\n#         res = i\r\n#         tmp = pre[n - 1 - i] - pre[0]\r\n#         res += max(0, a[0] - (k - tmp) \/\/ (i + 1))\r\n#         ans = min(ans, res)\r\n#     print(ans)\r\n\r\nmod = 998244353\r\nN = 5010\r\nfac = [1] * N\r\nfor i in range(2, N):\r\n    fac[i] = fac[i - 1] * i % mod\r\ninvfac = [1] * N\r\ninvfac[N - 1] = pow(fac[N - 1], mod - 2, mod)\r\nfor i in range(N - 1)[::-1]:\r\n    invfac[i] = invfac[i + 1] * (i + 1) % mod\r\ndef c(i, j):\r\n    return fac[i] * invfac[j] * invfac[i - j] % mod\r\n\r\ndef solve():\r\n    n, k = list(map(int, input().split(' ')))\r\n    a = list(map(int, input()))\r\n    pre = list(accumulate(a))\r\n    tmp = []\r\n    for i in range(n):\r\n        if i == 0:\r\n            r = bisect_right(pre, k)\r\n            if r - 1 >= 0 and pre[r -   1] == k:\r\n                tmp.append((i, r - 1))\r\n        else:\r\n            if a[i - 1] == 0: continue\r\n            r = bisect_right(pre, k + pre[i - 1])\r\n            if r - 1 >= i and pre[r - 1] == k + pre[i - 1]:\r\n                tmp.append((i, r - 1))\r\n\r\n    if not tmp:\r\n        print(1)\r\n        return\r\n    ans = 1\r\n    m = len(tmp)\r\n    for i in range(m):\r\n        l, r = tmp[i]\r\n        if l == 0:\r\n            cnt1 = pre[r]\r\n        else:\r\n            cnt1 = pre[r] - pre[l - 1]\r\n        ans += c(r - l + 1, cnt1) - 1\r\n        ans %= mod\r\n        if i > 0:\r\n            j = i - 1\r\n            r = tmp[j][1]\r\n            if l <= r:\r\n                if l == 0:\r\n                    cnt1 = pre[r]\r\n                else:\r\n                    cnt1 = pre[r] - pre[l - 1]\r\n                ans -= c(r - l + 1, cnt1) - 1\r\n                ans %= mod\r\n    print(ans % mod)\r\n\r\n    \r\nsolve()","tags":["math"],"src_uid":"d666df06a7a7ecbe801c1018b3d482b9"}
{"text_full":"[DESCRIPTION]Let's call a set of positive integers $$$a_1, a_2, \\dots, a_k$$$ quadratic if the product of the factorials of its elements is a square of an integer, i. e. $$$\\prod\\limits_{i=1}^{k} a_i! = m^2$$$, for some integer $$$m$$$.You are given a positive integer $$$n$$$.Your task is to find a quadratic subset of a set $$$1, 2, \\dots, n$$$ of maximum size. If there are multiple answers, print any of them.[SOURCE CODE]def is_square(n):\r\n    return int(n ** 0.5) ** 2 == n\r\n\r\ndef solve(n):\r\n    if n <= 3:\r\n        return range(2, n+1)\r\n\r\n    k = n >> 1\r\n    if n % 4 == 0:\r\n        return [k]\r\n    if n % 4 == 1:\r\n        return [k, n]\r\n    if n % 4 == 2:\r\n        if is_square(n + 2):\r\n            return [k + 1]\r\n        if is_square(2 * k * (k - 1)):\r\n            return [k - 2]\r\n        return [2, k]\r\n    if n % 4 == 3:\r\n        if is_square(n + 1):\r\n            return [k + 1, n]\r\n        if is_square(2 * k * (k - 1)):\r\n            return [k - 2, n]\r\n        if is_square(n * (k - 1)):\r\n            return [k - 2, n - 2]\r\n        return [2, k, n]\r\n    \r\nN = int(input())\r\nans = solve(N)\r\noutput = [x for x in range(1, N+1) if x not in ans]\r\nprint(len(output))\r\nprint(\" \".join(map(str, output)))","tags":["math","number theory"],"src_uid":"81f7807397635c9ce01f9100e68cb420"}
{"text_full":"[DESCRIPTION]Parsa has a humongous tree on $$$n$$$ vertices.On each vertex $$$v$$$ he has written two integers $$$l_v$$$ and $$$r_v$$$.To make Parsa's tree look even more majestic, Nima wants to assign a number $$$a_v$$$ ($$$l_v \\le a_v \\le r_v$$$) to each vertex $$$v$$$ such that the beauty of Parsa's tree is maximized.Nima's sense of the beauty is rather bizarre. He defines the beauty of the tree as the sum of $$$|a_u - a_v|$$$ over all edges $$$(u, v)$$$ of the tree.Since Parsa's tree is too large, Nima can't maximize its beauty on his own. Your task is to find the maximum possible beauty for Parsa's tree.[SOURCE CODE]import sys\r\nsys.setrecursionlimit(10 ** 5)\r\ninput = sys.stdin.buffer.readline\r\ndef dfs(par, x):\r\n    for u in g[x]:\r\n        if u == par:\r\n            continue\r\n        dfs(x, u)\r\n    dp[par][0] += max(abs(a[par][0] - a[x][0]) + dp[x][0], abs(a[par][0] - a[x][1]) + dp[x][1])\r\n    dp[par][1] += max(abs(a[par][1] - a[x][0]) + dp[x][0], abs(a[par][1] - a[x][1]) + dp[x][1])\r\nfor _ in range(int(input())):\r\n    n = int(input())\r\n    g = [[] for _ in range(n)]\r\n    a = []\r\n    for _ in range(n):\r\n        a.append(list(map(int, input().split())))\r\n    for _ in range(n - 1):\r\n        u, v = map(int, input().split())\r\n        g[u - 1].append(v - 1)\r\n        g[v - 1].append(u - 1)\r\n    dp = [[0.0, 0.0] for _ in range(n)]\r\n\r\n\r\n\r\n    for p in g[0]:\r\n        dfs(0, p)\r\n    print(int(max(dp[0][0], dp[0][1])))","tags":["graphs","trees"],"src_uid":"a5063294f814f359f7ab6b7b801eaf3e"}
{"text_full":"[DESCRIPTION]A sequence $$$(b_1, b_2, \\ldots, b_k)$$$ is called strange, if the absolute difference between any pair of its elements is greater than or equal to the maximum element in the sequence. Formally speaking, it's strange if for every pair $$$(i, j)$$$ with $$$1 \\le i&lt;j \\le k$$$, we have $$$|a_i-a_j|\\geq MAX$$$, where $$$MAX$$$ is the largest element of the sequence. In particular, any sequence of length at most $$$1$$$ is strange.For example, the sequences $$$(-2021, -1, -1, -1)$$$ and $$$(-1, 0, 1)$$$ are strange, but $$$(3, 0, 1)$$$ is not, because $$$|0 - 1| &lt; 3$$$.Sifid has an array $$$a$$$ of $$$n$$$ integers. Sifid likes everything big, so among all the strange subsequences of $$$a$$$, he wants to find the length of the longest one. Can you help him?A sequence $$$c$$$ is a subsequence of an array $$$d$$$ if $$$c$$$ can be obtained from $$$d$$$ by deletion of several (possibly, zero or all) elements.[SOURCE CODE]tcs = int(input())\r\nfor _ in range(tcs):\r\n    n = int(input())\r\n    a = list(map(int, input().split()))\r\n    \r\n    a.sort()\r\n    \r\n    if a[n-1] <= 0:\r\n        print(n)        \r\n    else:  \r\n        flag = 0\r\n        pi = 0\r\n        while(a[pi] <= 0):\r\n            pi += 1\r\n        \r\n        for i in range(pi):\r\n            x = a[i] - a[i+1]\r\n            if abs(x) < a[pi]:\r\n                flag = 1\r\n                \r\n        print(pi+1 if flag == 0 else pi)","tags":["math"],"src_uid":"a4b170cc058c485a50bf18982fd96851"}
{"text_full":"[DESCRIPTION]A sequence of $$$n$$$ numbers is called permutation if it contains all numbers from $$$1$$$ to $$$n$$$ exactly once. For example, the sequences [$$$3, 1, 4, 2$$$], [$$$1$$$] and [$$$2,1$$$] are permutations, but [$$$1,2,1$$$], [$$$0,1$$$] and [$$$1,3,4$$$] — are not.For a permutation $$$p$$$ of even length $$$n$$$ you can make an array $$$b$$$ of length $$$\\frac{n}{2}$$$ such that:   $$$b_i = \\max(p_{2i - 1}, p_{2i})$$$ for $$$1 \\le i \\le \\frac{n}{2}$$$ For example, if $$$p$$$ = [$$$2, 4, 3, 1, 5, 6$$$], then:   $$$b_1 = \\max(p_1, p_2) = \\max(2, 4) = 4$$$  $$$b_2 = \\max(p_3, p_4) = \\max(3,1)=3$$$  $$$b_3 = \\max(p_5, p_6) = \\max(5,6) = 6$$$  As a result, we made $$$b$$$ = $$$[4, 3, 6]$$$.For a given array $$$b$$$, find the lexicographically minimal permutation $$$p$$$ such that you can make the given array $$$b$$$ from it.If $$$b$$$ = [$$$4,3,6$$$], then the lexicographically minimal permutation from which it can be made is $$$p$$$ = [$$$1,4,2,3,5,6$$$], since:   $$$b_1 = \\max(p_1, p_2) = \\max(1, 4) = 4$$$  $$$b_2 = \\max(p_3, p_4) = \\max(2, 3) = 3$$$  $$$b_3 = \\max(p_5, p_6) = \\max(5, 6) = 6$$$ A permutation $$$x_1, x_2, \\dots, x_n$$$ is lexicographically smaller than a permutation $$$y_1, y_2 \\dots, y_n$$$ if and only if there exists such $$$i$$$ ($$$1 \\le i \\le n$$$) that $$$x_1=y_1, x_2=y_2, \\dots, x_{i-1}=y_{i-1}$$$ and $$$x_i&lt;y_i$$$.[SOURCE CODE]import collections\r\nimport math\r\nimport bisect\r\nimport sys\r\nimport heapq\r\nimport itertools\r\n#import functools\r\n\r\ndef solve():\r\n    n = int(input())\r\n    arr = [int(i) for i in sys.stdin.readline().split()]\r\n    dic = {}\r\n    for i, num in enumerate(arr):\r\n        dic[num] = i\r\n    if len(dic) != n \/\/ 2 or n not in dic:\r\n        print(-1)\r\n        return\r\n\r\n    output = [-1] * n\r\n    for num in dic:\r\n        output[dic[num] * 2 + 1] = num\r\n    \r\n    h = []\r\n    for num in range(n, 0, -1):\r\n        if num in dic:\r\n            heapq.heappush(h, -dic[num] * 2)\r\n        elif not h:\r\n            print(-1)\r\n            return\r\n        else:\r\n            output[-heapq.heappop(h)] = num\r\n    print(' '.join(map(str, output)))\r\n\r\n    \r\n    \r\n\r\nt = int(input())\r\nfor _ in range(t):\r\n    solve()","tags":["math"],"src_uid":"c2db558ecf921161ab4da003bd393ec7"}
{"text_full":"[DESCRIPTION]You are given a positive integer $$$x$$$. Find any such $$$2$$$ positive integers $$$a$$$ and $$$b$$$ such that $$$GCD(a,b)+LCM(a,b)=x$$$.As a reminder, $$$GCD(a,b)$$$ is the greatest integer that divides both $$$a$$$ and $$$b$$$. Similarly, $$$LCM(a,b)$$$ is the smallest integer such that both $$$a$$$ and $$$b$$$ divide it.It's guaranteed that the solution always exists. If there are several such pairs $$$(a, b)$$$, you can output any of them.[SOURCE CODE]T = input()\n\nfor _ in xrange(T):\n    x = input()\n\n    if x % 2 == 0:\n        print \"%d %d\" % (x\/\/2, x\/\/2)\n\n    else:\n        print \"1 %d\" % (x-1)","tags":["number theory"],"src_uid":"2fa3e88688b92c27ad26a23884e26009"}
{"text_full":"[DESCRIPTION]There are n cities in Westeros. The i-th city is inhabited by ai people. Daenerys and Stannis play the following game: in one single move, a player chooses a certain town and burns it to the ground. Thus all its residents, sadly, die. Stannis starts the game. The game ends when Westeros has exactly k cities left.The prophecy says that if the total number of surviving residents is even, then Daenerys wins: Stannis gets beheaded, and Daenerys rises on the Iron Throne. If the total number of surviving residents is odd, Stannis wins and everything goes in the completely opposite way.Lord Petyr Baelish wants to know which candidates to the throne he should support, and therefore he wonders, which one of them has a winning strategy. Answer to this question of Lord Baelish and maybe you will become the next Lord of Harrenholl.[SOURCE CODE]import math,string,itertools,fractions,heapq,collections,re,array,bisect\nfrom itertools import chain, dropwhile, permutations, combinations\nfrom collections import defaultdict, deque\n\ndef VI(): return list(map(int,input().split()))\n\ndef main(n,k,a):\n    now = sum(a)\n    even = sum([x%2==0 for x in a])\n    odd = sum([x%2==1 for x in a])\n    d = n-k\n    D = \"Daenerys\"\n    S = \"Stannis\"\n    if n==k:\n        ans = [S,D][now%2==0]\n    elif d%2==0: # Daenerys last\n        if k%2==0: ans = D\n        elif even <= d\/\/2: ans = S\n        else: ans = D\n    else: # Stannis last\n        if k%2==0:\n            if odd <= d\/\/2 or even <= d\/\/2: ans = D\n            else: ans = S\n        else:\n            if odd <= d\/\/2: ans = D\n            else: ans = S\n    print(ans)\n\n\ndef main_input(info=0):\n    n,k = VI()\n    a = VI()\n    main(n,k,a)\n\nif __name__ == \"__main__\":\n    main_input()","tags":["games"],"src_uid":"67e51db4d96b9f7996aea73cbdba3584"}
{"text_full":"[DESCRIPTION]There is a chessboard of size $$$n$$$ by $$$n$$$. The square in the $$$i$$$-th row from top and $$$j$$$-th column from the left is labelled $$$(i,j)$$$.Currently, Gregor has some pawns in the $$$n$$$-th row. There are also enemy pawns in the $$$1$$$-st row. On one turn, Gregor moves one of his pawns. A pawn can move one square up (from $$$(i,j)$$$ to $$$(i-1,j)$$$) if there is no pawn in the destination square. Additionally, a pawn can move one square diagonally up (from $$$(i,j)$$$ to either $$$(i-1,j-1)$$$ or $$$(i-1,j+1)$$$) if and only if there is an enemy pawn in that square. The enemy pawn is also removed.Gregor wants to know what is the maximum number of his pawns that can reach row $$$1$$$?Note that only Gregor takes turns in this game, and the enemy pawns never move. Also, when Gregor's pawn reaches row $$$1$$$, it is stuck and cannot make any further moves.[SOURCE CODE]def solve():\r\n    n = int(input())\r\n    e = list(input())\r\n    g = list(input())\r\n    e.insert(0,\"0\")\r\n    e.insert(n+1,\"0\")\r\n   # print(e)\r\n \r\n    \r\n    \r\n   \r\n    c = 0\r\n    for i in range(0,n):\r\n        if g[i] == \"1\":\r\n            if e[i+1] == \"0\":\r\n                c+=1\r\n            elif e[i] ==\"1\":\r\n                c+=1\r\n                e[i] = \"2\"\r\n            elif e[i+2] ==\"1\":\r\n                c+=1\r\n                e[i+2] = \"2\"\r\n    print(c)\r\n                \r\n           \r\ncase = int(input())\r\nfor _ in range(case):\r\n   solve()","tags":["graphs"],"src_uid":"c05426881a7dccc1aa79608b612290a7"}
{"text_full":"[DESCRIPTION]Turbulent times are coming, so you decided to buy sugar in advance. There are $$$n$$$ shops around that sell sugar: the $$$i$$$-th shop sells one pack of sugar for $$$a_i$$$ coins, but only one pack to one customer each day. So in order to buy several packs, you need to visit several shops.Another problem is that prices are increasing each day: during the first day the cost is $$$a_i$$$, during the second day cost is $$$a_i + 1$$$, during the third day — $$$a_i + 2$$$ and so on for each shop $$$i$$$.On the contrary, your everyday budget is only $$$x$$$ coins. In other words, each day you go and buy as many packs as possible with total cost not exceeding $$$x$$$. Note that if you don't spend some amount of coins during a day, you can't use these coins during the next days.Eventually, the cost for each pack will exceed $$$x$$$, and you won't be able to buy even a single pack. So, how many packs will you be able to buy till that moment in total?[SOURCE CODE]import math\r\n \r\nfor i in range(int(input())):\r\n    n, x = list(map(int, input().split()))\r\n    l = sorted(list(map(int, input().split())))\r\n    ans = 0\r\n    if x >= l[0]:\r\n        s = 0\r\n        for i, a in enumerate(l):\r\n            s += a\r\n            u = math.floor((x - s) \/ (i + 1.0)) + 1\r\n            if u > 0:\r\n                ans += u\r\n            else:\r\n                break\r\n    \r\n    print(ans)","tags":["math"],"src_uid":"b65767c1ebfe72e08f58a9f9254eaa7b"}
{"text_full":"[DESCRIPTION]A bitstring is a string that contains only the characters 0 and 1.Koyomi Kanou is working hard towards her dream of becoming a writer. To practice, she decided to participate in the Binary Novel Writing Contest. The writing prompt for the contest consists of three bitstrings of length $$$2n$$$. A valid novel for the contest is a bitstring of length at most $$$3n$$$ that contains at least two of the three given strings as subsequences.Koyomi has just received the three prompt strings from the contest organizers. Help her write a valid novel for the contest.A string $$$a$$$ is a subsequence of a string $$$b$$$ if $$$a$$$ can be obtained from $$$b$$$ by deletion of several (possibly, zero) characters.[SOURCE CODE]import sys\r\ninput = lambda : sys.stdin.readline().rstrip()\r\n\r\nwrite = lambda x: sys.stdout.write(x+\"\\n\"); writef = lambda x: print(\"{:.12f}\".format(x))\r\ndebug = lambda x: sys.stderr.write(x+\"\\n\")\r\nYES=\"Yes\"; NO=\"No\"; pans = lambda v: print(YES if v else NO)\r\nLI = lambda : list(map(int, input().split()))\r\n# sys.setrecursionlimit(3*10**5+10)\r\n\r\nt = int(input())\r\nfor _ in range(t):\r\n    n = int(input())\r\n    s = [list(map(int, input())) for _ in range(3)]\r\n    index = [0,0,0]\r\n    l = []\r\n    for i in range(3*n):\r\n        if max(index)==2*n:\r\n            inds = list(range(3))\r\n            inds.sort(key=lambda i: index[i])\r\n            j = inds[1]\r\n            for k in range(index[j], 2*n):\r\n                l.append(s[j][k])\r\n            break\r\n        if s[0][index[0]] + s[1][index[1]] + s[2][index[2]] >= 2:\r\n            v = 1\r\n        else:\r\n            v = 0\r\n        l.append(v)\r\n        for j in range(3):\r\n            if s[j][index[j]]==v:\r\n                index[j] += 1\r\n    assert len(l)<=3*n\r\n    write(\"\".join(map(str, l)))\r\n#     break","tags":["strings"],"src_uid":"fd3fad7de3068889e676e68551c00a0f"}
{"text_full":"[DESCRIPTION]You are given an array $$$a$$$ consisting of $$$n$$$ positive integers. You have to choose a positive integer $$$d$$$ and paint all elements into two colors. All elements which are divisible by $$$d$$$ will be painted red, and all other elements will be painted blue.The coloring is called beautiful if there are no pairs of adjacent elements with the same color in the array. Your task is to find any value of $$$d$$$ which yields a beautiful coloring, or report that it is impossible.[SOURCE CODE]def  GCD(divisor,num):\r\n    if num == 0:\r\n        return divisor\r\n    else:\r\n        return GCD(num , divisor % num)\r\n\r\ndef solve(array):\r\n    even_divisor = 0\r\n    odd_divisor = 0\r\n    for index in range (0 , len(array)):\r\n        if index % 2 == 0 :\r\n            even_divisor = GCD(even_divisor , array[index])\r\n        else :\r\n            odd_divisor = GCD(odd_divisor , array[index])\r\n\r\n    ok = True\r\n    index = 0\r\n    while index < len(array) :\r\n        if array [index] % odd_divisor == 0 :\r\n            ok = False\r\n            break;\r\n        index += 2\r\n    if ok :\r\n        return odd_divisor\r\n\r\n    ok = True\r\n    index = 1\r\n    while index < len(array):\r\n        if array[index] % even_divisor == 0:\r\n            ok = False\r\n            break;\r\n        index += 2\r\n\r\n    if ok:\r\n        return even_divisor\r\n    return 0\r\n\r\nn=int(input())\r\narray=[]\r\nfor i in range(n) :\r\n    s = int(input())\r\n    x = list(map(int, input().split()))\r\n    array.append(x)\r\n\r\nfor i in array:\r\n    print(solve(i))","tags":["math"],"src_uid":"e6c91f6872c4dd845cb7a156aacab7c7"}
{"text_full":"[DESCRIPTION]You are given an array $$$a_1, a_2, \\ldots, a_n$$$ consisting of $$$n$$$ positive integers and a positive integer $$$m$$$.You should divide elements of this array into some arrays. You can order the elements in the new arrays as you want.Let's call an array $$$m$$$-divisible if for each two adjacent numbers in the array (two numbers on the positions $$$i$$$ and $$$i+1$$$ are called adjacent for each $$$i$$$) their sum is divisible by $$$m$$$. An array of one element is $$$m$$$-divisible.Find the smallest number of $$$m$$$-divisible arrays that $$$a_1, a_2, \\ldots, a_n$$$ is possible to divide into.[SOURCE CODE]t = int(input())\r\nfor p in range(t):\r\n    l = list(map(int, input().rstrip().split()))\r\n    n = l[0]\r\n    m = l[1]\r\n    res = []\r\n    l1 = list(map(int, input().rstrip().split()))\r\n    mydict = {}\r\n    count = 0\r\n    for a in range(m):\r\n        mydict[a] = 0\r\n    for i in l1:\r\n        mydict[i % m] += 1\r\n\r\n    for j in range(m):\r\n\r\n        if mydict[j] == 0:\r\n            continue\r\n        if j == 0:\r\n            count += 1\r\n        elif mydict[m - j] != 0:\r\n            if mydict[m - j] == mydict[j]:\r\n                count += 1\r\n            elif abs(mydict[j] - mydict[m - j]) >= 1:\r\n                count += abs(mydict[j] - mydict[m - j])\r\n            else:\r\n                count += 1\r\n            mydict[j] = 0\r\n            mydict[m - j] = 0\r\n        else:\r\n            count += mydict[j]\r\n            mydict[j] = 0\r\n    print(count)","tags":["math"],"src_uid":"d107db1395ded62904d0adff164e5c1e"}
{"text_full":"[DESCRIPTION]This is the easy version of the problem. The only difference is that in this version $$$k = 0$$$.There is an array $$$a_1, a_2, \\ldots, a_n$$$ of $$$n$$$ positive integers. You should divide it into a minimal number of continuous segments, such that in each segment there are no two numbers (on different positions), whose product is a perfect square.Moreover, it is allowed to do at most $$$k$$$ such operations before the division: choose a number in the array and change its value to any positive integer. But in this version $$$k = 0$$$, so it is not important.What is the minimum number of continuous segments you should use if you will make changes optimally?[SOURCE CODE]import os\r\nimport sys\r\nfrom collections import defaultdict,deque\r\nfrom io import BytesIO, IOBase\r\n# MOD = 998244353\r\n# nmax = (2*(10**5))+2\r\n \r\n# fact = [1] * (nmax+1)\r\n# for i in range(2, nmax+1):\r\n#     fact[i] = fact[i-1] * i % MOD\r\n    \r\n# inv = [1] * (nmax+1)\r\n# for i in range(2, nmax+1):\r\n#     inv[i] = pow(fact[i], MOD-2, MOD)\r\n \r\n \r\n# def C(n, m):\r\n#     return fact[n] * inv[m] % MOD * inv[n-m] % MOD if 0 <= m <= n else 0\r\nfactor_dict = {1: 1}\r\nprimes = []\r\n \r\nfor p in range(2, 10**7):\r\n    if p*p > 10**7:\r\n        break\r\n    prime = True\r\n    for i in range(2, p):\r\n        if i*i > p:\r\n            break\r\n        if p % i==0:\r\n            prime = False\r\n            break\r\n    if prime:\r\n        primes.append(p)\r\n \r\ndef factor(n):\r\n    if n in factor_dict:\r\n        return factor_dict[n]\r\n    n2 = n\r\n    for p in primes:\r\n        if p*p > n:\r\n            break\r\n        while n % (p*p)==0:\r\n            n = n\/\/(p*p)\r\n    factor_dict[n2] = n\r\n    return n\r\n \r\nfor i in range(2, 10**4):\r\n    factor(i)\r\n    \r\nfrom collections import Counter\r\nfrom functools import lru_cache\r\nfrom collections import deque\r\ndef main():\r\n    # import bisect,math\r\n \r\n    # class SortedList():\r\n    #     BUCKET_RATIO = 50\r\n    #     REBUILD_RATIO = 170\r\n    \r\n    #     def __init__(self,buckets):\r\n    #         buckets = list(buckets)\r\n    #         buckets = sorted(buckets)\r\n    #         self._build(buckets)\r\n    \r\n    #     def __iter__(self):\r\n    #         for i in self.buckets:\r\n    #             for j in i: yield j\r\n    \r\n    #     def __reversed__(self):\r\n    #         for i in reversed(self.buckets):\r\n    #             for j in reversed(i): yield j\r\n    \r\n    #     def __len__(self):\r\n    #         return self.size\r\n    \r\n    #     def __contains__(self,x):\r\n    #         if self.size == 0: return False\r\n    #         bucket = self._find_bucket(x)\r\n    #         i = bisect.bisect_left(bucket,x)\r\n    #         return i != len(bucket) and bucket[i] == x\r\n    \r\n    #     def __getitem__(self,x):\r\n    #         if x < 0: x += self.size\r\n    #         if x < 0: raise IndexError\r\n    #         for i in self.buckets:\r\n    #             if x < len(i): return i[x]\r\n    #             x -= len(i)\r\n    #         raise IndexError\r\n    \r\n    #     def _build(self,buckets=None):\r\n    #         if buckets is None: buckets = list(self)\r\n    #         self.size = len(buckets)\r\n    #         bucket_size = int(math.ceil(math.sqrt(self.size\/self.BUCKET_RATIO)))\r\n    #         tmp = []\r\n    #         for i in range(bucket_size):\r\n    #             t = buckets[(self.size*i)\/\/bucket_size:(self.size*(i+1))\/\/bucket_size]\r\n    #             tmp.append(t)\r\n    #         self.buckets = tmp\r\n    \r\n    #     def _find_bucket(self,x):\r\n    #         for i in self.buckets:\r\n    #             if x <= i[-1]:\r\n    #                 return i\r\n    #         return i\r\n    \r\n    #     def add(self,x):\r\n    #         # O(√N)\r\n    #         if self.size == 0:\r\n    #             self.buckets = [[x]]\r\n    #             self.size = 1\r\n    #             return True\r\n    \r\n    #         bucket = self._find_bucket(x)\r\n    #         bisect.insort(bucket,x)\r\n    #         self.size += 1\r\n    #         if len(bucket) > len(self.buckets) * self.REBUILD_RATIO:\r\n    #             self._build()\r\n    #         return True\r\n    \r\n    #     def remove(self,x):\r\n    #         # O(√N)\r\n    #         if self.size == 0: return False\r\n    #         bucket = self._find_bucket(x)\r\n    #         i = bisect.bisect_left(bucket,x)\r\n    #         if i == len(bucket) or bucket[i] != x: return False\r\n    #         bucket.pop(i)\r\n    #         self.size -= 1\r\n    #         if len(bucket) == 0: self._build()\r\n    #         return True\r\n    \r\n    #     def lt(self,x):\r\n    #         # less than < x\r\n    #         for i in reversed(self.buckets):\r\n    #             if i[0] < x:\r\n    #                 return i[bisect.bisect_left(i,x) - 1]\r\n    \r\n    #     def le(self,x):\r\n    #         # less than or equal to <= x\r\n    #         for i in reversed(self.buckets):\r\n    #             if i[0] <= x:\r\n    #                 return i[bisect.bisect_right(i,x) - 1]\r\n    \r\n    #     def gt(self,x):\r\n    #         # greater than > x\r\n    #         for i in self.buckets:\r\n    #             if i[-1] > x:\r\n    #                 return i[bisect.bisect_right(i,x)]\r\n    \r\n    #     def ge(self,x):\r\n    #         # greater than or equal to >= x\r\n    #         for i in self.buckets:\r\n    #             if i[-1] >= x:\r\n    #                 return i[bisect.bisect_left(i,x)]\r\n    #     def index(self,x):\r\n    #         # the number of elements < x\r\n    #         ans = 0\r\n    #         for i in self.buckets:\r\n    #             if i[-1] >= x:\r\n    #                 return ans + bisect.bisect_left(i,x)\r\n    #             ans += len(i)\r\n    #         return ans\r\n    \r\n    #     def index_right(self,x):\r\n    #         # the number of elements < x\r\n    #         ans = 0\r\n    #         for i in self.buckets:\r\n    #             if i[-1] > x:\r\n    #                 return ans + bisect.bisect_right(i,x)\r\n    #             ans += len(i)\r\n    #         return ans\r\n    from math import sqrt\r\n    for _ in range(int(input())):\r\n        n,k=map(int,input().split())\r\n        arr=list(map(int,input().split()))\r\n        seen=set([])\r\n        ans=0\r\n        for el in arr:\r\n            if factor(el) in seen:\r\n                ans+=1\r\n                seen=set([])\r\n                seen.add(factor(el))\r\n            else :\r\n                seen.add(factor(el))\r\n        if seen!=set([]):\r\n            ans+=1\r\n        print(ans)\r\n                            \r\n \r\n#----------------------------------------------------------------------------------------\r\n \r\n \r\n# region fastio\r\n \r\nBUFSIZE = 8192\r\n \r\n \r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n \r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = 'x' in file.mode or 'r' not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n \r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n \r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b'\\n') + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n \r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\n \r\n \r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode('ascii'))\r\n        self.read = lambda: self.buffer.read().decode('ascii')\r\n        self.readline = lambda: self.buffer.readline().decode('ascii')\r\n \r\n \r\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\ninput = lambda: sys.stdin.readline().rstrip('\\r\\n')\r\n \r\n \r\n# endregion\r\n \r\nif __name__ == '__main__':\r\n    main()","tags":["math","number theory"],"src_uid":"878c2e57a396187ccef51d0f941386cf"}
{"text_full":"[DESCRIPTION]Monocarp has just learned a new card trick, and can't wait to present it to you. He shows you the entire deck of $$$n$$$ cards. You see that the values of cards from the topmost to the bottommost are integers $$$a_1, a_2, \\dots, a_n$$$, and all values are different.Then he asks you to shuffle the deck $$$m$$$ times. With the $$$j$$$-th shuffle, you should take $$$b_j$$$ topmost cards and move them under the remaining $$$(n - b_j)$$$ cards without changing the order.And then, using some magic, Monocarp tells you the topmost card of the deck. However, you are not really buying that magic. You tell him that you know the topmost card yourself. Can you surprise Monocarp and tell him the topmost card before he shows it?[SOURCE CODE]case = int(input())\r\ndef solve():\r\n    n = int(input())\r\n    card = list(map(int,input().split()))\r\n    m = int(input())\r\n    v = list(map(int,input().split()))\r\n    counter = 0\r\n    for i in v:\r\n        counter+=i\r\n    counter = counter%n\r\n    print(card[counter])\r\n    \r\n        \r\nfor _ in range(case):\r\n    solve()","tags":["math"],"src_uid":"c9da10199ad1a5358195b693325e628b"}
{"text_full":"[DESCRIPTION]Long time ago there was a symmetric array $$$a_1,a_2,\\ldots,a_{2n}$$$ consisting of $$$2n$$$ distinct integers. Array $$$a_1,a_2,\\ldots,a_{2n}$$$ is called symmetric if for each integer $$$1 \\le i \\le 2n$$$, there exists an integer $$$1 \\le j \\le 2n$$$ such that $$$a_i = -a_j$$$.For each integer $$$1 \\le i \\le 2n$$$, Nezzar wrote down an integer $$$d_i$$$ equal to the sum of absolute differences from $$$a_i$$$ to all integers in $$$a$$$, i. e. $$$d_i = \\sum_{j = 1}^{2n} {|a_i - a_j|}$$$.Now a million years has passed and Nezzar can barely remember the array $$$d$$$ and totally forget $$$a$$$. Nezzar wonders if there exists any symmetric array $$$a$$$ consisting of $$$2n$$$ distinct integers that generates the array $$$d$$$.[SOURCE CODE]for w in range(int(input())) :\r\n n=int(input())\r\n s=list(map(int,input().split()))\r\n arr=sorted(list(map(int,set(s))),reverse=True)\r\n i=t=0\r\n test='YES'\r\n count=dict()\r\n if len(arr)!=n :\r\n     test='NO'\r\n for p in s:\r\n    count[p]=count.get(p,0)+1\r\n for p in count:\r\n    if(count[p]!=2):\r\n        test='NO'\r\n while test=='YES' and i<n  :\r\n     arr[i]-=t*2\r\n     if arr[i]%((n-i)*2)==0  :\r\n      x=arr[i]\/\/((n-i)*2)\r\n      if x<=0 :\r\n          test='NO'\r\n          break\r\n      t+=x\r\n     else :\r\n          test='NO'\r\n          break\r\n     i=i+1\r\n print(test)","tags":["math"],"src_uid":"36f45f5cf4f75f81152fff4505b3b937"}
{"text_full":"[DESCRIPTION]Nezzar loves the game osu!.osu! is played on beatmaps, which can be seen as an array consisting of distinct points on a plane. A beatmap is called nice if for any three consecutive points $$$A,B,C$$$ listed in order, the angle between these three points, centered at $$$B$$$, is strictly less than $$$90$$$ degrees.  Points $$$A,B,C$$$ on the left have angle less than $$$90$$$ degrees, so they can be three consecutive points of a nice beatmap; Points $$$A',B',C'$$$ on the right have angle greater or equal to $$$90$$$ degrees, so they cannot be three consecutive points of a nice beatmap. Now Nezzar has a beatmap of $$$n$$$ distinct points $$$A_1,A_2,\\ldots,A_n$$$. Nezzar would like to reorder these $$$n$$$ points so that the resulting beatmap is nice.Formally, you are required to find a permutation $$$p_1,p_2,\\ldots,p_n$$$ of integers from $$$1$$$ to $$$n$$$, such that beatmap $$$A_{p_1},A_{p_2},\\ldots,A_{p_n}$$$ is nice. If it is impossible, you should determine it.[SOURCE CODE]import sys\r\n\r\nsys.setrecursionlimit(10**5)\r\nint1 = lambda x: int(x)-1\r\np2D = lambda x: print(*x, sep=\"\\n\")\r\ndef II(): return int(sys.stdin.buffer.readline())\r\ndef MI(): return map(int, sys.stdin.buffer.readline().split())\r\ndef LI(): return list(map(int, sys.stdin.buffer.readline().split()))\r\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\r\ndef BI(): return sys.stdin.buffer.readline().rstrip()\r\ndef SI(): return sys.stdin.buffer.readline().rstrip().decode()\r\ninf = 10**16\r\nmd = 10**9+7\r\n# md = 998244353\r\n\r\nn = II()\r\nxy = LLI(n)\r\nans = [0, 1]\r\n\r\ndef vec(i, j):\r\n    x0, y0 = xy[i]\r\n    x1, y1 = xy[j]\r\n    return x1-x0, y1-y0\r\n\r\ndef less90(i, j, k):\r\n    v1 = vec(j, i)\r\n    v2 = vec(j, k)\r\n    return v1[0]*v2[0]+v1[1]*v2[1] > 0\r\n\r\nfor i in range(2, n):\r\n    ans.append(i)\r\n    j = len(ans)\r\n    while j > 2:\r\n        if less90(ans[j-3], ans[j-2], ans[j-1]): break\r\n        ans[j-1], ans[j-2] = ans[j-2], ans[j-1]\r\n        j -= 1\r\n\r\nprint(\" \".join(str(i+1) for i in ans))","tags":["geometry"],"src_uid":"a464c3bd13fe9358c2419b17981522f6"}
{"text_full":"[DESCRIPTION]$$$n$$$ distinct integers $$$x_1,x_2,\\ldots,x_n$$$ are written on the board. Nezzar can perform the following operation multiple times.  Select two integers $$$x,y$$$ (not necessarily distinct) on the board, and write down $$$2x-y$$$. Note that you don't remove selected numbers. Now, Nezzar wonders if it is possible to have his favorite number $$$k$$$ on the board after applying above operation multiple times.[SOURCE CODE]import math\r\nfor t in range(int(input())):\r\n\tn, k = map(int,input().split())\r\n\ta = list(map(int,input().split()))\r\n\tans = 0\r\n\tfor i in range(1, n):\r\n\t\tans = math.gcd(ans, a[i]-a[i - 1])\r\n\tif (k-a[0])%ans==0:\r\n\t\tprint (\"YES\")\r\n\telse:\r\n\t\tprint (\"NO\")","tags":["math","number theory"],"src_uid":"ccb5369bc4175ba071969571ceb17227"}
{"text_full":"[DESCRIPTION]PizzaForces is Petya's favorite pizzeria. PizzaForces makes and sells pizzas of three sizes: small pizzas consist of $$$6$$$ slices, medium ones consist of $$$8$$$ slices, and large pizzas consist of $$$10$$$ slices each. Baking them takes $$$15$$$, $$$20$$$ and $$$25$$$ minutes, respectively.Petya's birthday is today, and $$$n$$$ of his friends will come, so he decided to make an order from his favorite pizzeria. Petya wants to order so much pizza that each of his friends gets at least one slice of pizza. The cooking time of the order is the total baking time of all the pizzas in the order.Your task is to determine the minimum number of minutes that is needed to make pizzas containing at least $$$n$$$ slices in total. For example:   if $$$12$$$ friends come to Petya's birthday, he has to order pizzas containing at least $$$12$$$ slices in total. He can order two small pizzas, containing exactly $$$12$$$ slices, and the time to bake them is $$$30$$$ minutes;  if $$$15$$$ friends come to Petya's birthday, he has to order pizzas containing at least $$$15$$$ slices in total. He can order a small pizza and a large pizza, containing $$$16$$$ slices, and the time to bake them is $$$40$$$ minutes;  if $$$300$$$ friends come to Petya's birthday, he has to order pizzas containing at least $$$300$$$ slices in total. He can order $$$15$$$ small pizzas, $$$10$$$ medium pizzas and $$$13$$$ large pizzas, in total they contain $$$15 \\cdot 6 + 10 \\cdot 8 + 13 \\cdot 10 = 300$$$ slices, and the total time to bake them is $$$15 \\cdot 15 + 10 \\cdot 20 + 13 \\cdot 25 = 750$$$ minutes;  if only one friend comes to Petya's birthday, he can order a small pizza, and the time to bake it is $$$15$$$ minutes.[SOURCE CODE]for _ in range(int(input())):\r\n    n=int(input())\r\n    print(max(15,(n+1)\/\/2*5))","tags":["math"],"src_uid":"3e27f1c06a263760f5b53c3afe4bf7ee"}
{"text_full":"[DESCRIPTION]Thanos wants to destroy the avengers base, but he needs to destroy the avengers along with their base.Let we represent their base with an array, where each position can be occupied by many avengers, but one avenger can occupy only one position. Length of their base is a perfect power of $$$2$$$. Thanos wants to destroy the base using minimum power. He starts with the whole base and in one step he can do either of following:   if the current length is at least $$$2$$$, divide the base into $$$2$$$ equal halves and destroy them separately, or  burn the current base. If it contains no avenger in it, it takes $$$A$$$ amount of power, otherwise it takes his $$$B \\cdot n_a \\cdot l$$$ amount of power, where $$$n_a$$$ is the number of avengers and $$$l$$$ is the length of the current base. Output the minimum power needed by Thanos to destroy the avengers' base.[SOURCE CODE]def inint():\n    return int(input())\ndef mp():\n    return map(int,input().split())\nfrom bisect import bisect,bisect_left\n    \ndef sol(i,j):\n    works=bisect(a,j)-bisect_left(a,i)\n    if works==0:return A\n    if i==j:return B*works\n    m=(i+j)>>1\n    return min(B*(j-i+1)*works,sol(i,m)+sol(m+1,j))    \n    \nn,k,A,B=mp()\na=list(mp())\na.sort()\n#print(a)\nprint(sol(1,2**n))","tags":["math"],"src_uid":"4695aa2b3590a0734ef2c6c580e471a9"}
{"text_full":"[DESCRIPTION]You are given an array $$$a$$$ of $$$n$$$ integers and a set $$$B$$$ of $$$m$$$ positive integers such that $$$1 \\leq b_i \\leq \\lfloor \\frac{n}{2} \\rfloor$$$ for $$$1\\le i\\le m$$$, where $$$b_i$$$ is the $$$i$$$-th element of $$$B$$$. You can make the following operation on $$$a$$$:  Select some $$$x$$$ such that $$$x$$$ appears in $$$B$$$. Select an interval from array $$$a$$$ of size $$$x$$$ and multiply by $$$-1$$$ every element in the interval. Formally, select $$$l$$$ and $$$r$$$ such that $$$1\\leq l\\leq r \\leq n$$$ and $$$r-l+1=x$$$, then assign $$$a_i:=-a_i$$$ for every $$$i$$$ such that $$$l\\leq i\\leq r$$$. Consider the following example, let $$$a=[0,6,-2,1,-4,5]$$$ and $$$B=\\{1,2\\}$$$:  $$$[0,6,-2,-1,4,5]$$$ is obtained after choosing size $$$2$$$ and $$$l=4$$$, $$$r=5$$$. $$$[0,6,2,-1,4,5]$$$ is obtained after choosing size $$$1$$$ and $$$l=3$$$, $$$r=3$$$. Find the maximum $$$\\sum\\limits_{i=1}^n {a_i}$$$ you can get after applying such operation any number of times (possibly zero).[SOURCE CODE]from __future__ import division, print_function\r\n\r\nimport os,sys\r\nfrom io import BytesIO, IOBase\r\n\r\nif sys.version_info[0] < 3:\r\n    from __builtin__ import xrange as range\r\n    from future_builtins import ascii, filter, hex, map, oct, zip\r\n\r\nfrom bisect import bisect_left as lower_bound, bisect_right as upper_bound \r\ndef so():  return int(input())\r\ndef st():  return input()\r\ndef mj():  return map(int,input().strip().split(\" \"))\r\ndef msj(): return list(map(str,input().strip().split(\" \")))\r\ndef le():  return list(map(int,input().split()))\r\ndef rc():  return map(float,input().split())\r\ndef lebe():return list(map(int, input()))\r\n\r\ndef dmain():\r\n    sys.setrecursionlimit(1000000)\r\n    threading.stack_size(1024000)\r\n    thread = threading.Thread(target=main)\r\n    thread.start()\r\ndef joro(L):\r\n    return(''.join(map(str, L)))\r\n\r\n\r\ndef decimalToBinary(n): return bin(n).replace(\"0b\",\"\")\r\n\r\n\r\ndef isprime(n):\r\n    for i in range(2,int(n**0.5)+1):\r\n        if n%i==0:\r\n            return False\r\n    return True\r\ndef npr(n, r):\r\n    return factorial(n) \/\/ factorial(n - r) if n >= r else 0\r\n \r\n \r\ndef ncr(n, r):\r\n    import math as my\r\n    return my.factorial(n) \/\/ (my.factorial(r) * my.factorial(n - r)) if n >= r else 0\r\n \r\n \r\ndef lower_bound(li, num):\r\n    answer = -1\r\n    start = 0\r\n    end = len(li) - 1\r\n \r\n    while (start <= end):\r\n        middle = (end + start) \/\/ 2\r\n        if li[middle] >= num:\r\n            answer = middle\r\n            end = middle - 1\r\n        else:\r\n            start = middle + 1\r\n    return answer  # min index where x is not less than num\r\n \r\n \r\ndef upper_bound(li, num):\r\n    answer = -1\r\n    start = 0\r\n    end = len(li) - 1\r\n \r\n    while (start <= end):\r\n        middle = (end + start) \/\/ 2\r\n \r\n        if li[middle] <= num:\r\n            answer = middle\r\n            start = middle + 1\r\n \r\n        else:\r\n            end = middle - 1\r\n    return answer  # max index where x is not greater than num\r\ndef tir(a,b,c):\r\n    if(0==c):\r\n        return 1\r\n    if(len(a)<=b):\r\n        return 0\r\n    \r\n    if(c!=-1):\r\n        return (tir(a,1+b,c+a[b]) or tir(a,b+1,c-a[b]) or tir(a,1+b,c)) \r\n        \r\n        \r\n    else:\r\n        return (tir(a,1+b,a[b]) or tir(a,b+1,-a[b]) or tir(a,1+b,-1))\r\nhoi=int(2**20)        \r\n \r\ndef abs(x):\r\n    return x if x >= 0 else -x\r\n \r\n \r\ndef binary_search(li, val, lb, ub):\r\n    # print(lb, ub, li)\r\n    ans = -1\r\n    while (lb <= ub):\r\n        mid = (lb + ub) \/\/ 2\r\n        # print('mid is',mid, li[mid])\r\n        if li[mid] > val:\r\n            ub = mid - 1\r\n        elif val > li[mid]:\r\n            lb = mid + 1\r\n        else:\r\n            ans = mid  # return index\r\n            break\r\n    return ans\r\n \r\n \r\ndef kadane(x):  # maximum sum contiguous subarray\r\n    sum_so_far = 0\r\n    current_sum = 0\r\n    for i in x:\r\n        current_sum += i\r\n        if current_sum < 0:\r\n            current_sum = 0\r\n        else:\r\n            sum_so_far = max(sum_so_far, current_sum)\r\n    return sum_so_far\r\n\r\n                    \r\ndef pref(li):\r\n    pref_sum = [0]\r\n    for i in li:\r\n        pref_sum.append(pref_sum[-1] + i)\r\n    return pref_sum\r\ndef gosa(a,b):\r\n    if(b==0):\r\n        return a\r\n    else:\r\n        return gosa(b,a%b) \r\n\r\n        \r\n        \r\ndef SieveOfEratosthenes(n):\r\n    prime = [True for i in range(n + 1)]\r\n    p = 2\r\n    li = []\r\n    while (p * p <= n):\r\n        if (prime[p] == True):\r\n            for i in range(p * p, n + 1, p):\r\n                prime[i] = False\r\n        p += 1\r\n \r\n    for p in range(2, len(prime)):\r\n        if prime[p]:\r\n            li.append(p)\r\n    return li\r\n \r\n \r\ndef primefactors(n):\r\n    factors = []\r\n    while (n % 2 == 0):\r\n        factors.append(2)\r\n        n \/\/= 2\r\n    for i in range(3, int(sqrt(n)) + 1, 2):  # only odd factors left\r\n        while n % i == 0:\r\n            factors.append(i)\r\n            n \/\/= i\r\n    if n > 2:  # incase of prime\r\n        factors.append(n)\r\n    return factors\r\n         \r\n    \r\ndef read():\r\n    sys.stdin  = open('input.txt', 'r')  \r\n    sys.stdout = open('output.txt', 'w') \r\ndef tr(n):\r\n    return n*(n+1)\/\/2\r\nboi=int(1e9-7)\r\ndoi=int(1e9+7)\r\nhoi=int(100+1e6)\r\ny=\"Yes\"\r\nn=\"No\"\r\nx=[0]*hoi\r\ny=[0]*hoi\r\ndef cal(jp,op,u):\r\n    re=0\r\n    te=1\r\n    while(te<=op):\r\n        z=0\r\n        p=int(2e9)\r\n        ad=0\r\n        for i in range(te,jp+1,op):\r\n            if(0>x[i]):\r\n                z=z^1\r\n            ad=abs(x[i])+ad\r\n            p=min(abs(x[i]),p)\r\n        if(0!=z^u):\r\n            ad=-2*p+ad\r\n        re=ad+re\r\n        te=1+te\r\n    return re\r\n\r\n    \r\n    \r\n    \r\n\r\ndef iu():\r\n    import sys\r\n    import math as my\r\n    input=sys.stdin.readline\r\n    from collections import deque, defaultdict\r\n    jp,kp=mj()\r\n    \r\n    L=le()\r\n    M=le()\r\n    for i in range(1+jp):\r\n        x[i]=L[i-1]\r\n    op=0\r\n    for i in range(1+kp):\r\n        y[i]=M[i-1]\r\n        op=gosa(y[i],op)\r\n    opp=max(cal(jp,op,0),cal(jp,op,1))\r\n    print(opp)\r\ndef main():\r\n    for i in range(so()):\r\n        iu()\r\n    \r\n\r\n    \r\n        \r\n        \r\n            \r\n    \r\n    \r\n                \r\n            \r\n                \r\n                \r\n                \r\n                \r\n            \r\n    \r\n            \r\n            \r\n    \r\n    \r\n    \r\n    \r\n        \r\n            \r\n    \r\n           \r\n            \r\n            \r\n        \r\n    \r\n        \r\n    \r\n    \r\n        \r\n        \r\n        \r\n\r\n            \r\n                    \r\n                \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n        \r\n                \r\n        \r\n        \r\n       \r\n    \r\n           \r\n          \r\n          \r\n                \r\n            \r\n        \r\n                \r\n    \r\n        \r\n        \r\n        \r\n       \r\n            \r\n                \r\n        \r\n\r\n\r\n\r\n\r\n# region fastio\r\n# template taken from https:\/\/github.com\/cheran-senthil\/PyRival\/blob\/master\/templates\/template.py\r\n\r\nBUFSIZE = 8192\r\n\r\n\r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n\r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n\r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n\r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n\r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\n\r\n\r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\n\r\n\r\ndef print(*args, **kwargs):\r\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\r\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\r\n    at_start = True\r\n    for x in args:\r\n        if not at_start:\r\n            file.write(sep)\r\n        file.write(str(x))\r\n        at_start = False\r\n    file.write(kwargs.pop(\"end\", \"\\n\"))\r\n    if kwargs.pop(\"flush\", False):\r\n        file.flush()\r\n\r\n\r\nif sys.version_info[0] < 3:\r\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\r\nelse:\r\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\n\r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\n\r\n# endregion\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    #read()\r\n    main()\r\n    #dmain()\r\n\r\n# Comment Read()","tags":["number theory"],"src_uid":"882deb8385fb175b4547f43b1eb01fc6"}
{"text_full":"[DESCRIPTION]This is an interactive problem.There was a tournament consisting of $$$2^n$$$ contestants. The $$$1$$$-st contestant competed with the $$$2$$$-nd, the $$$3$$$-rd competed with the $$$4$$$-th, and so on. After that, the winner of the first match competed with the winner of second match, etc. The tournament ended when there was only one contestant left, who was declared the winner of the tournament. Such a tournament scheme is known as the single-elimination tournament.You don't know the results, but you want to find the winner of the tournament. In one query, you select two integers $$$a$$$ and $$$b$$$, which are the indices of two contestants. The jury will return $$$1$$$ if $$$a$$$ won more matches than $$$b$$$, $$$2$$$ if $$$b$$$ won more matches than $$$a$$$, or $$$0$$$ if their number of wins was equal.Find the winner in no more than $$$\\left \\lceil \\frac{1}{3} \\cdot 2^{n + 1} \\right \\rceil$$$ queries. Here $$$\\lceil x \\rceil$$$ denotes the value of $$$x$$$ rounded up to the nearest integer.Note that the tournament is long over, meaning that the results are fixed and do not depend on your queries.[SOURCE CODE]t= int(input())\r\nfor _ in range(t):\r\n    n=int(input())\r\n    P = [i for i in range(1,2**n+1)]\r\n    while n>1:\r\n        k=[]\r\n        for i in range(0,2**(n)-1,4):\r\n            print(\"? \", P[i], P[i+2], flush =True)\r\n            a = int(input())\r\n            if a==0:\r\n                k.extend([P[i+1],P[i+3]])\r\n            elif a==1:\r\n                k.extend([P[i], P[i+3]])\r\n            elif a ==2:\r\n                k.extend([P[i+2],P[i+1]])\r\n        n-=1\r\n        P=k\r\n    print(\"? \", P[0],P[1],flush =True)\r\n    a=int(input())\r\n    if a ==1:print(\"!\",P[0],flush =True)\r\n    else:print(\"!\",P[1],flush =True)","tags":["number theory","probabilities"],"src_uid":"c9bc4fefa96b741843e54a8fb4b02877"}
{"text_full":"[DESCRIPTION]You are given a string $$$s$$$ consisting of $$$n$$$ characters. Each character of $$$s$$$ is either 0 or 1.A substring of $$$s$$$ is a contiguous subsequence of its characters.You have to choose two substrings of $$$s$$$ (possibly intersecting, possibly the same, possibly non-intersecting — just any two substrings). After choosing them, you calculate the value of the chosen pair of substrings as follows:  let $$$s_1$$$ be the first substring, $$$s_2$$$ be the second chosen substring, and $$$f(s_i)$$$ be the integer such that $$$s_i$$$ is its binary representation (for example, if $$$s_i$$$ is 11010, $$$f(s_i) = 26$$$);  the value is the bitwise OR of $$$f(s_1)$$$ and $$$f(s_2)$$$. Calculate the maximum possible value you can get, and print it in binary representation without leading zeroes.[SOURCE CODE]n = int(input())\ns = input()\ns = list(s)\ni = 0\nwhile s[i] == '0':\n    i += 1\n    if i == n:\n        break\nif i == n:\n    print(0)\nelse:\n    s = s[i:]\n    n = len(s)\n    ans = [i for i in s]\n    i = 0\n    o = 0\n    while s[i] == '1':\n        o += 1\n        i += 1\n    if o == 0:\n        print('0')\n    else:\n        ones = [j for j in range(1, o+1)]\n        while i < n and len(ones) > 0:\n            if s[i] == '0':\n                tmp = []\n                for j in ones:\n                    if s[i - j] == '1':\n                        tmp.append(j)\n                if len(tmp) > 0:\n                    ans[i] = '1'\n                    ones = tmp\n            i += 1\n        anss = ''\n        for i in ans:\n            anss += i\n        print(anss)","tags":["probabilities"],"src_uid":"7f855479e9df3405bb29f2a0cb1cb3b3"}
{"text_full":"[DESCRIPTION]Alice has recently received an array $$$a_1, a_2, \\dots, a_n$$$ for her birthday! She is very proud of her array, and when she showed her friend Bob the array, he was very happy with her present too!However, soon Bob became curious, and as any sane friend would do, asked Alice to perform $$$q$$$ operations of two types on her array:  $$$1$$$ $$$x$$$ $$$y$$$: update the element $$$a_x$$$ to $$$y$$$ (set $$$a_x = y$$$).  $$$2$$$ $$$l$$$ $$$r$$$: calculate how many non-decreasing subarrays exist within the subarray $$$[a_l, a_{l+1}, \\dots, a_r]$$$. More formally, count the number of pairs of integers $$$(p,q)$$$ such that $$$l \\le p \\le q \\le r$$$ and $$$a_p \\le a_{p+1} \\le \\dots \\le a_{q-1} \\le a_q$$$. Help Alice answer Bob's queries![SOURCE CODE]# Based on https:\/\/codeforces.com\/contest\/1567\/submission\/127989410\n# But use ffi for data layout and use double instead of big integer for answer\n\nimport sys\nfrom cffi import FFI\n\ninput = sys.stdin.buffer.readline\n\nffi = FFI()\nffi.cdef(\n    \"\"\"\n    typedef struct {\n        int first;\n        int last;\n        int suf;\n        int pre;\n        int length;\n        double ans;\n    } node_t;\n    \"\"\"\n)\n\n\n\n\nMX = 2 << ((2 * 10 ** 5) - 1).bit_length()\ndata = ffi.new(\"node_t[]\", MX + 3)\ndata[MX] = (0, 0, 0, 0, 0, 0)\nid_node = data[MX]\nres_left = MX + 1\nres_right = MX + 2\n\n\n\ndef combine(a, b):\n    if a.length == 0:\n        return b\n    if b.length == 0:\n        return a\n    first = a.first\n    last = b.last\n    suf = 0\n    pre = 0\n    length = a.length + b.length\n    ans = a.ans + b.ans\n    if a.last <= b.first:\n        if a.length == a.pre:\n            pre = b.pre + a.length\n        else:\n            pre = a.pre\n        if b.length == b.suf:\n            suf = a.suf + b.length\n        else:\n            suf = b.suf\n        ans += a.suf * b.pre\n    else:\n        pre = a.pre\n        suf = b.suf\n    return (first, last, suf, pre, length, ans)\n\n\ndef mapValue(x):\n    return (x, x, 1, 1, 1, 1)\n\n\nclass SegmentTree:\n    def __init__(self, N, A):\n        self._len = N\n        self._size = _size = 1 << (self._len - 1).bit_length()\n        for i in range(2 * _size):\n            data[i] = id_node\n        for i, x in enumerate(A):\n            data[_size + i] = mapValue(x)\n        for i in reversed(range(_size)):\n            data[i] = combine(data[i + i], data[i + i + 1])\n\n    def __delitem__(self, idx):\n        self[idx] = id_node\n\n    def __getitem__(self, idx):\n        return data[idx + self._size]\n\n    def __setitem__(self, idx, value):\n        idx += self._size\n        data[idx] = value\n        idx >>= 1\n        while idx:\n            data[idx] = combine(data[2 * idx], data[2 * idx + 1])\n            idx >>= 1\n\n    def __len__(self):\n        return self._len\n\n    def query(self, start, stop):\n        \"\"\"func of data[start, stop)\"\"\"\n        start += self._size\n        stop += self._size\n        data[res_left] = id_node\n        data[res_right] = id_node\n        while start < stop:\n            if start & 1:\n                data[res_left] = combine(data[res_left], data[start])\n                start += 1\n            if stop & 1:\n                stop -= 1\n                data[res_right] = combine(data[stop], data[res_right])\n            start >>= 1\n            stop >>= 1\n        data[res_left] = combine(data[res_left], data[res_right])\n        return data[res_left]\n\n\ndef main():\n    n, q = map(int, input().split())\n    segtree = SegmentTree(n, map(int, input().split()))\n    ans = []\n    for _ in range(q):\n        t, l, r = map(int, input().split())\n        l -= 1\n        if t == 1:\n            segtree[l] = mapValue(r)\n        else:\n            ans.append(int(segtree.query(l, r).ans))\n    print(\"\\n\".join(map(str, ans)))\n\n\nif __name__ == \"__main__\":\n    main()","tags":["math"],"src_uid":"0373262cf6c4c6d29fbf2177a1649cee"}
{"text_full":"[DESCRIPTION]You are given an array $$$a_1, a_2, \\dots , a_n$$$, which is sorted in non-decreasing order ($$$a_i \\le a_{i + 1})$$$. Find three indices $$$i$$$, $$$j$$$, $$$k$$$ such that $$$1 \\le i &lt; j &lt; k \\le n$$$ and it is impossible to construct a non-degenerate triangle (a triangle with nonzero area) having sides equal to $$$a_i$$$, $$$a_j$$$ and $$$a_k$$$ (for example it is possible to construct a non-degenerate triangle with sides $$$3$$$, $$$4$$$ and $$$5$$$ but impossible with sides $$$3$$$, $$$4$$$ and $$$7$$$). If it is impossible to find such triple, report it.[SOURCE CODE]for u in range(int(input())):\n    n = int(input())\n    x = [int(w) for w in input().split()]\n    \n    if x[0] + x[1] > x[-1]:\n        print(-1)\n        \n    else:\n        print(1, 2, n)","tags":["geometry","math"],"src_uid":"341555349b0c1387334a0541730159ac"}
{"text_full":"[DESCRIPTION]Polycarp was recently given a set of $$$n$$$ (number $$$n$$$ — even) dominoes. Each domino contains two integers from $$$1$$$ to $$$n$$$.Can he divide all the dominoes into two sets so that all the numbers on the dominoes of each set are different? Each domino must go into exactly one of the two sets.For example, if he has $$$4$$$ dominoes: $$$\\{1, 4\\}$$$, $$$\\{1, 3\\}$$$, $$$\\{3, 2\\}$$$ and $$$\\{4, 2\\}$$$, then Polycarp will be able to divide them into two sets in the required way. The first set can include the first and third dominoes ($$$\\{1, 4\\}$$$ and $$$\\{3, 2\\}$$$), and the second set — the second and fourth ones ($$$\\{1, 3\\}$$$ and $$$\\{4, 2\\}$$$).[SOURCE CODE]import sys\r\ninput= sys.stdin.readline\r\ndef solve():\r\n        n = int(input())\r\n        adj = [[] for i in range(n)]\r\n        f= False\r\n        for i in range(n):\r\n            a,b = map(int,input().split(' '))\r\n            a-=1\r\n            b-=1\r\n            adj[a].append(b)\r\n            adj[b].append(a)\r\n            if len(adj[a])  > 2 or len(adj[b]) > 2 or a ==b:\r\n                f = True\r\n        if f==True:\r\n            sys.stdout.write('No\\n')\r\n            return        \r\n        color = [-1 for i in range(n)]\r\n        for i in range(n):\r\n            if color[i] == -1:\r\n                q = []\r\n                q.append(i)\r\n                color[i] = 0\r\n                while len(q)>0:\r\n                    a = q.pop(0)\r\n                    for k in adj[a]:\r\n                        if a ==k:\r\n                            f = True\r\n                            sys.stdout.write('No\\n')\r\n                            return\r\n                        if color[k] ==  -1:\r\n                            if color[a] == 1:\r\n                                color[k] = 0\r\n                            else:\r\n                                color[k] = 1    \r\n                            q.append(k)\r\n                        else:\r\n                            if color[k] == color[a]:\r\n                                f = True\r\n                                print('No')\r\n                                return\r\n        if f:\r\n            sys.stdout.write('No\\n')\r\n        else:\r\n            sys.stdout.write('Yes\\n')        \r\nt = int(input())\r\nfor _ in range(t): \r\n    solve()","tags":["graphs"],"src_uid":"8717913513b019d3ef836176eafce7b1"}
{"text_full":"[DESCRIPTION]Multiset —is a set of numbers in which there can be equal elements, and the order of the numbers does not matter. Two multisets are equal when each value occurs the same number of times. For example, the multisets $$$\\{2,2,4\\}$$$ and $$$\\{2,4,2\\}$$$ are equal, but the multisets $$$\\{1,2,2\\}$$$ and $$$\\{1,1,2\\}$$$ — are not.You are given two multisets $$$a$$$ and $$$b$$$, each consisting of $$$n$$$ integers.In a single operation, any element of the $$$b$$$ multiset can be doubled or halved (rounded down). In other words, you have one of the following operations available for an element $$$x$$$ of the $$$b$$$ multiset:   replace $$$x$$$ with $$$x \\cdot 2$$$,  or replace $$$x$$$ with $$$\\lfloor \\frac{x}{2} \\rfloor$$$ (round down).  Note that you cannot change the elements of the $$$a$$$ multiset.See if you can make the multiset $$$b$$$ become equal to the multiset $$$a$$$ in an arbitrary number of operations (maybe $$$0$$$).For example, if $$$n = 4$$$, $$$a = \\{4, 24, 5, 2\\}$$$, $$$b = \\{4, 1, 6, 11\\}$$$, then the answer is yes. We can proceed as follows:   Replace $$$1$$$ with $$$1 \\cdot 2 = 2$$$. We get $$$b = \\{4, 2, 6, 11\\}$$$.  Replace $$$11$$$ with $$$\\lfloor \\frac{11}{2} \\rfloor = 5$$$. We get $$$b = \\{4, 2, 6, 5\\}$$$.  Replace $$$6$$$ with $$$6 \\cdot 2 = 12$$$. We get $$$b = \\{4, 2, 12, 5\\}$$$.  Replace $$$12$$$ with $$$12 \\cdot 2 = 24$$$. We get $$$b = \\{4, 2, 24, 5\\}$$$.  Got equal multisets $$$a = \\{4, 24, 5, 2\\}$$$ and $$$b = \\{4, 2, 24, 5\\}$$$.[SOURCE CODE]#!\/usr\/bin\/env python3\r\n \r\nimport io, os, sys\r\nfrom sys import stdin, stdout\r\n \r\n# input = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\r\ndef input(): return stdin.readline().strip()\r\ndef read_int_list(): return list(map(int, input().split()))\r\ndef read_int_tuple(): return tuple(map(int, input().split()))\r\ndef read_int(): return int(input())\r\n \r\nfrom itertools import permutations, chain, combinations, product\r\nfrom math import factorial, gcd\r\nfrom collections import Counter, defaultdict, deque\r\nfrom heapq import heappush, heappop, heapify\r\nfrom bisect import bisect_left\r\nfrom functools import lru_cache\r\nimport random\r\n \r\n### CODE HERE\r\n\r\nimport sys\r\nimport array\r\n\r\nclass BinaryTrie_pool:\r\n    def __repr__(self) -> str:\r\n        return f\"{self.num_words, self.starts, self.child0, self.child1}\"\r\n\r\n    def alloc(self):\r\n\r\n        self.num_words.append(0)\r\n        self.starts.append(0)\r\n        self.child0.append(-1)\r\n        self.child1.append(-1)\r\n\r\n        self.next_alloc += 1\r\n        return self.next_alloc - 1\r\n\r\n    def __init__(self):\r\n\r\n        self.num_words = array.array('L')\r\n        self.starts = array.array('L')\r\n        self.child0 = array.array('l')\r\n        self.child1 = array.array('l')\r\n\r\n        self.next_alloc = 0\r\n\r\n        self.root = self.alloc()\r\n\r\n    def anyChild(self, node):\r\n        if self.child0[node] != -1 and self.starts[self.child0[node]] > 0:\r\n            return self.child0[node]\r\n        if self.child1[node] != -1 and self.starts[self.child1[node]] > 0:\r\n            return self.child1[node]\r\n\r\n    def insert(self, word):\r\n        word = list(map(int, word))\r\n        node=self.root\r\n        for i in word:\r\n            self.starts[node] += 1\r\n\r\n            if i == 0 and self.child0[node] == -1: self.child0[node] = self.alloc()\r\n            if i == 1 and self.child1[node] == -1: self.child1[node] = self.alloc()\r\n\r\n            node = self.child0[node] if i == 0 else self.child1[node]\r\n        self.num_words[node] += 1\r\n        self.starts[node] += 1\r\n\r\n    def findAnyWithPrefix(self, prefix):\r\n        prefix = list(map(int, prefix))\r\n\r\n        node = self.findNode(prefix)\r\n        if node == -1 or node is None:\r\n            return None\r\n        if self.starts[node] == 0:\r\n            return None\r\n        while self.num_words[node] == 0:\r\n            node = self.anyChild(node)\r\n        return node\r\n\r\n    def containsWord(self, word):\r\n        word = list(map(int, word))\r\n        node = self.findNode(word)\r\n        if node == -1: return False\r\n        return node.num_words > 0\r\n\r\n    def remove(self, word):\r\n        word = list(map(int, word))\r\n        node=self.root\r\n        self.starts[node] -= 1\r\n        for i in word:\r\n            if i == 0 and self.child0[node] == -1: return None\r\n            if i == 1 and self.child1[node] == -1: return None\r\n\r\n            node = self.child0[node] if i == 0 else self.child1[node]\r\n\r\n            self.starts[node] -= 1\r\n        self.num_words[node] -= 1\r\n\r\n    def removeAnyWithPrefix(self, prefix):\r\n        prefix = list(map(int, prefix))\r\n        node=self.root\r\n        for i in prefix:\r\n            self.starts[node] -= 1\r\n            node = self.child0[node] if i == 0 else self.child1[node]\r\n\r\n        if self.num_words[node] > 0:\r\n            self.starts[node] -= 1\r\n            self.num_words[node] -= 1\r\n            return \r\n        \r\n        self.starts[node] -= 1\r\n\r\n        while self.num_words[node] == 0:\r\n            node = self.anyChild(node)\r\n            self.starts[node] -= 1\r\n        \r\n        self.num_words[node] -= 1\r\n\r\n    def findNode(self, word):\r\n        word = list(map(int, word))\r\n        \r\n        node=self.root\r\n        for i in word:\r\n            if i == 0 and self.child0[node] == -1: return None\r\n            if i == 1 and self.child1[node] == -1: return None\r\n\r\n            node = self.child0[node] if i == 0 else self.child1[node]\r\n\r\n        return node\r\n\r\n    def startsWith(self, prefix):\r\n        prefix = list(map(int, prefix))\r\n\r\n        node = self.findNode(prefix)\r\n        if node == -1: return False\r\n        return self.starts[node] > 0\r\n \r\ndef clean(arr):\r\n    ret = []\r\n    for a in arr:\r\n        x = a\r\n        while x > 0 and x % 2 == 0:\r\n            x \/\/= 2\r\n        ret += [x]\r\n    return sorted(ret)[::-1]\r\n \r\ndef bin(x):\r\n    return \"{0:b}\".format(x)\r\n \r\ndef ans(A, B):\r\n    A = clean(A)\r\n    B = clean(B)\r\n\r\n    A = [bin(x) for x in A]\r\n    B = [bin(x) for x in B]\r\n\r\n    t = BinaryTrie_pool()\r\n\r\n    for b in B:\r\n        t.insert(b)\r\n \r\n    for a in A:\r\n        w = t.findAnyWithPrefix(a)\r\n \r\n        if w is None:\r\n            return \"NO\"\r\n\r\n        t.removeAnyWithPrefix(a)\r\n         \r\n    return \"YES\"\r\n \r\nif False:\r\n    t = BinaryTrie_pool()\r\n    t.insert(\"10\")\r\n    t.insert(\"100\")\r\n    print(t)\r\n    print(t.anyChild(0))\r\nelse:\r\n    for _ in range(read_int()):\r\n        input()\r\n        A = read_int_list()\r\n        B = read_int_list()\r\n\r\n        print(ans(A, B))","tags":["math","number theory"],"src_uid":"bcd34e88bcd70ad36acbe6c3b70aa45d"}
{"text_full":"[DESCRIPTION]There is a grid, consisting of $$$n$$$ rows and $$$m$$$ columns. Each cell of the grid is either free or blocked. One of the free cells contains a lab. All the cells beyond the borders of the grid are also blocked.A crazy robot has escaped from this lab. It is currently in some free cell of the grid. You can send one of the following commands to the robot: \"move right\", \"move down\", \"move left\" or \"move up\". Each command means moving to a neighbouring cell in the corresponding direction.However, as the robot is crazy, it will do anything except following the command. Upon receiving a command, it will choose a direction such that it differs from the one in command and the cell in that direction is not blocked. If there is such a direction, then it will move to a neighbouring cell in that direction. Otherwise, it will do nothing.We want to get the robot to the lab to get it fixed. For each free cell, determine if the robot can be forced to reach the lab starting in this cell. That is, after each step of the robot a command can be sent to a robot such that no matter what different directions the robot chooses, it will end up in a lab.[SOURCE CODE]import sys\r\nimport os\r\nfrom io import BytesIO, IOBase\r\nfrom collections import deque\r\n\r\n# region fastio\r\nBUFSIZE = 8192\r\n \r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n \r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n \r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n \r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n \r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\n \r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\n\r\nif sys.version_info[0] < 3:\r\n    sys.stdin = BytesIO(os.read(0, os.fstat(0).st_size))\r\nelse:\r\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\n\r\nf = sys.stdin\r\nif os.environ.get('USER') == \"loic\":\r\n    f = open(\"data.in\")\r\n    \r\nline = lambda: f.readline().split()\r\nui = lambda: int(line()[0])\r\nti = lambda: map(int,line())\r\nli = lambda: list(ti())\r\n\r\n#######################################################################\r\n\r\ndef neigh(i,j):\r\n    res = []\r\n    if i > 0:\r\n        res.append((i-1,j))\r\n    if i < N-1:\r\n        res.append((i+1,j))\r\n    if j > 0:\r\n        res.append((i,j-1))\r\n    if j < M-1:\r\n        res.append((i,j+1))\r\n    return res\r\n\r\ndef solve():\r\n    \r\n    start = (x,y)\r\n    \r\n    q = deque([start])\r\n\r\n    while q:\r\n        i,j = q.pop()\r\n        \r\n        chs = neigh(i, j)\r\n        \r\n        for i_n,j_n in chs:\r\n            val = G[i_n][j_n]\r\n            if val == '.':\r\n                cnt = 0\r\n                for i_ch,j_ch in neigh(i_n, j_n):\r\n                    if G[i_ch][j_ch] == '.':\r\n                        cnt += 1\r\n                if cnt <= 1:\r\n                    G[i_n][j_n] = '+'\r\n                    q.append((i_n,j_n))\r\n    \r\n    \r\n    res = \"\\n\".join(\"\".join(v for v in l) for l in G)\r\n    \r\n    return str(res)\r\n\r\nfor test in range(1,ui()+1):\r\n    N,M = ti()\r\n    G = []\r\n    x = -1\r\n    y = -1\r\n    \r\n    G = [list(line()[0]) for i in range(N)]\r\n    xLab = -1\r\n    yLab = -1\r\n    for i in range(N):\r\n        for j in range(M):\r\n            if G[i][j] == 'L':\r\n                x = i\r\n                y = j\r\n                break\r\n    \r\n#     for i in range(N):\r\n#         l = list(line()[0])\r\n#         G.append(l)\r\n#         if x == -1:\r\n#             for j in range(M):\r\n#                 if l[j] == 'L':\r\n#                     x = i\r\n#                     y = j\r\n#                     break\r\n    \r\n    print(solve())\r\n    \r\nf.close()","tags":["graphs"],"src_uid":"fa82a5160696616af784b5488c9f69f6"}
{"text_full":"[DESCRIPTION]Alice and Bob are playing a game. They have an array of positive integers $$$a$$$ of size $$$n$$$.Before starting the game, Alice chooses an integer $$$k \\ge 0$$$. The game lasts for $$$k$$$ stages, the stages are numbered from $$$1$$$ to $$$k$$$. During the $$$i$$$-th stage, Alice must remove an element from the array that is less than or equal to $$$k - i + 1$$$. After that, if the array is not empty, Bob must add $$$k - i + 1$$$ to an arbitrary element of the array. Note that both Alice's move and Bob's move are two parts of the same stage of the game. If Alice can't delete an element during some stage, she loses. If the $$$k$$$-th stage ends and Alice hasn't lost yet, she wins.Your task is to determine the maximum value of $$$k$$$ such that Alice can win if both players play optimally. Bob plays against Alice, so he tries to make her lose the game, if it's possible.[SOURCE CODE]import copy\r\nt = int(input())\r\nfor _ in range(t):\r\n    n = int(input())\r\n    ass = sorted(list(map(int, input().split())))\r\n    for k in range(n, 0, -1):\r\n        l = copy.deepcopy(ass)\r\n        for i in range(1, k + 1):\r\n            while len(l) > 0 and l[-1] > k - i + 1:\r\n                l.pop()\r\n            if len(l) == 0:\r\n                break\r\n            else:\r\n                l.pop()\r\n                if len(l) > 0:\r\n                    l.pop(0)\r\n        else:\r\n            print(k)\r\n            break\r\n    else:\r\n        print(0)","tags":["games"],"src_uid":"0682d5ee1b5b160ece449c4676a369a7"}
{"text_full":"[DESCRIPTION]There is a grid, consisting of $$$n$$$ rows and $$$m$$$ columns. The rows are numbered from $$$1$$$ to $$$n$$$ from bottom to top. The columns are numbered from $$$1$$$ to $$$m$$$ from left to right. The $$$i$$$-th column has the bottom $$$a_i$$$ cells blocked (the cells in rows $$$1, 2, \\dots, a_i$$$), the remaining $$$n - a_i$$$ cells are unblocked.A robot is travelling across this grid. You can send it commands — move up, right, down or left. If a robot attempts to move into a blocked cell or outside the grid, it explodes.However, the robot is broken — it executes each received command $$$k$$$ times. So if you tell it to move up, for example, it will move up $$$k$$$ times ($$$k$$$ cells). You can't send it commands while the robot executes the current one.You are asked $$$q$$$ queries about the robot. Each query has a start cell, a finish cell and a value $$$k$$$. Can you send the robot an arbitrary number of commands (possibly, zero) so that it reaches the finish cell from the start cell, given that it executes each command $$$k$$$ times?The robot must stop in the finish cell. If it visits the finish cell while still executing commands, it doesn't count.[SOURCE CODE]# stdin = open(\"testcase.txt\")\n \n# def input():\n# \treturn stdin.readline().strip()\n \n \n# import io, os\n# import sys\n \n # sys.stdout.write(str( (n-1)*(n-2) + 1 ) + \"\\n\")\n# input = io.BytesIO(os.read(0, \\\n#          os.fstat(0).st_size)).readline\nfrom math import log, ceil\n# # import sys\n# import sys\n# sys.setrecursionlimit(10000)\nfrom sys import stdin, stdout\n \n# from collections import Counter, defaultdict\n# from queue import PriorityQueue\n# from bisect import bisect_left, bisect_right\n# mod = 1000000007\n \ninput = stdin.readline\n \ndef integer_list():\n\treturn list(map(int, input().split()))\n \n# def string_list():\n# \treturn list(map(str, input().split()))\n \n# def hetro_list():\n# \treturn list(input().split())\ndef segment_tree_build(a: list, n: int):\n\tglobal tree\n \n\t# assign values to leaves of the segment tree\n\tfor i in range(n):\n\t\ttree[n + i] = a[i]\n \n\t# assign values to internal nodes\n\t# to compute maximum in a given range *\/\n\tfor i in range(n - 1, 0, -1):\n\t\ttree[i] = max(tree[2 * i], tree[2 * i + 1])\n \n \n \n \n \ndef range_query(left: int, right: int, n: int) -> int:\n\tglobal tree\n \n\t# Basically the left and right indices will move\n\t# towards right and left respectively and with\n\t# every each next higher level and compute the\n\t# maximum at each height.\n\t# change the index to leaf node first\n\tleft += n\n\tright += n\n \n\t# initialize maximum to a very low value\n\tma = -1\n\twhile left < right:\n \n\t\t# if left index in odd\n\t\tif left & 1:\n\t\t\t\n\t\t\tma = max(ma, tree[left])\n\t\t\tleft += 1\n \n\t\t# make left index even\n \n \n\t\t# if right index in odd\n\t\tif right & 1:\n \n\t\t# make right index even\n\t\t\tright -= 1\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n \n\t\t\tma = max(ma, tree[right])\n \n\t\t# move to the next higher level\n\t\tleft \/\/= 2\n\t\tright \/\/= 2\n\treturn ma\n \n \n \nfor _ in range(1):\n\tn, m = integer_list()\n \n\tlst = integer_list()\n \n\ttree = [0]*(2*m)\n\tsegment_tree_build(lst, m)\n \n \n \n \n\tq = int(input())\n\tfor j in range(q):\n\t\tx1 , y1 , x2 , y2 , k = integer_list()\n \n\t\txs , ys = x1 , y1\n\t\ty1 , y2 = min(y1 , y2) , max(y1 , y2)\n\t\tx1 , x2 = min(x1 , x2) , max(x1 , x2)\n \n\t\tif((x2 - x1) % k):\n\t\t\tstdout.write('NO' + \"\\n\")\n\t\t\tcontinue\n\t\tif((y2 - y1) % k):\n\t\t\tstdout.write('NO' + \"\\n\")\n\t\t\tcontinue\n \n\t\tbound = xs + k * ((n - xs) \/\/ k)\n\t\t\n\t\tif range_query(y1-1, y2, m) < bound:\n\t\t\tstdout.write('YES' + \"\\n\")\n\t\t\t\n\t\telse:\n\t\t\tstdout.write('NO' + \"\\n\")","tags":["math"],"src_uid":"19f12c275f2b389ed5a1af66808d1bbd"}
{"text_full":"[DESCRIPTION]You are given a matrix, consisting of $$$n$$$ rows and $$$m$$$ columns. The rows are numbered top to bottom, the columns are numbered left to right.Each cell of the matrix can be either free or locked.Let's call a path in the matrix a staircase if it:   starts and ends in the free cell;  visits only free cells;  has one of the two following structures:   the second cell is $$$1$$$ to the right from the first one, the third cell is $$$1$$$ to the bottom from the second one, the fourth cell is $$$1$$$ to the right from the third one, and so on;  the second cell is $$$1$$$ to the bottom from the first one, the third cell is $$$1$$$ to the right from the second one, the fourth cell is $$$1$$$ to the bottom from the third one, and so on.  In particular, a path, consisting of a single cell, is considered to be a staircase.Here are some examples of staircases:  Initially all the cells of the matrix are free.You have to process $$$q$$$ queries, each of them flips the state of a single cell. So, if a cell is currently free, it makes it locked, and if a cell is currently locked, it makes it free.Print the number of different staircases after each query. Two staircases are considered different if there exists such a cell that appears in one path and doesn't appear in the other path.[SOURCE CODE]class SplayTree():\r\n\tdef __init__(self):\r\n\t\tself.children={}\r\n\t\tself.parents={}\r\n\t\tself.root=None\r\n\tdef insert(self, x):\r\n\t\tif self.root is None:\r\n\t\t\tself.root=x\r\n\t\t\tself.children[x]=[None,None]\r\n\t\t\tself.parents[x]=None\r\n\t\telse:\r\n\t\t\tcurr = self.root\r\n\t\t\twhile True:\r\n\t\t\t\tif curr == x:\r\n\t\t\t\t\tself.splay(x)\r\n\t\t\t\t\treturn None\r\n\t\t\t\telif x < curr:\r\n\t\t\t\t\tif self.children[curr][0] is None:\r\n\t\t\t\t\t\tself.children[curr][0] = x\r\n\t\t\t\t\t\tself.children[x] = [None, None]\r\n\t\t\t\t\t\tself.parents[x] = curr\r\n\t\t\t\t\t\tself.splay(x)\r\n\t\t\t\t\t\treturn None\r\n\t\t\t\t\telse:\r\n\t\t\t\t\t\tcurr = self.children[curr][0]\r\n\t\t\t\telse:\r\n\t\t\t\t\tif self.children[curr][1] is None:\r\n\t\t\t\t\t\tself.children[curr][1] = x\r\n\t\t\t\t\t\tself.children[x] = [None, None]\r\n\t\t\t\t\t\tself.parents[x] = curr\r\n\t\t\t\t\t\tself.splay(x)\r\n\t\t\t\t\t\treturn None\r\n\t\t\t\t\telse:\r\n\t\t\t\t\t\tcurr = self.children[curr][1]\r\n\r\n\tdef find(self, x):\r\n\t\treturn x in self.parents\r\n\r\n\tdef delete(self, x, show=False):\r\n\t\tif self.children[x][0] is None and self.children[x][1] is None:\r\n\t\t\tif self.root == x:\r\n\t\t\t\tself.root = None\r\n\t\t\tdel self.children[x]\r\n\t\t\tp = self.parents[x]\r\n\t\t\tdel self.parents[x]\r\n\t\t\tfor i in range(2):\r\n\t\t\t\tif self.children[p][i] == x:\r\n\t\t\t\t\tself.children[p][i] = None\r\n\t\t\tself.splay(p)\r\n\t\telif self.children[x][0] is None or self.children[x][1] is None:\r\n\t\t\tif self.children[x][0] is None:\r\n\t\t\t\tind = 1\r\n\t\t\telse:\r\n\t\t\t\tind = 0\r\n\t\t\tchild = self.children[x][ind]\r\n\t\t\tif self.root == x:\r\n\t\t\t\tself.root = child\r\n\t\t\t\tdel self.children[x]\r\n\t\t\t\tdel self.parents[x]\r\n\t\t\t\tself.parents[child] = None\r\n\t\t\telse:\r\n\t\t\t\tp = self.parents[x]\r\n\t\t\t\tself.parents[child] = p\r\n\t\t\t\tfor i in range(2):\r\n\t\t\t\t\tif self.children[p][i] == x:\r\n\t\t\t\t\t\tself.children[p][i] = child\r\n\t\t\t\tdel self.parents[x]\r\n\t\t\t\tdel self.children[x]\r\n\t\t\t\tself.splay(p)\r\n\t\telse:\r\n\t\t\ts = self.successor(x)\r\n\t\t\tif self.parents[s] == x:\r\n\t\t\t\tskids = self.children[s][:]\r\n\t\t\t\txkid = self.children[x][0]\r\n\t\t\t\txpar = self.parents[x]\r\n\t\t\t\tself.children[s] = [xkid, x]\r\n\t\t\t\tself.parents[s] = xpar\r\n\t\t\t\tself.children[x] = skids\r\n\t\t\t\tself.parents[x] = s\r\n\t\t\t\tfor i in skids:\r\n\t\t\t\t\tif i is not None:\r\n\t\t\t\t\t\tself.parents[i] = x\r\n\t\t\t\tif xkid is not None:\r\n\t\t\t\t\tself.parents[xkid] = s\r\n\t\t\t\tif xpar is not None:\r\n\t\t\t\t\tfor i in range(2):\r\n\t\t\t\t\t\tif self.children[xpar][i] == x:\r\n\t\t\t\t\t\t\tself.children[xpar][i] = s\r\n\t\t\t\tif self.root == x:\r\n\t\t\t\t\tself.root = s\r\n\t\t\t\tself.delete(x)\r\n\t\t\t\tif xpar is not None:\r\n\t\t\t\t\tself.splay(xpar)\r\n\t\t\telse:\r\n\t\t\t\tskids = self.children[s][:]\r\n\t\t\t\tspar = self.parents[s]\r\n\t\t\t\txkids = self.children[x][:]\r\n\t\t\t\txpar = self.parents[x]\r\n\t\t\t\tself.children[s] = xkids\r\n\t\t\t\tself.parents[s] = xpar\r\n\t\t\t\tself.children[x] = skids\r\n\t\t\t\tself.parents[x] = spar\r\n\t\t\t\tfor i in skids:\r\n\t\t\t\t\tif i is not None:\r\n\t\t\t\t\t\tself.parents[i] = x\r\n\t\t\t\tfor i in xkids:\r\n\t\t\t\t\tif i is not None:\r\n\t\t\t\t\t\tself.parents[i] = s\r\n\t\t\t\tfor i in range(2):\r\n\t\t\t\t\tif spar is not None and self.children[spar][i] == s:\r\n\t\t\t\t\t\tself.children[spar][i] = x\r\n\t\t\t\t\tif xpar is not None and self.children[xpar][i] == x:\r\n\t\t\t\t\t\tself.children[xpar][i] = s\r\n\t\t\t\tif self.root == x:\r\n\t\t\t\t\tself.root = s\r\n\t\t\t\tif show:\r\n\t\t\t\t\tprint(self.children)\r\n\t\t\t\t\tprint(self.parents)\r\n\t\t\t\t\tprint(self.root)\r\n\t\t\t\tself.delete(x)\r\n\t\t\t\tif xpar is not None:\r\n\t\t\t\t\tself.splay(xpar)\r\n\r\n\tdef successor(self,x):\r\n\t\tif self.find(x):\r\n\t\t\tif self.children[x][1] is None:\r\n\t\t\t\tcurr = x\r\n\t\t\t\twhile self.parents[curr] is not None:\r\n\t\t\t\t\tif self.parents[curr] > curr:\r\n\t\t\t\t\t\treturn self.parents[curr]\r\n\t\t\t\t\tcurr = self.parents[curr]\r\n\t\t\t\treturn None \r\n\t\t\telse:\r\n\t\t\t\tcurr = self.children[x][1]\r\n\t\t\twhile self.children[curr][0] is not None:\r\n\t\t\t\tcurr = self.children[curr][0]\r\n\t\t\treturn curr\r\n\t\telse:\r\n\t\t\tcurr = self.root\r\n\t\t\tprev = None\r\n\t\t\twhile True:\r\n\t\t\t\tif x < curr:\r\n\t\t\t\t\tif self.children[curr][0] is None:\r\n\t\t\t\t\t\tself.splay(curr)\r\n\t\t\t\t\t\treturn curr\r\n\t\t\t\t\telse:\r\n\t\t\t\t\t\tprev = curr\r\n\t\t\t\t\t\tcurr = self.children[curr][0]\r\n\t\t\t\telse:\r\n\t\t\t\t\tif self.children[curr][1] is None:\r\n\t\t\t\t\t\tif prev is not None:\r\n\t\t\t\t\t\t\tself.splay(prev)\r\n\t\t\t\t\t\treturn prev\r\n\t\t\t\t\telse:\r\n\t\t\t\t\t\tcurr = self.children[curr][1]\r\n\tdef predecessor(self,x):\r\n\t\tif self.find(x):\r\n\t\t\tif self.children[x][0] is None:\r\n\t\t\t\tcurr = x\r\n\t\t\t\twhile self.parents[curr] is not None:\r\n\t\t\t\t\tif self.parents[curr] < curr:\r\n\t\t\t\t\t\treturn self.parents[curr]\r\n\t\t\t\t\tcurr = self.parents[curr]\r\n\t\t\t\treturn None\r\n\t\t\telse:\r\n\t\t\t\tcurr = self.children[x][0]\r\n\t\t\twhile self.children[curr][1] is not None:\r\n\t\t\t\tcurr = self.children[curr][1]\r\n\t\t\treturn  curr\r\n\t\telse:\r\n\t\t\tcurr = self.root\r\n\t\t\tprev = None\r\n\t\t\twhile True:\r\n\t\t\t\tif x > curr:\r\n\t\t\t\t\tif self.children[curr][1] is None:\r\n\t\t\t\t\t\tself.splay(curr)\r\n\t\t\t\t\t\treturn curr\r\n\t\t\t\t\telse:\r\n\t\t\t\t\t\tprev = curr\r\n\t\t\t\t\t\tcurr = self.children[curr][1]\r\n\t\t\t\telse:\r\n\t\t\t\t\tif self.children[curr][0] is None:\r\n\t\t\t\t\t\tif prev is not None:\r\n\t\t\t\t\t\t\tself.splay(prev)\r\n\t\t\t\t\t\treturn prev\r\n\t\t\t\t\telse:\r\n\t\t\t\t\t\tcurr = self.children[curr][0]\r\n\r\n\tdef splay(self, x):\r\n\t\twhile self.parents[x] is not None:\r\n\t\t\tp = self.parents[x]\r\n\t\t\tgp = self.parents[p]\r\n\t\t\tif gp is None:\r\n\t\t\t\tif p > x:\r\n\t\t\t\t\ta,b = self.children[x]\r\n\t\t\t\t\tc = self.children[p][1]\r\n\t\t\t\t\tself.children[x] = [a,p]\r\n\t\t\t\t\tself.children[p] = [b,c]\r\n\t\t\t\t\tself.parents[x] = None\r\n\t\t\t\t\tself.parents[p] = x\r\n\t\t\t\t\tself.parents[b] = p\r\n\t\t\t\t\tself.root = x\r\n\t\t\t\telse:\r\n\t\t\t\t\ta = self.children[p][0]\r\n\t\t\t\t\tb,c = self.children[x]\r\n\t\t\t\t\tself.children[x] = [p,c]\r\n\t\t\t\t\tself.children[p] = [a,b]\r\n\t\t\t\t\tself.parents[x] = None\r\n\t\t\t\t\tself.parents[p] = x\r\n\t\t\t\t\tself.parents[b] = p\r\n\t\t\t\t\tself.root = x\r\n\t\t\telse:\r\n\t\t\t\tggp = self.parents[gp]\r\n\t\t\t\tif p > x and gp > x:\r\n\t\t\t\t\ta,b = self.children[x]\r\n\t\t\t\t\tc = self.children[p][1]\r\n\t\t\t\t\td = self.children[gp][1]\r\n\t\t\t\t\tself.children[x] = [a,p]\r\n\t\t\t\t\tself.children[p] = [b,gp]\r\n\t\t\t\t\tself.children[gp] = [c,d]\r\n\t\t\t\t\tself.parents[x] = ggp\r\n\t\t\t\t\tself.parents[p] = x\r\n\t\t\t\t\tself.parents[gp] = p\r\n\t\t\t\t\tself.parents[b] = p\r\n\t\t\t\t\tself.parents[c] = gp\r\n\t\t\t\telif p < x and gp < x:\r\n\t\t\t\t\tc,d = self.children[x]\r\n\t\t\t\t\tb = self.children[p][0]\r\n\t\t\t\t\ta = self.children[gp][0]\r\n\t\t\t\t\tself.children[x] = [p,d]\r\n\t\t\t\t\tself.children[p] = [gp,c]\r\n\t\t\t\t\tself.children[gp] = [a,b]\r\n\t\t\t\t\tself.parents[x] = ggp\r\n\t\t\t\t\tself.parents[p] = x\r\n\t\t\t\t\tself.parents[gp] = p\r\n\t\t\t\t\tself.parents[b] = gp\r\n\t\t\t\t\tself.parents[c] = p\r\n\t\t\t\telif p < x and gp > x:\r\n\t\t\t\t\tb,c = self.children[x]\r\n\t\t\t\t\ta = self.children[p][0]\r\n\t\t\t\t\td = self.children[gp][1]\r\n\t\t\t\t\tself.children[x] = [p,gp]\r\n\t\t\t\t\tself.children[p] = [a,b]\r\n\t\t\t\t\tself.children[gp] = [c,d]\r\n\t\t\t\t\tself.parents[x] = ggp\r\n\t\t\t\t\tself.parents[p] = x\r\n\t\t\t\t\tself.parents[gp] = x\r\n\t\t\t\t\tself.parents[b] = p\r\n\t\t\t\t\tself.parents[c] = gp\r\n\t\t\t\telse:\r\n\t\t\t\t\tb,c = self.children[x]\r\n\t\t\t\t\td = self.children[p][1]\r\n\t\t\t\t\ta = self.children[gp][0]\r\n\t\t\t\t\tself.children[x] = [gp,p]\r\n\t\t\t\t\tself.children[p] = [c,d]\r\n\t\t\t\t\tself.children[gp] = [a,b]\r\n\t\t\t\t\tself.parents[x] = ggp\r\n\t\t\t\t\tself.parents[p] = x\r\n\t\t\t\t\tself.parents[gp] = x\r\n\t\t\t\t\tself.parents[b] = gp\r\n\t\t\t\t\tself.parents[c] = p\r\n\t\t\t\tif ggp is not None:\r\n\t\t\t\t\tfor i in range(2):\r\n\t\t\t\t\t\tif self.children[ggp][i] == gp:\r\n\t\t\t\t\t\t\tself.children[ggp][i] = x\r\n\t\t\t\telse:\r\n\t\t\t\t\tself.root = x\r\n\t\t\tif None in self.parents:\r\n\t\t\t\tdel self.parents[None]\r\n\r\n\r\nn,m,q = map(int,input().split())\r\ndiag = {}\r\nfor i in range(-m,n+1):\r\n\tdiag[i] = SplayTree()\r\n\tdiag[i].insert(max(0,i))\r\n\tdiag[i].insert(min(n+1,m+1+i))\r\n\r\ntotal = 0\r\nj = n\r\nk = m\r\nwhile j>0 and k>0:\r\n\ttotal += 2*j*k\r\n\ttotal += j*(k-1)\r\n\ttotal += k*(j-1)\r\n\tj-=1\r\n\tk-=1\r\ntotal -= n*m\r\nfor _ in range(q):\r\n\tx, y = map(int, input().split())\r\n\tdiff = x-y\r\n\tpred = diag[diff].predecessor(x)\r\n\tsucc = diag[diff].successor(x)\r\n\tpredup = diag[diff-1].predecessor(x)\r\n\tsuccup = diag[diff-1].successor(x-1)\r\n\tpreddown = diag[diff+1].predecessor(x+1)\r\n\tsuccdown = diag[diff+1].successor(x)\r\n\tbeforeup = min(2*(x-pred)-1,2*(x-predup)-2)\r\n\tafterup = min(2*(succ-x)-1,2*(succup-x))\r\n\tbeforedown = min(2*(x-pred)-1,2*(x-preddown))\r\n\tafterdown = min(2*(succ-x)-1,2*(succdown-x)-2)\r\n\tchange = (beforeup+1)*(afterup+1) + (beforedown+1)*(afterdown+1) - 1\r\n\tif diag[diff].find(x):\r\n\t\ttotal += change\r\n\t\tdiag[diff].delete(x)\r\n\telse:\r\n\t\ttotal -= change\r\n\t\tdiag[diff].insert(x)\r\n\tprint(total)","tags":["math"],"src_uid":"c72b1a45f5cf80a31c239cf1409c0104"}
{"text_full":"[DESCRIPTION]You are given two arrays $$$a$$$ and $$$b$$$, both of length $$$n$$$.You can perform the following operation any number of times (possibly zero): select an index $$$i$$$ ($$$1 \\leq i \\leq n$$$) and swap $$$a_i$$$ and $$$b_i$$$.Let's define the cost of the array $$$a$$$ as $$$\\sum_{i=1}^{n} \\sum_{j=i + 1}^{n} (a_i + a_j)^2$$$. Similarly, the cost of the array $$$b$$$ is $$$\\sum_{i=1}^{n} \\sum_{j=i + 1}^{n} (b_i + b_j)^2$$$.Your task is to minimize the total cost of two arrays.[SOURCE CODE]# import sys, os\r\n# if not os.environ.get(\"ONLINE_JUDGE\"):\r\n#     sys.stdin = open('in.txt', 'r')\r\n#     sys.stdout = open('out.txt', 'w')\r\n    \r\nimport sys\r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\n\r\nfor _ in range(int(input())):\r\n    n = int(input())\r\n    a = list(map(int, input().split()))\r\n    b = list(map(int, input().split()))\r\n    if n == 1:\r\n        print(0)\r\n    else:\r\n        cost = 0\r\n        s = 0\r\n        for i in range(n):\r\n            cost += a[i]**2 + b[i]**2\r\n            s += a[i] + b[i]\r\n        wt = [abs(a[i]-b[i]) for i in range(n)]\r\n        capacity = sum(wt)\r\n        dp = [[False for i in range(capacity + 1)] for i in range(n+1)]\r\n        dp[0][0] = True\r\n\r\n        for i in range(n+1):\r\n            for j in range(capacity + 1):\r\n                if j == 0:\r\n                    dp[i][j] = True\r\n                else:\r\n                    if dp[i-1][j] or dp[i-1][j-wt[i-1]]:\r\n                        dp[i][j] = True\r\n        \r\n        pos = []\r\n        min_j = 0\r\n        for i in range(n):\r\n            min_j += min(a[i], b[i])\r\n        for j in range(capacity + 1):\r\n            if dp[n][j]:\r\n                s1 = j + min_j\r\n                pos.append(s1**2 + (s - s1)**2)\r\n        \r\n        print(min(pos) + (n-2)*cost)","tags":["math"],"src_uid":"b57066317ae2f2280d7351ff12e0c959"}
{"text_full":"[DESCRIPTION]The enchanted forest got its name from the magical mushrooms growing here. They may cause illusions and generally should not be approached.—Perfect Memento in Strict SenseMarisa comes to pick mushrooms in the Enchanted Forest. The Enchanted forest can be represented by $$$n$$$ points on the $$$X$$$-axis numbered $$$1$$$ through $$$n$$$. Before Marisa started, her friend, Patchouli, used magic to detect the initial number of mushroom on each point, represented by $$$a_1,a_2,\\ldots,a_n$$$.Marisa can start out at any point in the forest on minute $$$0$$$. Each minute, the followings happen in order:  She moves from point $$$x$$$ to $$$y$$$ ($$$|x-y|\\le 1$$$, possibly $$$y=x$$$).  She collects all mushrooms on point $$$y$$$.  A new mushroom appears on each point in the forest. Note that she cannot collect mushrooms on minute $$$0$$$.Now, Marisa wants to know the maximum number of mushrooms she can pick after $$$k$$$ minutes.[SOURCE CODE]import sys,math\r\ninput=sys.stdin.readline\r\n\r\nfor _ in range(int(input())):\r\n    #n=int(input())\r\n    n,k=map(int,input().split())\r\n    l=list(map(int,input().split()))\r\n    if n==1:\r\n        print(l[0]+(k-1))\r\n    elif k>=n:\r\n        ans=sum(l)+((n*(n-1))\/\/2)+n*(k-n)\r\n        \r\n        print(ans)\r\n    else:\r\n        s=0\r\n        for i in range(k):\r\n            s=s+l[i]\r\n        x=s\r\n        for i in range(k,n):\r\n            x=x-l[i-k]+l[i]\r\n            s=max(s,x)\r\n        print(s+((k*(k-1))\/\/2))","tags":["math"],"src_uid":"e092d58ac58e1e41d17be946128234e5"}
{"text_full":"[DESCRIPTION]Finally, you have defeated Razor and now, you are the Most Wanted street racer. Sergeant Cross has sent the full police force after you in a deadly pursuit. Fortunately, you have found a hiding spot but you fear that Cross and his force will eventually find you. To increase your chances of survival, you want to tune and repaint your BMW M3 GTR.The car can be imagined as a permuted $$$n$$$-dimensional hypercube. A simple $$$n$$$-dimensional hypercube is an undirected unweighted graph built recursively as follows:   Take two simple $$$(n-1)$$$-dimensional hypercubes one having vertices numbered from $$$0$$$ to $$$2^{n-1}-1$$$ and the other having vertices numbered from $$$2^{n-1}$$$ to $$$2^{n}-1$$$. A simple $$$0$$$-dimensional Hypercube is just a single vertex.  Add an edge between the vertices $$$i$$$ and $$$i+2^{n-1}$$$ for each $$$0\\leq i &lt; 2^{n-1}$$$. A permuted $$$n$$$-dimensional hypercube is formed by permuting the vertex numbers of a simple $$$n$$$-dimensional hypercube in any arbitrary manner.Examples of a simple and permuted $$$3$$$-dimensional hypercubes are given below:  Note that a permuted $$$n$$$-dimensional hypercube has the following properties:   There are exactly $$$2^n$$$ vertices.  There are exactly $$$n\\cdot 2^{n-1}$$$ edges.  Each vertex is connected to exactly $$$n$$$ other vertices.  There are no self-loops or duplicate edges. Let's denote the permutation used to generate the permuted $$$n$$$-dimensional hypercube, representing your car, from a simple $$$n$$$-dimensional hypercube by $$$P$$$. Before messing up the functionalities of the car, you want to find this permutation so that you can restore the car if anything goes wrong. But the job isn't done yet.You have $$$n$$$ different colours numbered from $$$0$$$ to $$$n-1$$$. You want to colour the vertices of this permuted $$$n$$$-dimensional hypercube in such a way that for each and every vertex $$$u$$$ satisfying $$$0\\leq u &lt; 2^n$$$ and for each and every colour $$$c$$$ satisfying $$$0\\leq c &lt; n$$$, there is at least one vertex $$$v$$$ adjacent to $$$u$$$ having a colour $$$c$$$. In other words, from each and every vertex, it must be possible to reach a vertex of any colour by just moving to an adjacent vertex. Given the permuted $$$n$$$-dimensional hypercube, find any valid permutation $$$P$$$ and colouring.[SOURCE CODE]from collections import deque\r\nfrom sys import stdin\r\nimport sys\r\n \r\ntt = int(stdin.readline())\r\n \r\nfor loop in range(tt):\r\n \r\n    n = int(stdin.readline())\r\n \r\n    lis = [ [] for i in range(2**n)]\r\n \r\n    for i in range(n*(2**(n-1))):\r\n \r\n        u,v = map(int,stdin.readline().split())\r\n        lis[u].append(v)\r\n        lis[v].append(u)\r\n \r\n    rp = [0] * (2**n)\r\n    d = [float(\"inf\")] * (2**n)\r\n \r\n    d[0] = 0\r\n \r\n    q = deque()\r\n    for i in range(n):\r\n        nexv = lis[0][i]\r\n        rp[nexv] = 2**i\r\n        d[nexv] = 1\r\n        q.append(nexv)\r\n \r\n    while q:\r\n        v = q.popleft()\r\n        for nexv in lis[v]:\r\n \r\n            if d[nexv] == float(\"inf\"):\r\n                d[nexv] = d[v] + 1\r\n                q.append(nexv)\r\n \r\n            if d[nexv] > d[v]:\r\n                rp[nexv] |= rp[v]\r\n \r\n    p = [None] * (2**n)\r\n    for i in range(2**n):\r\n        p[rp[i]] = i\r\n \r\n    print (*p)\r\n \r\n    if (2**n) % n == 0:\r\n \r\n        c = [None] * (2**n)\r\n        \r\n        for i in range(2**n):\r\n \r\n            now = 0\r\n            for j in range(n):\r\n                if 2**j & i > 0:\r\n                    now ^= j\r\n            c[p[i]] = now\r\n \r\n        print (*c)\r\n \r\n    else:\r\n        print (-1)","tags":["graphs","math"],"src_uid":"4c9c50f9ebe06a3e86c20aee2a0ee797"}
{"text_full":"[DESCRIPTION]Highway 201 is the most busy street in Rockport. Traffic cars cause a lot of hindrances to races, especially when there are a lot of them. The track which passes through this highway can be divided into $$$n$$$ sub-tracks. You are given an array $$$a$$$ where $$$a_i$$$ represents the number of traffic cars in the $$$i$$$-th sub-track. You define the inconvenience of the track as $$$\\sum\\limits_{i=1}^{n} \\sum\\limits_{j=i+1}^{n} \\lvert a_i-a_j\\rvert$$$, where $$$|x|$$$ is the absolute value of $$$x$$$. You can perform the following operation any (possibly zero) number of times: choose a traffic car and move it from its current sub-track to any other sub-track.Find the minimum inconvenience you can achieve.[SOURCE CODE]import sys\r\n\r\ninput = lambda: sys.stdin.buffer.readline().decode().strip()\r\nprint = sys.stdout.write\r\n\r\nfor _ in range(int(input())):\r\n    n = int(input())\r\n    nums = list(map(int, input().split()))\r\n    total = sum(nums)\r\n    reminder = total % n\r\n    print(str((n - reminder) * reminder) + \"\\n\")","tags":["math"],"src_uid":"935bceb69117d06eb75121c805bff69c"}
{"text_full":"[DESCRIPTION]This is the hard version of the problem. The only difference is that here $$$2\\leq k\\leq 100$$$. You can make hacks only if both the versions of the problem are solved.This is an interactive problem!Every decimal number has a base $$$k$$$ equivalent. The individual digits of a base $$$k$$$ number are called $$$k$$$-its. Let's define the $$$k$$$-itwise XOR of two $$$k$$$-its $$$a$$$ and $$$b$$$ as $$$(a + b)\\bmod k$$$.The $$$k$$$-itwise XOR of two base $$$k$$$ numbers is equal to the new number formed by taking the $$$k$$$-itwise XOR of their corresponding $$$k$$$-its. The $$$k$$$-itwise XOR of two decimal numbers $$$a$$$ and $$$b$$$ is denoted by $$$a\\oplus_{k} b$$$ and is equal to the decimal representation of the $$$k$$$-itwise XOR of the base $$$k$$$ representations of $$$a$$$ and $$$b$$$. All further numbers used in the statement below are in decimal unless specified.You have hacked the criminal database of Rockport Police Department (RPD), also known as the Rap Sheet. But in order to access it, you require a password. You don't know it, but you are quite sure that it lies between $$$0$$$ and $$$n-1$$$ inclusive. So, you have decided to guess it. Luckily, you can try at most $$$n$$$ times without being blocked by the system. But the system is adaptive. Each time you make an incorrect guess, it changes the password. Specifically, if the password before the guess was $$$x$$$, and you guess a different number $$$y$$$, then the system changes the password to a number $$$z$$$ such that $$$x\\oplus_{k} z=y$$$. Guess the password and break into the system.[SOURCE CODE]from __future__ import division, print_function\r\n\r\nimport os,sys\r\nfrom io import BytesIO, IOBase\r\n\r\nif sys.version_info[0] < 3:\r\n    from __builtin__ import xrange as range\r\n    from future_builtins import ascii, filter, hex, map, oct, zip\r\n\r\nfrom bisect import bisect_left as lower_bound, bisect_right as upper_bound \r\ndef so():  return int(input())\r\ndef st():  return input()\r\ndef mj():  return map(int, input().split())\r\ndef msj(): return map(str,input().strip().split(\" \"))\r\ndef le():  return list(map(int,input().split()))\r\ndef rc():  return map(float,input().split())\r\ndef lebe():return list(map(int, input()))\r\n\r\ndef dmain():\r\n    sys.setrecursionlimit(1000000)\r\n    threading.stack_size(1024000)\r\n    thread = threading.Thread(target=main)\r\n    thread.start()\r\ndef joro(L):\r\n    return(''.join(map(str, L)))\r\n\r\n\r\ndef decimalToBinary(n): return bin(n).replace(\"0b\",\"\")\r\n\r\n\r\ndef isprime(n):\r\n    for i in range(2,int(n**0.5)+1):\r\n        if n%i==0:\r\n            return False\r\n    return True\r\ndef npr(n, r):\r\n    return factorial(n) \/\/ factorial(n - r) if n >= r else 0\r\n \r\n \r\ndef ncr(n, r):\r\n    return factorial(n) \/\/ (factorial(r) * factorial(n - r)) if n >= r else 0\r\n \r\n \r\ndef lower_bound(li, num):\r\n    answer = -1\r\n    start = 0\r\n    end = len(li) - 1\r\n \r\n    while (start <= end):\r\n        middle = (end + start) \/\/ 2\r\n        if li[middle] >= num:\r\n            answer = middle\r\n            end = middle - 1\r\n        else:\r\n            start = middle + 1\r\n    return answer  # min index where x is not less than num\r\n \r\n \r\ndef upper_bound(li, num):\r\n    answer = -1\r\n    start = 0\r\n    end = len(li) - 1\r\n \r\n    while (start <= end):\r\n        middle = (end + start) \/\/ 2\r\n \r\n        if li[middle] <= num:\r\n            answer = middle\r\n            start = middle + 1\r\n \r\n        else:\r\n            end = middle - 1\r\n    return answer  # max index where x is not greater than num\r\ndef tir(a,b,c):\r\n    if(0==c):\r\n        return 1\r\n    if(len(a)<=b):\r\n        return 0\r\n    \r\n    if(c!=-1):\r\n        return (tir(a,1+b,c+a[b]) or tir(a,b+1,c-a[b]) or tir(a,1+b,c)) \r\n        \r\n        \r\n    else:\r\n        return (tir(a,1+b,a[b]) or tir(a,b+1,-a[b]) or tir(a,1+b,-1))\r\nhoi=int(2**20)        \r\n \r\ndef abs(x):\r\n    return x if x >= 0 else -x\r\n \r\n \r\ndef binary_search(li, val, lb, ub):\r\n    # print(lb, ub, li)\r\n    ans = -1\r\n    while (lb <= ub):\r\n        mid = (lb + ub) \/\/ 2\r\n        # print('mid is',mid, li[mid])\r\n        if li[mid] > val:\r\n            ub = mid - 1\r\n        elif val > li[mid]:\r\n            lb = mid + 1\r\n        else:\r\n            ans = mid  # return index\r\n            break\r\n    return ans\r\n \r\n \r\ndef kadane(x):  # maximum sum contiguous subarray\r\n    sum_so_far = 0\r\n    current_sum = 0\r\n    for i in x:\r\n        current_sum += i\r\n        if current_sum < 0:\r\n            current_sum = 0\r\n        else:\r\n            sum_so_far = max(sum_so_far, current_sum)\r\n    return sum_so_far\r\n \r\n \r\ndef pref(li):\r\n    pref_sum = [0]\r\n    for i in li:\r\n        pref_sum.append(pref_sum[-1] + i)\r\n    return pref_sum\r\n \r\n \r\ndef SieveOfEratosthenes(n):\r\n    prime = [True for i in range(n + 1)]\r\n    p = 2\r\n    li = []\r\n    while (p * p <= n):\r\n        if (prime[p] == True):\r\n            for i in range(p * p, n + 1, p):\r\n                prime[i] = False\r\n        p += 1\r\n \r\n    for p in range(2, len(prime)):\r\n        if prime[p]:\r\n            li.append(p)\r\n    return li\r\n \r\n \r\ndef primefactors(n):\r\n    factors = []\r\n    while (n % 2 == 0):\r\n        factors.append(2)\r\n        n \/\/= 2\r\n    for i in range(3, int(sqrt(n)) + 1, 2):  # only odd factors left\r\n        while n % i == 0:\r\n            factors.append(i)\r\n            n \/\/= i\r\n    if n > 2:  # incase of prime\r\n        factors.append(n)\r\n    return factors\r\n\r\ndef read():\r\n    sys.stdin  = open('input.txt', 'r')  \r\n    sys.stdout = open('output.txt', 'w') \r\ndef tr(n):\r\n    return n*(n+1)\/\/2\r\ndef hu(a,b,opp):\r\n    d=1\r\n    c=0\r\n    while(0<b or 0<a):\r\n        c=c+(((b%opp)+(a%opp))%opp)*d\r\n        a=a\/\/opp\r\n        b=b\/\/opp\r\n        d=opp*d\r\n    return c\r\ndef rw(u,opp):\r\n    c=0\r\n    d=1\r\n    while(0<u):\r\n        c=c+((-u%opp)%opp)*d\r\n        u=u\/\/opp\r\n        d=opp*d\r\n    return c\r\nsoi=int(1e9)\r\nboi=int(1e9-7)\r\ndoi=int(1e9+7)\r\n\r\n\r\ndef main():\r\n    import sys\r\n    import math as my\r\n    input=sys.stdin.readline\r\n    y=\"Yes\"\r\n    n=\"No\"\r\n    for i in range(so()):\r\n        #c=0\r\n        op,opp=mj()\r\n        c=0\r\n        for i in range(op):\r\n            if(not i%2):\r\n                z=i\r\n                \r\n            else:\r\n                \r\n                z=rw(i,opp)\r\n            uo=hu(z,c,opp)\r\n            print(uo)\r\n            sys.stdout.flush()\r\n            oppp=so()\r\n            if(1==oppp):\r\n                break\r\n            if(-1==oppp):\r\n                return\r\n            c=hu(rw(c,opp),uo,opp)\r\n    \r\n\r\n    \r\n            \r\n            \r\n            \r\n                \r\n            \r\n        \r\n    \r\n    \r\n    \r\n        \r\n    \r\n    \r\n    \r\n    \r\n    \r\n        \r\n        \r\n                        \r\n            \r\n    \r\n        \r\n    \r\n            \r\n    \r\n            \r\n        \r\n    \r\n\r\n            \r\n        \r\n    \r\n    \r\n    \r\n\r\n    \r\n    \r\n    \r\n    \r\n        \r\n\r\n        \r\n    \r\n\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n\r\n    \r\n\r\n    \r\n        \r\n        \r\n            \r\n    \r\n    \r\n                \r\n            \r\n                \r\n                \r\n                \r\n                \r\n            \r\n    \r\n            \r\n            \r\n    \r\n    \r\n    \r\n    \r\n        \r\n            \r\n    \r\n           \r\n            \r\n            \r\n        \r\n    \r\n        \r\n    \r\n    \r\n        \r\n        \r\n        \r\n\r\n            \r\n                    \r\n                \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n                    \r\n        \r\n                \r\n        \r\n        \r\n       \r\n    \r\n           \r\n          \r\n          \r\n                \r\n            \r\n        \r\n                \r\n    \r\n        \r\n        \r\n        \r\n       \r\n            \r\n                \r\n        \r\n\r\n\r\n\r\n\r\n# region fastio\r\n# template taken from https:\/\/github.com\/cheran-senthil\/PyRival\/blob\/master\/templates\/template.py\r\n\r\nBUFSIZE = 8192\r\n\r\n\r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n\r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n\r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n\r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n\r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\n\r\n\r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\n\r\n\r\ndef print(*args, **kwargs):\r\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\r\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\r\n    at_start = True\r\n    for x in args:\r\n        if not at_start:\r\n            file.write(sep)\r\n        file.write(str(x))\r\n        at_start = False\r\n    file.write(kwargs.pop(\"end\", \"\\n\"))\r\n    if kwargs.pop(\"flush\", False):\r\n        file.flush()\r\n\r\n\r\nif sys.version_info[0] < 3:\r\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\r\nelse:\r\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\n\r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\n\r\n# endregion\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    #read()\r\n    main()\r\n    #dmain()\r\n\r\n# Comment Read()","tags":["math"],"src_uid":"7a9b559eb3b601590e22eb128f2bf307"}
{"text_full":"[DESCRIPTION]This is an interactive problem.Note: the XOR-sum of an array $$$a_1, a_2, \\ldots, a_n$$$ ($$$1 \\le a_i \\le 10^9$$$) is defined as $$$a_1 \\oplus a_2 \\oplus \\ldots \\oplus a_n$$$, where $$$\\oplus$$$ denotes the bitwise XOR operation.Little Dormi received an array of $$$n$$$ integers $$$a_1, a_2, \\ldots, a_n$$$ for Christmas. However, while playing with it over the winter break, he accidentally dropped it into his XOR machine, and the array got lost.The XOR machine is currently configured with a query size of $$$k$$$ (which you cannot change), and allows you to perform the following type of query: by giving the machine $$$k$$$ distinct indices $$$x_1, x_2, \\ldots, x_k$$$, it will output $$$a_{x_1} \\oplus a_{x_2} \\oplus \\ldots \\oplus a_{x_k}$$$.As Little Dormi's older brother, you would like to help him recover the XOR-sum of his array $$$a_1, a_2, \\ldots, a_n$$$ by querying the XOR machine.Little Dormi isn't very patient, so to be as fast as possible, you must query the XOR machine the minimum number of times to find the XOR-sum of his array. Formally, let $$$d$$$ be the minimum number of queries needed to find the XOR-sum of any array of length $$$n$$$ with a query size of $$$k$$$. Your program will be accepted if you find the correct XOR-sum in at most $$$d$$$ queries.Lastly, you also noticed that with certain configurations of the machine $$$k$$$ and values of $$$n$$$, it may not be possible to recover the XOR-sum of Little Dormi's lost array. If that is the case, you should report it as well.The array $$$a_1, a_2, \\ldots, a_n$$$ is fixed before you start querying the XOR machine and does not change with the queries.[SOURCE CODE]from collections import deque\n\nn, k = map(int,input().split())\nif k%2==0 and n%2==1:\n    print(-1)\n    exit()\n\n\n\nqueue = deque()\nvisited = [ False for i in range(n)]\npre = [-1]*n\n\n\ndef getarr(add,front,rear,k,n):\n\n    nextrear = rear + (add + k)\/\/2\n    nextfront = front + (k - add)\/\/2\n    arr = [(i-1)%n + 1 for i in range(front,nextfront)] + [(i-1)%n + 1 for i in range(rear+1,nextrear+1)]\n    return [nextfront,nextrear,arr]\n\n    \n    \n    \n    \n        \n\n\n\n\n\n\nvisited[k-1] = True\nqueue.append(k-1)\n\nwhile queue:\n#    print(queue)\n    d = queue.popleft()\n\n    for diff in range(k,-k-1,-2):\n        front = (k + diff)\/\/2\n        rear = (k-diff)\/\/2\n        if d + front >= n:  continue \n        if rear > d + 1: continue \n        if d + diff < 0 or d + diff >=n: continue \n        if visited[d+diff]: continue \n \n\n        queue.append(diff+d)\n        visited[diff+d] = True\n        pre[diff+d] = d\n        \n        \n\n\n\nstack = []\nindex = n -1\nwhile True:\n    stack.append(index)\n    if pre[index]==-1: break\n    else:  index = pre[index]\nstack.append(-1)\nstack = stack[::-1]\n\n\n#print(stack)\nfront,rear = 1,0\n    \nans = 0     \nfor i in range(len(stack)-1):\n    [front,rear,arr] = getarr(stack[i+1]-stack[i],front,rear,k,n)\n#    print(front,rear)\n    print(\"? \"+\" \".join(map(str,arr))  )\n    temp = int(input())\n    ans = ans ^ temp\n\nprint(\"! \"+str(ans))","tags":["graphs"],"src_uid":"5de2777a63c0c889da36c32df91744cf"}
{"text_full":"[DESCRIPTION]You are given two arrays of integers $$$a_1, a_2, \\ldots, a_n$$$ and $$$b_1, b_2, \\ldots, b_n$$$.Let's define a transformation of the array $$$a$$$:  Choose any non-negative integer $$$k$$$ such that $$$0 \\le k \\le n$$$.  Choose $$$k$$$ distinct array indices $$$1 \\le i_1 &lt; i_2 &lt; \\ldots &lt; i_k \\le n$$$.  Add $$$1$$$ to each of $$$a_{i_1}, a_{i_2}, \\ldots, a_{i_k}$$$, all other elements of array $$$a$$$ remain unchanged.  Permute the elements of array $$$a$$$ in any order. Is it possible to perform some transformation of the array $$$a$$$ exactly once, so that the resulting array is equal to $$$b$$$?[SOURCE CODE]import sys\r\n\r\nt = int(sys.stdin.readline())\r\nfor _ in range(t):\r\n    n = int(sys.stdin.readline())\r\n    a = list(map(int, sys.stdin.readline().split()))\r\n    b = list(map(int, sys.stdin.readline().split()))\r\n    newa = sorted(a)\r\n    newb = sorted(b)\r\n\r\n    ans = \"YES\"\r\n    for i in range(n):\r\n        if (newa[i] != newb[i]) and (newa[i] + 1 != newb[i]):\r\n            ans = \"NO\"\r\n\r\n    print(ans)","tags":["math"],"src_uid":"6ca98e655007bfb86f1039c9f096557e"}
{"text_full":"[DESCRIPTION]$$$n$$$ people live on the coordinate line, the $$$i$$$-th one lives at the point $$$x_i$$$ ($$$1 \\le i \\le n$$$). They want to choose a position $$$x_0$$$ to meet. The $$$i$$$-th person will spend $$$|x_i - x_0|$$$ minutes to get to the meeting place. Also, the $$$i$$$-th person needs $$$t_i$$$ minutes to get dressed, so in total he or she needs $$$t_i + |x_i - x_0|$$$ minutes. Here $$$|y|$$$ denotes the absolute value of $$$y$$$.These people ask you to find a position $$$x_0$$$ that minimizes the time in which all $$$n$$$ people can gather at the meeting place.[SOURCE CODE]import math\r\ndef balanced(m,l):\r\n    \r\n    leftMax = float(\"-inf\")\r\n    rightMax = float(\"-inf\")\r\n\r\n\r\n    for i in l:\r\n        if i>m:\r\n            rightMax = max(max(l[i]) + i-m,rightMax)\r\n        elif i<m:\r\n            leftMax = max(max(l[i]) + m-i,leftMax)\r\n\r\n    return rightMax-leftMax\r\n\r\n\r\nfor k in range(int(input())):\r\n    \r\n\r\n    n = int(input())\r\n    \r\n\r\n\r\n    x = list(map(int,input().split()))\r\n    t = list(map(int,input().split()))\r\n\r\n\r\n    l = {}\r\n    for i in range(n):\r\n        l[x[i]] = []\r\n    for i in range(n):\r\n        l[x[i]].append(t[i])\r\n\r\n    qleft = min(x)\r\n    qright = max(x)\r\n\r\n    prev_mid = -1\r\n\r\n    while qleft<=qright:\r\n        \r\n        \r\n        m = qleft + (qright-qleft)\/2\r\n\r\n        if prev_mid != -1 and math.fabs(m-prev_mid)<0.0005:\r\n            print(\"%.2f\"%m)\r\n            break\r\n        \r\n        if balanced(qleft,l)==0:\r\n            print(qleft)\r\n            break\r\n        if balanced(qright,l)==0:\r\n            print(qright)\r\n            break\r\n\r\n        b = balanced(m,l)\r\n        if b==0:\r\n            print(\"%.2f\"%m)\r\n            break\r\n        if b<0:\r\n            qright = m\r\n            prev_mid = m\r\n            \r\n        else:\r\n            qleft = m\r\n            prev_mid = m","tags":["geometry","math"],"src_uid":"9336bfed41e9b277bdfa157467066078"}
{"text_full":"[DESCRIPTION]You have a string $$$s$$$ consisting of digits from $$$0$$$ to $$$9$$$ inclusive. You can perform the following operation any (possibly zero) number of times:   You can choose a position $$$i$$$ and delete a digit $$$d$$$ on the $$$i$$$-th position. Then insert the digit $$$\\min{(d + 1, 9)}$$$ on any position (at the beginning, at the end or in between any two adjacent digits). What is the lexicographically smallest string you can get by performing these operations?A string $$$a$$$ is lexicographically smaller than a string $$$b$$$ of the same length if and only if the following holds:   in the first position where $$$a$$$ and $$$b$$$ differ, the string $$$a$$$ has a smaller digit than the corresponding digit in $$$b$$$.[SOURCE CODE]for _ in range(int(input())):\r\n    S = (input())\r\n    m = S[-1]\r\n    ans = []\r\n    for i in reversed(S):\r\n        m = min(i, m)\r\n        if i == m:\r\n            ans.append(i)\r\n        else:\r\n            ans.append(str(min(int(i)+1, 9)))\r\n    print(''.join(sorted(ans)))","tags":["math"],"src_uid":"906b319e41f716e734cf04b34678aa58"}
{"text_full":"[DESCRIPTION]We say that a positive integer $$$n$$$ is $$$k$$$-good for some positive integer $$$k$$$ if $$$n$$$ can be expressed as a sum of $$$k$$$ positive integers which give $$$k$$$ distinct remainders when divided by $$$k$$$.Given a positive integer $$$n$$$, find some $$$k \\geq 2$$$ so that $$$n$$$ is $$$k$$$-good or tell that such a $$$k$$$ does not exist.[SOURCE CODE]import array\r\nimport bisect\r\nimport heapq\r\nimport json\r\nimport math\r\nimport collections\r\nimport sys\r\nimport copy\r\nfrom functools import reduce\r\nimport decimal\r\nfrom io import BytesIO, IOBase\r\nimport os\r\nimport itertools\r\nimport functools\r\nfrom types import GeneratorType\r\nimport fractions\r\nfrom typing import Tuple, List, Union\r\n\r\n# sys.setrecursionlimit(10 ** 9)\r\ndecimal.getcontext().rounding = decimal.ROUND_HALF_UP\r\n\r\ngraphDict = collections.defaultdict\r\n\r\nqueue = collections.deque\r\n\r\n\r\n################## pypy deep recursion handling ##############\r\n# Author = @pajenegod\r\ndef bootstrap(f, stack=[]):\r\n    def wrappedfunc(*args, **kwargs):\r\n        to = f(*args, **kwargs)\r\n        if stack:\r\n            return to\r\n        else:\r\n            while True:\r\n                if type(to) is GeneratorType:\r\n                    stack.append(to)\r\n                    to = next(to)\r\n                else:\r\n                    stack.pop()\r\n                    if not stack:\r\n                        return to\r\n                    to = stack[-1].send(to)\r\n\r\n    return wrappedfunc\r\n\r\n\r\n################## Graphs ###################\r\nclass Graphs:\r\n    def __init__(self):\r\n        self.graph = graphDict(list)\r\n\r\n    def add_edge(self, u, v, w, z):\r\n        self.graph[u].append([v, w, z])\r\n        self.graph[v].append([u, z, w])\r\n\r\n    def dfs_utility(self, nodes, visited_nodes, colors, parity, level):\r\n        global count\r\n        if nodes == 1:\r\n            colors[nodes] = -1\r\n        else:\r\n            if len(self.graph[nodes]) == 1 and parity % 2 == 0:\r\n                if q == 1:\r\n                    colors[nodes] = 1\r\n                else:\r\n                    colors[nodes] = -1\r\n                    count += 1\r\n            else:\r\n                if parity % 2 == 0:\r\n                    colors[nodes] = -1\r\n                else:\r\n                    colors[nodes] = 1\r\n        visited_nodes.add(nodes)\r\n        for neighbour in self.graph[nodes]:\r\n            new_level = level + 1\r\n            if neighbour not in visited_nodes:\r\n                self.dfs_utility(neighbour, visited_nodes, colors, level - 1, new_level)\r\n\r\n    def dfs(self, node):\r\n        Visited = set()\r\n        color = collections.defaultdict()\r\n        self.dfs_utility(node, Visited, color, 0, 0)\r\n        return color\r\n\r\n    def bfs(self, node, f_node):\r\n        count = float(\"inf\")\r\n        visited = set()\r\n        level = 0\r\n        if node not in visited:\r\n            queue.append([node, level])\r\n            visited.add(node)\r\n        flag = 0\r\n        while queue:\r\n            parent = queue.popleft()\r\n            if parent[0] == f_node:\r\n                flag = 1\r\n                count = min(count, parent[1])\r\n            level = parent[1] + 1\r\n            for item in self.graph[parent[0]]:\r\n                if item not in visited:\r\n                    queue.append([item, level])\r\n                    visited.add(item)\r\n        return count if flag else -1\r\n        return False\r\n\r\n\r\n################### Tree Implementaion ##############\r\nclass Tree:\r\n    def __init__(self, data):\r\n        self.data = data\r\n        self.left = None\r\n        self.right = None\r\n\r\n\r\ndef inorder(node, lis):\r\n    if node:\r\n        inorder(node.left, lis)\r\n        lis.append(node.data)\r\n        inorder(node.right, lis)\r\n    return lis\r\n\r\n\r\ndef leaf_node_sum(root):\r\n    if root is None:\r\n        return 0\r\n    if root.left is None and root.right is None:\r\n        return root.data\r\n    return leaf_node_sum(root.left) + leaf_node_sum(root.right)\r\n\r\n\r\ndef hight(root):\r\n    if root is None:\r\n        return -1\r\n    if root.left is None and root.right is None:\r\n        return 0\r\n    return max(hight(root.left), hight(root.right)) + 1\r\n\r\n\r\n################## Union Find #######################\r\nclass UnionFind():\r\n    parents = []\r\n    sizes = []\r\n    count = 0\r\n\r\n    def __init__(self, n):\r\n        self.count = n\r\n        self.parents = [i for i in range(n)]\r\n        self.sizes = [1 for i in range(n)]\r\n\r\n    def find(self, i):\r\n        if self.parents[i] == i:\r\n            return i\r\n        else:\r\n            self.parents[i] = self.find(self.parents[i])\r\n            return self.parents[i]\r\n\r\n    def unite(self, i, j):\r\n        root_i = self.find(i)\r\n        root_j = self.find(j)\r\n        if root_i == root_j:\r\n            return\r\n        elif root_i < root_j:\r\n            self.parents[root_j] = root_i\r\n            self.sizes[root_i] += self.sizes[root_j]\r\n        else:\r\n            self.parents[root_i] = root_j\r\n            self.sizes[root_j] += self.sizes[root_i]\r\n\r\n    def same(self, i, j):\r\n        return self.find(i) == self.find(j)\r\n\r\n    def size(self, i):\r\n        return self.sizes[self.find(i)]\r\n\r\n    def group_count(self):\r\n        return len(set(self.find(i) for i in range(self.count)))\r\n\r\n    def answer(self, extra, p, q):\r\n        dic = collections.Counter()\r\n        for q in range(n):\r\n            dic[self.find(q)] = self.size(q)\r\n        hq = list(dic.values())\r\n        heapq._heapify_max(hq)\r\n        ans = -1\r\n        for z in range(extra + 1):\r\n            if hq:\r\n                ans += heapq._heappop_max(hq)\r\n            else:\r\n                break\r\n        return ans\r\n\r\n\r\n#################################################\r\n\r\ndef rounding(n):\r\n    return int(decimal.Decimal(f'{n}').to_integral_value())\r\n\r\n\r\ndef factors(n):\r\n    return set(reduce(list.__add__,\r\n                      ([i, n \/\/ i] for i in range(1, int(n ** 0.5) + 1) if n % i == 0), [1]))\r\n\r\n\r\ndef p_sum(array):\r\n    return list(itertools.accumulate(array))\r\n\r\n\r\ndef base_change(nn, bb):\r\n    if nn == 0:\r\n        return [0]\r\n    digits = []\r\n    while nn:\r\n        digits.append(int(nn % bb))\r\n        nn \/\/= bb\r\n    return digits[::-1]\r\n\r\n\r\ndef diophantine(a: int, b: int, c: int):\r\n    d, x, y = extended_gcd(a, b)\r\n    r = c \/\/ d\r\n    return r * x, r * y\r\n\r\n\r\n@bootstrap\r\ndef extended_gcd(a: int, b: int):\r\n    if b == 0:\r\n        d, x, y = a, 1, 0\r\n    else:\r\n        (d, p, q) = yield extended_gcd(b, a % b)\r\n        x = q\r\n        y = p - q * (a \/\/ b)\r\n\r\n    yield d, x, y\r\n\r\n\r\n######################################################################################\r\n\r\n'''\r\nKnowledge and awareness are vague, and perhaps better called illusions.\r\nEveryone lives within their own subjective interpretation.\r\n                                                            ~Uchiha Itachi\r\n'''\r\n\r\n################################ <fast I\/O> ###########################################\r\nBUFSIZE = 8192\r\n\r\n\r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n\r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n\r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n\r\n    def readline(self, **kwargs):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n\r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\n\r\n\r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\n\r\n\r\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\n\r\n\r\n#############################################<I\/O Region >##############################################\r\n\r\n\r\ndef inp():\r\n    return sys.stdin.readline().strip()\r\n\r\n\r\ndef map_inp(v_type):\r\n    return map(v_type, inp().split())\r\n\r\n\r\ndef list_inp(v_type):\r\n    return list(map_inp(v_type))\r\n\r\n\r\ndef interactive():\r\n    return sys.stdout.flush()\r\n\r\n\r\n######################################## Solution ####################################\r\n\r\n\r\ndef primes_sieve1(limit):\r\n    limitn = limit + 1\r\n    primes = dict()\r\n    for i in range(2, limitn): primes[i] = True\r\n\r\n    for i in primes:\r\n        factors = range(i, limitn, i)\r\n        for f in factors[1:]:\r\n            primes[f] = False\r\n    return [i for i in primes if primes[i] == True]\r\n\r\n\r\ndef c_sum(x):\r\n    return (x * (x + 1)) \/\/ 2\r\ndef ans(a):\r\n    print(a)\r\n    return\r\n\r\nfor _ in range(int(inp())):\r\n    n = int(inp())\r\n    if n <= 2:\r\n        ans(-1)\r\n        continue\r\n    if n % 2:\r\n        ans(2)\r\n        continue\r\n    if n % 3 == 0:\r\n        ans(3)\r\n        continue\r\n    if n % 4 == 2:\r\n        ans(4)\r\n        continue\r\n    m = n\r\n    while m % 2 == 0:\r\n        m \/\/= 2\r\n    if m == 1:\r\n        ans(-1)\r\n        continue\r\n    for k in (m, n \/\/ m * 2):\r\n        a = n - k * (k + 1) \/\/ 2\r\n        if a >= 0 and a % k == 0:\r\n            ans(k)\r\n            break","tags":["math","number theory"],"src_uid":"8063c96cf62727f1b98e476e43679da2"}
{"text_full":"[DESCRIPTION]You are given a matrix $$$a$$$, consisting of $$$3$$$ rows and $$$n$$$ columns. Each cell of the matrix is either free or taken.A free cell $$$y$$$ is reachable from a free cell $$$x$$$ if at least one of these conditions hold:   $$$x$$$ and $$$y$$$ share a side;  there exists a free cell $$$z$$$ such that $$$z$$$ is reachable from $$$x$$$ and $$$y$$$ is reachable from $$$z$$$. A connected component is a set of free cells of the matrix such that all cells in it are reachable from one another, but adding any other free cell to the set violates this rule.You are asked $$$q$$$ queries about the matrix. Each query is the following:   $$$l$$$ $$$r$$$ — count the number of connected components of the matrix, consisting of columns from $$$l$$$ to $$$r$$$ of the matrix $$$a$$$, inclusive. Print the answers to all queries.[SOURCE CODE]import sys\r\n\r\ndef Column2Num( m, idx ):\r\n    return int(m[0][idx] != 0)  | (int(m[1][idx]) << 1) | (int(m[2][idx]) << 2)\r\n\r\ndef QColumn( m, bits, idx ):\r\n    if bits[idx] == 5:\r\n        if m[0][idx] == m[2][idx]:\r\n            return True\r\n    return False\r\n\r\ndef GetIntegratedCount( m ):\r\n    ret, curr = [ 0 ], set()\r\n    for c in range( len( m[0] ) ):\r\n        if m[0][c] != 0: curr.add( m[0][c] )\r\n        if m[1][c] != 0: curr.add( m[1][c] )\r\n        if m[2][c] != 0: curr.add( m[2][c] )\r\n        ret.append( len( curr ) )\r\n    ret.append( len( curr ) )\r\n    return ret\r\n\r\ndef Print( tm ):\r\n    print( '\\n', tm[0], '\\n', tm[1], '\\n', tm[2] )\r\n\r\ndef PrintIndexed( tm ):\r\n    for i in range( len( tm[0] ) ):\r\n        print(  i+1, ':', tm[0][i], tm[1][i], tm[2][i] )\r\n\r\ndef next( b, next ):\r\n\r\n    b &= next\r\n\r\n    if b == 0:\r\n        return b\r\n\r\n    if b & 1 or b & 4:\r\n        if next & 2:\r\n            b |= 2\r\n\r\n    if b & 2:\r\n        if next & 1:\r\n            b |= 1\r\n        if next & 4:\r\n            b |= 4\r\n\r\n    return b\r\n\r\ndef setCompNumber( b, m, i, compNumber ):\r\n    if b & 1:\r\n        m[0][i] = compNumber\r\n    if b & 2:\r\n        m[1][i] = compNumber\r\n    if b & 4:\r\n        m[2][i] = compNumber\r\n\r\n\r\ndef goLeft( start, compNumber, size, m, bits, fullColumn ):\r\n    b = bits[start]\r\n    fc = start\r\n\r\n    for i in range( start - 1, -1, -1 ):\r\n\r\n        b = next( b, bits[i] ) \r\n\r\n        if b == 7:\r\n            fc = i\r\n            break\r\n\r\n        if b == 0:\r\n            break\r\n\r\n        setCompNumber( b, m, i, compNumber )\r\n\r\n        if b == 5:\r\n            fullColumn[ i ] = fc\r\n\r\n\r\ndef goRight( start, compNumber, size, m, bits, fullColumn ):\r\n    \r\n    b = bits[start]\r\n\r\n    for i in range( start, size ):\r\n\r\n        b = next( b, bits[i] ) \r\n\r\n        if b == 7:\r\n            fc = i\r\n\r\n        if b == 0:\r\n            break\r\n\r\n        setCompNumber( b, m, i, compNumber )\r\n\r\n        if b == 5:\r\n            fullColumn[ i ] = fc\r\n\r\ndef goRight12( b, start, compNumber, size, m, bits ):\r\n    \r\n    for i in range( start, size ):\r\n\r\n        b = next( b, bits[i] ) \r\n        if b == 0:\r\n            break\r\n\r\n        setCompNumber( b, m, i, compNumber )\r\n\r\n\r\ndef get3Components( compNumber, size, m, bits, leftFullColumn, rightFullColumn ):\r\n    for i in range( size ):\r\n        if bits[i] == 7:\r\n            if m[ 0 ][ i  ] == 1:\r\n                compNumber += 1\r\n                goRight( i, compNumber, size, m, bits, leftFullColumn )\r\n            goLeft ( i, compNumber, size, m, bits, rightFullColumn )\r\n    return compNumber\r\n\r\ndef get12Components( compNumber, size, m, bits ):\r\n    for i in range( size ):\r\n        if m[ 0 ][ i  ] == 1:\r\n            compNumber += 1\r\n            goRight12( 1, i, compNumber, size, m, bits )\r\n        if m[ 1 ][ i  ] == 1:\r\n            compNumber += 1\r\n            goRight12( 2, i, compNumber, size, m, bits )\r\n        if m[ 2 ][ i  ] == 1:\r\n            compNumber += 1\r\n            goRight12( 4, i, compNumber, size, m, bits )\r\n\r\ndef SolveBB( m, bits, integratedCount, s, e, leftFullColumn, rightFullColumn ):\r\n    #debug = 0\r\n    #print( 'start,end =',s, e )\r\n    #if debug: Print( [ m[0][s-1:e], m[1][s-1:e], m[2][s-1:e] ] )\r\n\r\n    sol1 = 0\r\n    if s-1 == 0:\r\n        sol1 = integratedCount[e]\r\n    else:\r\n        startCnt = 1\r\n        if bits[s-1] == 0:\r\n            startCnt = 0\r\n        elif bits[s-1] == 5:\r\n            if m[0][s-1] != m[2][s-1]:\r\n                startCnt = 2\r\n\r\n        sol1 = startCnt + integratedCount[e] - integratedCount[s]\r\n\r\n    sQ = QColumn( m, bits, s - 1)\r\n    eQ = QColumn( m, bits, e - 1)\r\n\r\n\r\n    if sQ and eQ:\r\n       if m[0][s-1] == m[2][s-1]:\r\n           if rightFullColumn[s-1] == rightFullColumn[e-1]:\r\n                sol1 += 1\r\n                return sol1 \r\n           elif leftFullColumn[s-1] == leftFullColumn[e-1]:\r\n                sol1 += 1\r\n                return sol1 \r\n\r\n    if sQ:\r\n       if rightFullColumn[s-1] != -1:\r\n            if rightFullColumn[s-1] > e-1:\r\n                sol1 += 1\r\n       else:\r\n            sol1 += 1\r\n    if eQ:\r\n        if leftFullColumn[e-1] != -1:\r\n            if leftFullColumn[e-1] < s-1:\r\n                sol1 += 1\r\n        else:\r\n            sol1 += 1\r\n\r\n    return sol1\r\n\r\ndef mainBB():\r\n    debug = 0\r\n    input = sys.stdin\r\n    if len( sys.argv ) >= 2:\r\n        input = open( sys.argv[1], 'r' )\r\n\r\n    size = int( input.readline() )\r\n    m = []\r\n    for i in range( 3 ):\r\n        m.append( [ int( t ) for t in list( input.readline().strip() ) ] )\r\n    bits = [ Column2Num( m, i ) for i in range( size ) ]    \r\n\r\n    leftFullColumn = [ -1 for i in range( size ) ]\r\n    rightFullColumn = list(  leftFullColumn )\r\n\r\n    compNumber = get3Components( 1, size, m, bits, leftFullColumn, rightFullColumn )\r\n    get12Components( compNumber, size, m, bits )\r\n    integratedCount = GetIntegratedCount( m )\r\n\r\n    if debug: PrintIndexed( m )\r\n    if debug: Print( m )\r\n    if debug: print( integratedCount )\r\n    if debug: print( leftFullColumn )\r\n    if debug: print( rightFullColumn )\r\n\r\n    n = int( input.readline() )\r\n    for i in range( n ):\r\n        ln = input.readline().strip().split()\r\n        s = int( ln[0] )\r\n        e = int( ln[1] )\r\n        if debug: print( s, e, m )\r\n\r\n        print( SolveBB( m, bits, integratedCount, s, e, leftFullColumn, rightFullColumn ) )\r\n\r\nif __name__ == \"__main__\":\r\n    mainBB()","tags":["math","trees"],"src_uid":"7c0ffbba9e61a25e51c91b1f89c35532"}
{"text_full":"[DESCRIPTION]This is an interactive problem.The jury has a permutation $$$p$$$ of length $$$n$$$ and wants you to guess it. For this, the jury created another permutation $$$q$$$ of length $$$n$$$. Initially, $$$q$$$ is an identity permutation ($$$q_i = i$$$ for all $$$i$$$).You can ask queries to get $$$q_i$$$ for any $$$i$$$ you want. After each query, the jury will change $$$q$$$ in the following way:   At first, the jury will create a new permutation $$$q'$$$ of length $$$n$$$ such that $$$q'_i = q_{p_i}$$$ for all $$$i$$$.  Then the jury will replace permutation $$$q$$$ with pemutation $$$q'$$$. You can make no more than $$$2n$$$ queries in order to quess $$$p$$$.[SOURCE CODE]import sys\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    p = [0] * n\n    todo = {j for j in range(1, n + 1)}\n    while todo:\n        x = todo.pop()\n        todo.add(x)\n        st, ls = set(), []\n        while True:\n            print('?', x)\n            sys.stdout.flush()\n            y = int(input())\n            if y in st:\n                break\n            else:\n                st.add(y)\n                ls.append(y)\n        if len(ls) == 1:\n            p[x - 1] = x\n            todo.remove(x)\n        else:\n            for j in range(len(ls)):\n                p[ls[j] - 1] = ls[(j + 1) % len(ls)]\n            for x in st:\n                todo.remove(x)\n    print('!', ' '.join(map(str, p)))\n    sys.stdout.flush()","tags":["math"],"src_uid":"96ec983bfadc9e96e36ebb8ffc5279d3"}
{"text_full":"[DESCRIPTION]You are given a rooted tree consisting of $$$n$$$ vertices. Vertices are numbered from $$$1$$$ to $$$n$$$. Any vertex can be the root of a tree.A tree is a connected undirected graph without cycles. A rooted tree is a tree with a selected vertex, which is called the root.The tree is specified by an array of parents $$$p$$$ containing $$$n$$$ numbers: $$$p_i$$$ is a parent of the vertex with the index $$$i$$$. The parent of a vertex $$$u$$$ is a vertex that is the next vertex on the shortest path from $$$u$$$ to the root. For example, on the simple path from $$$5$$$ to $$$3$$$ (the root), the next vertex would be $$$1$$$, so the parent of $$$5$$$ is $$$1$$$.The root has no parent, so for it, the value of $$$p_i$$$ is $$$i$$$ (the root is the only vertex for which $$$p_i=i$$$).Find such a set of paths that:  each vertex belongs to exactly one path, each path can contain one or more vertices;  in each path each next vertex — is a son of the current vertex (that is, paths always lead down — from parent to son);  number of paths is minimal. For example, if $$$n=5$$$ and $$$p=[3, 1, 3, 3, 1]$$$, then the tree can be divided into three paths:   $$$3 \\rightarrow 1 \\rightarrow 5$$$ (path of $$$3$$$ vertices),  $$$4$$$ (path of $$$1$$$ vertices).  $$$2$$$ (path of $$$1$$$ vertices).     Example of splitting a root tree into three paths for $$$n=5$$$, the root of the tree — node $$$3$$$.[SOURCE CODE]# cook your dish here\r\n#!\/usr\/bin\/env python\r\nfrom bisect import bisect_left\r\nimport os\r\nfrom math import ceil, factorial, fmod,pi,sqrt,log\r\nimport sys\r\nfrom collections import Counter\r\nfrom io import BytesIO, IOBase, StringIO\r\ndef modFact(n, p):\r\n    if n >= p:\r\n        return 0   \r\n \r\n    result = 1\r\n    for i in range(1, n + 1):\r\n        result = (result * i) % p\r\n \r\n    return result\r\n \r\ndef calculate(p, q):\r\n     \r\n    mod = 998244353\r\n    expo = 0\r\n    expo = mod - 2\r\n \r\n    # Loop to find the value\r\n    # until the expo is not zero\r\n    while (expo):\r\n \r\n        # Multiply p with q\r\n        # if expo is odd\r\n        if (expo & 1):\r\n            p = (p * q) % mod\r\n        q = (q * q) % mod\r\n \r\n        # Reduce the value of\r\n        # expo by 2\r\n        expo >>= 1\r\n \r\n    return p\r\ndef compute_gcd(x, y):\r\n\r\n   while(y):\r\n       x, y = y, x % y\r\n   return x\r\n\r\n# This function computes LCM\r\ndef compute_lcm(x, y):\r\n   lcm = (x*y)\/\/compute_gcd(x,y)\r\n   return lcm\r\n\r\ndef read_arr():\r\n    return [int(x) for x in input().split()]\r\n\r\ndef bin_search(num, arr):\r\n    start = 0\r\n    end = len(arr)-1\r\n    while start <= end:\r\n        mid=(start+end)\/\/2\r\n        if arr[mid] == num:\r\n            return mid\r\n        elif arr[mid] > num:\r\n            end= mid-1\r\n        else:\r\n            start = mid + 1\r\n    return -1\r\n\r\n\r\ndef factors(n) :\r\n     \r\n    # Note that this loop runs till square root\r\n    i = 1\r\n    ans=[]\r\n    while i <= sqrt(n):\r\n         \r\n        if (n % i == 0) :\r\n             \r\n            # If divisors are equal, print only one\r\n            if (n \/ i == i) :\r\n                ans.append(i)\r\n            else :\r\n                # Otherwise print both\r\n                \r\n                ans.append(i)\r\n                ans.append(int(n\/i))\r\n        i = i + 1\r\n    return ans\r\n\r\ndef is_palindrome(n):\r\n    for j in range(len(n)\/\/2):\r\n        if n[j]!=n[len(n)-j-1]:\r\n            return False\r\n    return True\r\n\r\ndef main():\r\n    t=int(input())\r\n    for i in range(t):\r\n        n = int(input())\r\n        arr = [int(x) for x in input().split()]\r\n        leaves = [True for j in range(n+1)]\r\n        leaves[0]=False\r\n        for j in range(n):\r\n            leaves[arr[j]]=False \r\n        paths = []\r\n        if n == 1:\r\n            print(1)\r\n            print(1)\r\n            print(1)\r\n            print()\r\n            continue\r\n        vis = [False for j in range(n+1)]\r\n        for j in range(n+1):\r\n            if leaves[j]:\r\n                new = []\r\n                start = j\r\n                while not vis[start]:\r\n                    new.append(start)\r\n                    vis[start] = True \r\n                    if start == arr[start-1]:\r\n                        break\r\n                    start = arr[start-1]\r\n                paths.append(new)\r\n        print(len(paths))\r\n        for j in paths:\r\n            print(len(j))\r\n            for k in range(len(j)-1, -1, -1):\r\n                print(j[k],end=\" \")\r\n            print()\r\n        if i != t-1:\r\n            print()\r\n\r\n\r\n\r\n\r\n\r\nBUFSIZE = 8192\r\n \r\n \r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n \r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n \r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n \r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n \r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\n \r\n \r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\n \r\n \r\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\n \r\n# endregion\r\n \r\nif __name__ == \"__main__\":\r\n    main()","tags":["graphs","trees"],"src_uid":"cd2a9169186c4ade98548c29bbdacdf0"}
{"text_full":"[DESCRIPTION]This is the easy version of the problem. The difference between the versions is the constraint on $$$n$$$ and the required number of operations. You can make hacks only if all versions of the problem are solved.There are two binary strings $$$a$$$ and $$$b$$$ of length $$$n$$$ (a binary string is a string consisting of symbols $$$0$$$ and $$$1$$$). In an operation, you select a prefix of $$$a$$$, and simultaneously invert the bits in the prefix ($$$0$$$ changes to $$$1$$$ and $$$1$$$ changes to $$$0$$$) and reverse the order of the bits in the prefix.For example, if $$$a=001011$$$ and you select the prefix of length $$$3$$$, it becomes $$$011011$$$. Then if you select the entire string, it becomes $$$001001$$$.Your task is to transform the string $$$a$$$ into $$$b$$$ in at most $$$3n$$$ operations. It can be proved that it is always possible.[SOURCE CODE]for _ in range(int(input())):\n    n=int(input())\n    s=input()\n    s1=input()\n    s=list(str(x) for x in s)\n    s1=list(str(x) for x in s1)\n    c=[]\n    for i in range(n-1,-1,-1):\n        if s[len(s)-1]==s1[i]:\n            s=s[:len(s)-1]\n            ##print(s,i)\n            continue\n        if int(s1[i])+int(s[0])==1:\n\n            c.append(i+1)\n            s=s[:i+1]\n            for i in range(len(s)):\n                if s[i]=='0':\n                    s[i]='1'\n                else:\n                    s[i]='0'\n            s=s[::-1]\n            s=s[:len(s)-1]\n            continue\n        if s1[i]==s[0]:\n            if s1[i]=='1':\n                s[0]='0'\n                c.append(1)\n            else:\n                c.append(1)\n                s[0]='1'\n            c.append(i + 1)\n            s = s[:i + 1]\n            ##print(s)\n            for i in range(len(s)):\n                if s[i] == '0':\n                    s[i] = '1'\n                else:\n                    s[i] = '0'\n\n            s = s[::-1]\n            s=s[:len(s)-1]\n            ##print(s)\n            continue\n    if len(c)==0:\n        print(0)\n        continue\n    print(len(c),*c)","tags":["strings"],"src_uid":"10c9b2d70030f7ed680297455d1f1bb0"}
{"text_full":"[DESCRIPTION]You are given a connected undirected graph with $$$n$$$ vertices and $$$m$$$ edges. Vertices of the graph are numbered by integers from $$$1$$$ to $$$n$$$ and edges of the graph are numbered by integers from $$$1$$$ to $$$m$$$.Your task is to answer $$$q$$$ queries, each consisting of two integers $$$l$$$ and $$$r$$$. The answer to each query is the smallest non-negative integer $$$k$$$ such that the following condition holds:   For all pairs of integers $$$(a, b)$$$ such that $$$l\\le a\\le b\\le r$$$, vertices $$$a$$$ and $$$b$$$ are reachable from one another using only the first $$$k$$$ edges (that is, edges $$$1, 2, \\ldots, k$$$).[SOURCE CODE]import os\r\nimport sys\r\nfrom io import BytesIO, IOBase\r\n\r\nimport sys\r\nimport threading\r\n\r\nthreading.stack_size(250 * 1024 * 1024)\r\nsys.setrecursionlimit(5000)\r\n\r\n\r\nBUFSIZE = 8192\r\n \r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n \r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n \r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n \r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n \r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\n \r\n \r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\n \r\n \r\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\n\r\n\r\nclass DisjointSetWithWeights:\r\n    def __init__(self, size):\r\n        self.U = [[i, 1] for i in range(size)]\r\n        self.W = [10**9 for i in range(size)]\r\n        \r\n    def root(self, e):\r\n        u = self.U[e]\r\n\r\n        if u[0] != e:\r\n#            r = self.U[e] = self.root(u[0])\r\n            return self.root(u[0])\r\n\r\n        return u\r\n\r\n    def union(self, first, second, weight):\r\n        uFirst, uSecond = self.root(first), self.root(second)\r\n\r\n        if uFirst == uSecond:\r\n            return False\r\n\r\n        if uFirst[1] < uSecond[1]:\r\n            uFirst, uSecond = uSecond, uFirst\r\n            first, second = second, first\r\n\r\n        if uSecond[0] != uFirst[0]:\r\n            self.W[uSecond[0]] = weight\r\n            uSecond[0] = uFirst[0]\r\n            uFirst[1] += uSecond[1]\r\n            \r\n        return True\r\n\r\n    def maxWeight(self, s, e):\r\n        w = 0\r\n\r\n        while s != e:\r\n            if self.W[s] < self.W[e]:\r\n                s, w = self.U[s][0], self.W[s]\r\n            else:\r\n                e, w = self.U[e][0], self.W[e]\r\n\r\n        return w\r\n                \r\n\r\nclass SparseTable:\r\n    def __init__(self, A, F):\r\n        self.A = A\r\n        self.F = F\r\n\r\n        self.buildLG()\r\n        self.buildST()\r\n\r\n    def buildLG(self):\r\n        self.LG = []\r\n        lg, V = 0, 1\r\n        for e in range(len(self.A) + 1):\r\n            if V * 2 <= e:\r\n                V *= 2\r\n                lg += 1\r\n            self.LG.append(lg)\r\n\r\n    def buildST(self):\r\n        n = len(self.A)\r\n        self.ST = []\r\n        length = 1\r\n        while length <= n:\r\n            if length == 1:\r\n                self.ST.append(self.A)\r\n            else:\r\n                self.ST.append([self.F(self.ST[-1][s], self.ST[-1][s + length\/\/2]) for s in range(n - length + 1)])\r\n\r\n            length <<= 1\r\n\r\n    def query(self, l, r):\r\n        if l == r:\r\n            return self.ST[0][l]\r\n\r\n        if l > r:\r\n            l, r = r, l\r\n        \r\n        e = self.LG[r - l + 1]\r\n        return self.F(self.ST[e][l], self.ST[e][r - 2**e + 1])\r\n\r\n\r\nT = int(input())\r\nfor _ in range(T):\r\n    n, m, q = map(int, input().split())\r\n\r\n    dsu = DisjointSetWithWeights(n + 1)\r\n\r\n    for i in range(m):\r\n        s, e = map(int, input().split())\r\n        dsu.union(s, e, i)\r\n\r\n    W = [dsu.maxWeight(i, i + 1) for i in range(1, n)]\r\n\r\n    ST = SparseTable(W, max)\r\n\r\n    R = []\r\n    for i in range(q):\r\n        a, b = map(int, input().split())\r\n        if a == b:\r\n            R.append(0)\r\n        else:\r\n            R.append(ST.query(a - 1, b - 2) + 1)\r\n\r\n\r\n    print(\" \".join(str(r) for r in R))","tags":["trees"],"src_uid":"a365055f2d1c836fd50aed9090db1072"}
{"text_full":"[DESCRIPTION]The All-Berland Team Programming Contest will take place very soon. This year, teams of four are allowed to participate.There are $$$a$$$ programmers and $$$b$$$ mathematicians at Berland State University. How many maximum teams can be made if:  each team must consist of exactly $$$4$$$ students,  teams of $$$4$$$ mathematicians or $$$4$$$ programmers are unlikely to perform well, so the decision was made not to compose such teams. Thus, each team must have at least one programmer and at least one mathematician.Print the required maximum number of teams. Each person can be a member of no more than one team.[SOURCE CODE]from sys import stdin, stdout\r\nt = int(stdin.readline())\r\nfor i in range(t):\r\n    a, b = map(int, stdin.readline().strip().split())\r\n    teams=0\r\n    if a==b:\r\n        teams += (a+b)\/\/4\r\n    else:\r\n        max_one = max(a, b)\r\n        min_one = min(a, b)\r\n        m_p_pairs = min_one \r\n        max_one-=min_one\r\n        min_one = 0\r\n        m_m_pairs = max_one\/\/2\r\n        if m_m_pairs>=m_p_pairs:\r\n            teams+=m_p_pairs \r\n        else:\r\n            teams+=m_m_pairs\r\n            m_p_pairs-=m_m_pairs\r\n            teams+=m_p_pairs\/\/2\r\n    stdout.write(f\"{teams}\\n\")","tags":["math"],"src_uid":"8a1ceac1440f7cb406f12d9fc2ca0e20"}
{"text_full":"[DESCRIPTION]A string is called square if it is some string written twice in a row. For example, the strings \"aa\", \"abcabc\", \"abab\" and \"baabaa\" are square. But the strings \"aaa\", \"abaaab\" and \"abcdabc\" are not square.For a given string $$$s$$$ determine if it is square.[SOURCE CODE]n = int(input())\r\nm = []\r\nfor i in range(n):\r\n    a = input()\r\n    m.append(a)\r\nfor j in m:\r\n    if len(j) == 1:\r\n        print('NO')\r\n    else:\r\n        b = len(j) \/\/ 2\r\n        if len(j) % 2 == 0:\r\n            if j[:b] == j[b:]:\r\n                print('YES')\r\n            else:\r\n                print('NO')\r\n        else:\r\n            print('NO')","tags":["strings"],"src_uid":"9640b7197bd7b8a59f29aecf104291e1"}
{"text_full":"[DESCRIPTION]This is the hard version of the problem. The difference is the constraints on $$$n$$$, $$$m$$$ and $$$t$$$. You can make hacks only if all versions of the problem are solved.Alice and Bob are given the numbers $$$n$$$, $$$m$$$ and $$$k$$$, and play a game as follows:The game has a score that Alice tries to maximize, and Bob tries to minimize. The score is initially $$$0$$$. The game consists of $$$n$$$ turns. Each turn, Alice picks a real number from $$$0$$$ to $$$k$$$ (inclusive) which Bob either adds to or subtracts from the score of the game. But throughout the game, Bob has to choose to add at least $$$m$$$ out of the $$$n$$$ turns.Bob gets to know which number Alice picked before deciding whether to add or subtract the number from the score, and Alice gets to know whether Bob added or subtracted the number for the previous turn before picking the number for the current turn (except on the first turn since there was no previous turn).If Alice and Bob play optimally, what will the final score of the game be?[SOURCE CODE]import sys\r\nimport os\r\nfrom io import BytesIO, IOBase\r\nBUFSIZE = 8192\r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\n \r\nMOD=10**9+7\r\nfacts=[1 for _ in range(10**6+1)]\r\nfor i in range(1,10**6+1):\r\n    facts[i]=(facts[i-1]*i)%MOD\r\nfactinvs=[1 for _ in range(10**6+1)]\r\nfactinvs[-1]=pow(facts[-1],MOD-2,MOD)\r\ntemp=factinvs[-1]\r\nfor i in range(10**6,1,-1):\r\n    factinvs[i-1]=(factinvs[i]*i)%MOD\r\npowinvs=[1 for _ in range(10**6+1)]\r\ninv_2=pow(2,MOD-2,MOD)\r\nfor i in range(1,10**6+1):\r\n    powinvs[i]=powinvs[i-1]*inv_2%MOD\r\ndef binom(n,m):\r\n    return facts[n]*factinvs[m]*factinvs[n-m]%MOD\r\ndef solve():\r\n    n,m,k=map(int,input().split())\r\n    if n==m:\r\n        print((m*k)%MOD)\r\n        return\r\n    res=0\r\n    for i in range(1,m+1):\r\n        c=binom(n-i-1,m-i)\r\n        p=powinvs[n-i]\r\n        res+=(c*p*i*k)%MOD\r\n        res%=MOD\r\n    print(res)\r\n \r\nfor _ in range(int(input())):solve()","tags":["games"],"src_uid":"32ab22abbbce760be53ea8928876431c"}
{"text_full":"[DESCRIPTION]You are given a string s and should process m queries. Each query is described by two 1-based indices li, ri and integer ki. It means that you should cyclically shift the substring s[li... ri] ki times. The queries should be processed one after another in the order they are given.One operation of a cyclic shift (rotation) is equivalent to moving the last character to the position of the first character and shifting all other characters one position to the right.For example, if the string s is abacaba and the query is l1 = 3, r1 = 6, k1 = 1 then the answer is abbacaa. If after that we would process the query l2 = 1, r2 = 4, k2 = 2 then we would get the string baabcaa.[SOURCE CODE]s = input()\nn = int(input())\n\nfor i in range(n):\n    l, r, k = map(int, input().split())\n    k = k % (r - l + 1)\n    s = s[:l - 1] + s[r - k:r] + s[l - 1:r - k] + s[r:]\n\nprint(s)","tags":["strings"],"src_uid":"501b60c4dc465b8a60fd567b208ea1e3"}
{"text_full":"[DESCRIPTION]This problem is a simplified version of D2, but it has significant differences, so read the whole statement.Polycarp has an array of $$$n$$$ ($$$n$$$ is even) integers $$$a_1, a_2, \\dots, a_n$$$. Polycarp conceived of a positive integer $$$k$$$. After that, Polycarp began performing the following operations on the array: take an index $$$i$$$ ($$$1 \\le i \\le n$$$) and reduce the number $$$a_i$$$ by $$$k$$$.After Polycarp performed some (possibly zero) number of such operations, it turned out that all numbers in the array became the same. Find the maximum $$$k$$$ at which such a situation is possible, or print $$$-1$$$ if such a number can be arbitrarily large.[SOURCE CODE]def hcf(a,b):\r\n    if b>a:\r\n        a,b=b,a\r\n    if b==0:\r\n        return a\r\n    return hcf(b,a%b)\r\n\r\nfor iiii in range(int(input())):\r\n    n=int(input())\r\n    q=list(map(int,input().split()))\r\n    maxx=-1\r\n    q1=[]\r\n    q.sort()\r\n    for i in range(1,n):\r\n        if q[i]-q[i-1]>0:\r\n            q1.append(q[i]-q[i-1])\r\n\r\n    if len(q1)==0:\r\n        print(-1)\r\n        continue\r\n    if len(q1)==1:\r\n        print(q1[0])\r\n        continue\r\n    maxx=q1[0]\r\n    for i in range(1,len(q1)):\r\n        maxx=min(maxx,hcf(q1[0],q1[i]))\r\n    print(maxx)","tags":["math","number theory"],"src_uid":"57f0f36905d7769167b7ba9d3d9be351"}
{"text_full":"[DESCRIPTION]A tree is an undirected connected graph in which there are no cycles. This problem is about non-rooted trees. A leaf of a tree is a vertex that is connected to at most one vertex.The gardener Vitaly grew a tree from $$$n$$$ vertices. He decided to trim the tree. To do this, he performs a number of operations. In one operation, he removes all leaves of the tree.  Example of a tree. For example, consider the tree shown in the figure above. The figure below shows the result of applying exactly one operation to the tree.  The result of applying the operation \"remove all leaves\" to the tree. Note the special cases of the operation:  applying an operation to an empty tree (of $$$0$$$ vertices) does not change it;  applying an operation to a tree of one vertex removes this vertex (this vertex is treated as a leaf);  applying an operation to a tree of two vertices removes both vertices (both vertices are treated as leaves). Vitaly applied $$$k$$$ operations sequentially to the tree. How many vertices remain?[SOURCE CODE]t = int(input())\r\nfrom collections import defaultdict, deque\r\n\r\ndef count_indegrees(graph,n):\r\n    indegrees = [0 for i in range(n)]\r\n    for node in graph:\r\n        for neighbor in graph[node]:\r\n            indegrees[neighbor] += 1\r\n    return indegrees\r\n\r\nfor x in range(t):\r\n    input()\r\n    n,k = [int(x) for x in input().split()]\r\n\r\n    graph = defaultdict(list)\r\n    for aaa in range(n-1):\r\n        a,b =[int(x) for x in input().split()]\r\n        a -= 1\r\n        b -= 1\r\n        graph[a].append(b)\r\n        graph[b].append(a)\r\n\r\n    indegrees = count_indegrees(graph, n)\r\n    with_1 = deque([])\r\n    for x in range(len(indegrees)):\r\n        if indegrees[x] <= 1:\r\n            with_1.append(x)\r\n\r\n    pro = 0\r\n    for x in range(k):\r\n        if len(with_1) == 0:\r\n            break\r\n        \r\n        nex = deque([])\r\n        while len(with_1) != 0:\r\n            node = with_1.popleft()\r\n            pro += 1\r\n            for neighbor in graph[node]:\r\n                indegrees[neighbor] -= 1\r\n                if indegrees[neighbor] == 1:\r\n                    nex.append(neighbor)\r\n\r\n        with_1 = nex\r\n\r\n    print(n-pro)","tags":["trees"],"src_uid":"07ac198c1086323517540ecd0669eb4c"}
{"text_full":"[DESCRIPTION]You are given a string $$$s$$$ of length $$$n$$$. Each character is either one of the first $$$k$$$ lowercase Latin letters or a question mark.You are asked to replace every question mark with one of the first $$$k$$$ lowercase Latin letters in such a way that the following value is maximized.Let $$$f_i$$$ be the maximum length substring of string $$$s$$$, which consists entirely of the $$$i$$$-th Latin letter. A substring of a string is a contiguous subsequence of that string. If the $$$i$$$-th letter doesn't appear in a string, then $$$f_i$$$ is equal to $$$0$$$.The value of a string $$$s$$$ is the minimum value among $$$f_i$$$ for all $$$i$$$ from $$$1$$$ to $$$k$$$.What is the maximum value the string can have?[SOURCE CODE]import io,os\ninput = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\nfrom collections import deque \n\n \nn, k = map(int,input().split())\ns = input()\n\n \n \n \ndef judge(needed):\n \n    \n    inf = 2147483647\n    minstate = [inf]*(1<<k)\n    minstate[0] = 0\n \n    effect = [[inf]*(n+1) for j in range(k)]\n \n\n    \n    for j in range(k):\n        accu = 0\n        index = inf\n        for i in range(n)[::-1]:\n            if s[i]==ord('?') or s[i]==97+j:\n                accu += 1\n            else:\n                accu = 0\n\n   \n\n            if accu>=needed:\n                index = i + needed\n            effect[j][i] = index\n#            effect[j][i] = min(effect[j][i],inf*inf+inf*inf)\n\n\n   \n#    print(effect)                \n             \n\n    for state in range(1,1<<k):\n\n        minimum = minstate[state]\n\n        for j in range(k):\n            if (1<<j) & state==0: continue\n\n            index = minstate[state^(1<<j)]\n            if index<n:\n                minimum = min(minimum, effect[j][index]) \n\n\n\n        minstate[state] = minimum \n   \n \n#    print(minstate) \n \n \n \n    if minstate[-1]<=n:  return True\n    return False\n \n \nfront = 0\nrear = n\/\/k+1\n \nwhile front < rear:\n    mid = (front+rear)\/\/2\n    flag = judge(mid)\n#    print(mid,flag)\n \n    if flag:  \n        front = mid + 1\n    else:\n        rear = mid \n \nprint(front-1)","tags":["strings"],"src_uid":"87d3c1d8d3d1f34664ff32081222117d"}
{"text_full":"[DESCRIPTION]You are given two arrays $$$a$$$ and $$$b$$$ of length $$$n$$$. Array $$$a$$$ contains each odd integer from $$$1$$$ to $$$2n$$$ in an arbitrary order, and array $$$b$$$ contains each even integer from $$$1$$$ to $$$2n$$$ in an arbitrary order.You can perform the following operation on those arrays:   choose one of the two arrays  pick an index $$$i$$$ from $$$1$$$ to $$$n-1$$$  swap the $$$i$$$-th and the $$$(i+1)$$$-th elements of the chosen array  Compute the minimum number of operations needed to make array $$$a$$$ lexicographically smaller than array $$$b$$$.For two different arrays $$$x$$$ and $$$y$$$ of the same length $$$n$$$, we say that $$$x$$$ is lexicographically smaller than $$$y$$$ if in the first position where $$$x$$$ and $$$y$$$ differ, the array $$$x$$$ has a smaller element than the corresponding element in $$$y$$$.[SOURCE CODE]def get_input():\r\n    al = []\r\n    for c in range(int(input())):\r\n        input()\r\n        a = [int(i) for i in input().split(\" \")]\r\n        b = [int(i) for i in input().split(\" \")]\r\n        al.append([a,b])\r\n    return al\r\ndef solve(a,b):\r\n    j = 1\r\n    di = {}\r\n    for i in range(len(a)):\r\n        while j < b[i]:\r\n            di[j] = i\r\n            j+=2\r\n    ans = 2*len(a) + 1\r\n    for i in range(len(a)):\r\n        ans = min(ans, i + di[a[i]])\r\n    return ans\r\n\r\n            \r\ndef main():\r\n    arr_list = get_input()\r\n    for a,b in arr_list:\r\n        r = solve(a,b)\r\n        print(r)\r\nmain()","tags":["math"],"src_uid":"55a1e9236cac9a6044e74b1975331535"}
{"text_full":"[DESCRIPTION]You are given a directed graph consisting of $$$n$$$ vertices. Each directed edge (or arc) labeled with a single character. Initially, the graph is empty.You should process $$$m$$$ queries with it. Each query is one of three types:   \"$$$+$$$ $$$u$$$ $$$v$$$ $$$c$$$\" — add arc from $$$u$$$ to $$$v$$$ with label $$$c$$$. It's guaranteed that there is no arc $$$(u, v)$$$ in the graph at this moment;  \"$$$-$$$ $$$u$$$ $$$v$$$\" — erase arc from $$$u$$$ to $$$v$$$. It's guaranteed that the graph contains arc $$$(u, v)$$$ at this moment;  \"$$$?$$$ $$$k$$$\" — find the sequence of $$$k$$$ vertices $$$v_1, v_2, \\dots, v_k$$$ such that there exist both routes $$$v_1 \\to v_2 \\to \\dots \\to v_k$$$ and $$$v_k \\to v_{k - 1} \\to \\dots \\to v_1$$$ and if you write down characters along both routes you'll get the same string. You can visit the same vertices any number of times.[SOURCE CODE]import os, sys\r\nfrom io import BytesIO, IOBase\r\n\r\nfrom collections import defaultdict, deque, Counter\r\nfrom bisect import bisect_left, bisect_right\r\nfrom heapq import heappush, heappop\r\nfrom functools import lru_cache\r\nfrom itertools import accumulate\r\nimport math\r\nimport sys\r\n\r\n# sys.setrecursionlimit(10 ** 6)\r\n# Fast IO Region\r\nBUFSIZE = 8192\r\n\r\n\r\n#\r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n\r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n\r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n\r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n\r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\n\r\n\r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\n\r\n\r\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\n# sys.setrecursionlimit(800)\r\n\r\n\r\nii = lambda: int(input())\r\nmii = lambda: map(int, input().split())\r\nlmii = lambda: list(map(int, input().split()))\r\ni2c = lambda n: chr(ord('a') + n)\r\nc2i = lambda c: ord(c) - ord('a')\r\n# mod = 998244353\r\nmod = 10 ** 9 + 7\r\n\r\n\r\ndef solve():\r\n    n, m = mii()\r\n    magic = 2184732\r\n    d = {}\r\n    bs = 0\r\n    bss = 0\r\n    for i in range(m):\r\n        ope = input().split()\r\n        if len(ope) == 4:\r\n            ch, u, v, c = ope\r\n            u = int(u) + magic\r\n            v = int(v) + magic\r\n            d[(u, v)] = c\r\n            if (v, u) in d and d[(v, u)] != '#':\r\n                bs += 1\r\n                if d[(v, u)] == c:\r\n                    bss += 1\r\n        elif len(ope) == 3:\r\n            ch, u, v = ope\r\n            u = int(u) + magic\r\n            v = int(v) + magic\r\n            if (v, u) in d and d[(v, u)] != '#':\r\n                bs -= 1\r\n                if d[(v, u)] == d[(u, v)]:\r\n                    bss -= 1\r\n            d[(u, v)] = '#'\r\n        else:\r\n            _, k = ope\r\n            k = int(k)\r\n            if k & 1:\r\n                if bs > 0:\r\n                    print('YES')\r\n                else:\r\n                    print('NO')\r\n            else:\r\n                if bss > 0:\r\n                    print('YES')\r\n                else:\r\n                    print('NO')\r\n\r\n\r\nfor _ in range(1):\r\n    solve()","tags":["graphs"],"src_uid":"5afb904f611d963ed3e302faefef3305"}
{"text_full":"[DESCRIPTION]You are given a permutation $$$p_1, p_2, \\ldots, p_n$$$ of length $$$n$$$ of numbers $$$0, \\ldots, n - 1$$$. Count the number of subsegments $$$1 \\leq l \\leq r \\leq n$$$ of this permutation such that $$$mex(p_l, p_{l+1}, \\ldots, p_r) &gt; med(p_l, p_{l+1}, \\ldots, p_r)$$$.$$$mex$$$ of $$$S$$$ is the smallest non-negative integer that does not occur in $$$S$$$. For example: $$$mex({0, 1, 2, 3}) = 4$$$ $$$mex({0, 4, 1, 3}) = 2$$$ $$$mex({5, 4, 0, 1, 2}) = 3$$$$$$med$$$ of the set $$$S$$$ is the median of the set, i.e. the element that, after sorting the elements in non-decreasing order, will be at position number $$$\\left \\lfloor{ \\frac{|S| + 1}{2} } \\right \\rfloor$$$ (array elements are numbered starting from $$$1$$$ and here $$$\\left \\lfloor{v} \\right \\rfloor$$$ denotes rounding $$$v$$$ down.). For example: $$$med({0, 1, 2, 3}) = 1$$$ $$$med({0, 4, 1, 3}) = 1$$$ $$$med({5, 4, 0, 1, 2}) = 2$$$A sequence of $$$n$$$ numbers is called a permutation if it contains all the numbers from $$$0$$$ to $$$n - 1$$$ exactly once.[SOURCE CODE]m=int(input())\r\nfor _ in range(m):\r\n    n=int(input())\r\n    s=dict(zip(map(int,input().split()),range(n)))\r\n    mi=s[0]\r\n    ma=mi\r\n    lists=0\r\n    n0=int(n\/2)+n%2\r\n    for i in range(n0):\r\n        si=s[i]\r\n        mi=min(mi,si)\r\n        ma=max(ma,si)\r\n        b1=2*i+1\r\n        b2=b1+1\r\n        a1=min(b1-ma+mi,mi+1,n-ma,n-b1+1)\r\n        a2=min(b2-ma+mi,mi+1,n-ma,n-b2+1)\r\n        if b2<=n and a2>0:\r\n            lists=lists+a2\r\n        if a1>0:\r\n            lists=lists+a1\r\n    print(lists)","tags":["math"],"src_uid":"d55660b8091bca2211fa1ad56402aebd"}
{"text_full":"[DESCRIPTION]You are given $$$n$$$ of integers $$$a_1, a_2, \\ldots, a_n$$$. Process $$$q$$$ queries of two types: query of the form \"0 $$$x_j$$$\": add the value $$$x_j$$$ to all even elements of the array $$$a$$$, query of the form \"1 $$$x_j$$$\": add the value $$$x_j$$$ to all odd elements of the array $$$a$$$.Note that when processing the query, we look specifically at the odd\/even value of $$$a_i$$$, not its index.After processing each query, print the sum of the elements of the array $$$a$$$.Please note that the answer for some test cases won't fit into 32-bit integer type, so you should use at least 64-bit integer type in your programming language (like long long for C++).[SOURCE CODE]t = int(input())\nfor _ in range(t):\n    n, q = [int(i) for i in input().split()]\n    a = [int(j) for j in input().split()]\n    n0 = 0\n    n1 = 0\n    suma = sum(a)\n    for j in range(n):\n        if a[j] % 2 == 0:\n            n0 += 1\n        else:\n            n1 += 1\n    for _ in range(q):\n        operation, number = [int(i) for i in input().split()]\n        if operation == 0:\n            suma += (n0 * number)\n            print(suma)\n        if operation == 1:\n            suma += (n1 * number)\n            print(suma)\n        if number % 2 != 0:\n            if operation == 1:\n                n0 += n1\n                n1 = 0\n            elif operation == 0:\n                n1 += n0\n                n0 = 0","tags":["math"],"src_uid":"d15cffca07768f8ce6fab7e13a6e7976"}
{"text_full":"[DESCRIPTION]You are given a table $$$a$$$ of size $$$n \\times m$$$. We will consider the table rows numbered from top to bottom from $$$1$$$ to $$$n$$$, and the columns numbered from left to right from $$$1$$$ to $$$m$$$. We will denote a cell that is in the $$$i$$$-th row and in the $$$j$$$-th column as $$$(i, j)$$$. In the cell $$$(i, j)$$$ there is written a number $$$(i - 1) \\cdot m + j$$$, that is $$$a_{ij} = (i - 1) \\cdot m + j$$$.A turtle initially stands in the cell $$$(1, 1)$$$ and it wants to come to the cell $$$(n, m)$$$. From the cell $$$(i, j)$$$ it can in one step go to one of the cells $$$(i + 1, j)$$$ or $$$(i, j + 1)$$$, if it exists. A path is a sequence of cells in which for every two adjacent in the sequence cells the following satisfies: the turtle can reach from the first cell to the second cell in one step. A cost of a path is the sum of numbers that are written in the cells of the path.  For example, with $$$n = 2$$$ and $$$m = 3$$$ the table will look as shown above. The turtle can take the following path: $$$(1, 1) \\rightarrow (1, 2) \\rightarrow (1, 3) \\rightarrow (2, 3)$$$. The cost of such way is equal to $$$a_{11} + a_{12} + a_{13} + a_{23} = 12$$$. On the other hand, the paths $$$(1, 1) \\rightarrow (1, 2) \\rightarrow (2, 2) \\rightarrow (2, 1)$$$ and $$$(1, 1) \\rightarrow (1, 3)$$$ are incorrect, because in the first path the turtle can't make a step $$$(2, 2) \\rightarrow (2, 1)$$$, and in the second path it can't make a step $$$(1, 1) \\rightarrow (1, 3)$$$.You are asked to tell the turtle a minimal possible cost of a path from the cell $$$(1, 1)$$$ to the cell $$$(n, m)$$$. Please note that the cells $$$(1, 1)$$$ and $$$(n, m)$$$ are a part of the way.[SOURCE CODE]t = int(input())\r\nlist = []\r\nfor i in range(1,t+1):\r\n    pair = input().split()\r\n    list.append(pair)\r\n\r\nfor i in range(1,t+1):\r\n    n = int(list[i-1][0])\r\n    m = int(list[i-1][1])\r\n    sum = 0\r\n    for x in range(1,m):\r\n        sum = sum + x\r\n    for y in range(1,n+1):\r\n        sum = sum + (y*m)\r\n    print(sum)","tags":["math"],"src_uid":"7d774a003d2e3e8ae6fe1912b3998c96"}
{"text_full":"[DESCRIPTION]It was the third month of remote learning, Nastya got sick of staying at dormitory, so she decided to return to her hometown. In order to make her trip more entertaining, one of Nastya's friend presented her an integer array $$$a$$$. Several hours after starting her journey home Nastya remembered about the present. To entertain herself she decided to check, are there four different indices $$$x, y, z, w$$$ such that $$$a_x + a_y = a_z + a_w$$$.Her train has already arrived the destination, but she still hasn't found the answer. Can you help her unravel the mystery?[SOURCE CODE]#!\/usr\/bin\/env python3\r\nimport sys\r\n \r\nsys.stdin.readline()\r\nl = list(map(int, sys.stdin.readline().split()))\r\n#l = sorted(l)\r\n \r\ncand = {}\r\n \r\nfor i, v1 in enumerate(l):\r\n    for j in range(i):\r\n        s = v1 + l[j]\r\n        if s in cand:\r\n            if i not in cand[s] and j not in cand[s]:\r\n                print('YES')\r\n                print(i + 1, j + 1, cand[s][0] + 1, cand[s][1] + 1)\r\n                exit(0)\r\n        else:\r\n            cand[s] = (i, j)\r\n \r\nprint('NO')","tags":["math"],"src_uid":"704297bc97528ec27cce5f9388019e29"}
{"text_full":"[DESCRIPTION]Vasya is a CEO of a big construction company. And as any other big boss he has a spacious, richly furnished office with two crystal chandeliers. To stay motivated Vasya needs the color of light at his office to change every day. That's why he ordered both chandeliers that can change its color cyclically. For example: red – brown – yellow – red – brown – yellow and so on. There are many chandeliers that differs in color set or order of colors. And the person responsible for the light made a critical mistake — they bought two different chandeliers.Since chandeliers are different, some days they will have the same color, but some days — different. Of course, it looks poor and only annoys Vasya. As a result, at the $$$k$$$-th time when chandeliers will light with different colors, Vasya will become very angry and, most probably, will fire the person who bought chandeliers.Your task is to calculate the day, when it happens (counting from the day chandeliers were installed). You can think that Vasya works every day without weekends and days off.[SOURCE CODE]def mcd(a,b):\r\n if a==0: return(b)\r\n if b==0: return(a)\r\n return mcd(b,a%b)\r\n\r\n\r\n\r\ndef solve(n,m,k,a,b):\r\n d = mcd(n,m)\r\n mcm = n*m\/\/d\r\n [x,y] = BuscarIndices(n,m,d)\r\n\r\n collection = {}\r\n matchings = []\r\n\r\n for i in range(n):\r\n  collection[a[i]] = i\r\n \r\n for j in range(m):\r\n  if b[j] in collection and (collection[b[j]] - j) % d == 0:\r\n   if m == 1:\r\n    matchings += [collection[b[j]]]\r\n   else:\r\n    matchings+=[DevuelvePos(collection[b[j]],j,n,m,d,mcm,x,y)]\r\n\r\n matchings.sort()\r\n diasSinProcesar = k\r\n cantidadFinalDias = 0\r\n if k > mcm - len(matchings):\r\n  cantidadFinalDias = ((k-1)\/\/(mcm - len(matchings))) * mcm\r\n  diasSinProcesar = (k-1)%(mcm - len(matchings)) + 1\r\n posicion_inicial = 0\r\n start,end = 0,len(matchings)-1\r\n\r\n while start<=end:\r\n  med = (start+end)\/\/2\r\n  dias_rep = med - start\r\n  total_dias_intervalo = matchings[med] - posicion_inicial\r\n  dias_noRep = total_dias_intervalo - dias_rep\r\n  if dias_noRep >= diasSinProcesar:\r\n   end = med - 1\r\n  else:\r\n   cantidadFinalDias += total_dias_intervalo + 1\r\n   diasSinProcesar -= dias_noRep\r\n   posicion_inicial = matchings[med] + 1\r\n   start = med + 1\r\n cantidadFinalDias += diasSinProcesar\r\n return cantidadFinalDias\r\n \r\ndef DevuelvePos(i,j,n,m,d,mcm,x,y):\r\n return ((i+j + (j-i)*(x*n + y*m)\/\/d)\/\/2)%mcm\r\n\r\ndef BuscarIndices(n,m,d):\r\n x,y=0,0\r\n for i in range(1, m):\r\n  if (i * n - d) % m == 0:\r\n   x = i\r\n   y = (i * n - d) \/\/ m\r\n   break\r\n return [x,y]\r\n\r\n\r\n\r\n\r\ndef main():\r\n [n,m,k] = input().split(\" \")\r\n n,m,k = int(n), int(m), int(k)\r\n a = list(map(int,input().split()))\r\n b = list(map(int,input().split()))\r\n if n<m:\r\n  n,m,a,b = m,n,b,a\r\n print(solve(n,m,k,a,b))\r\n\r\n\r\n\r\nmain()","tags":["math","number theory"],"src_uid":"04f75aa0ae4a015b87ac8521cd1d34fc"}
{"text_full":"[DESCRIPTION]You are given three positive (i.e. strictly greater than zero) integers $$$x$$$, $$$y$$$ and $$$z$$$.Your task is to find positive integers $$$a$$$, $$$b$$$ and $$$c$$$ such that $$$x = \\max(a, b)$$$, $$$y = \\max(a, c)$$$ and $$$z = \\max(b, c)$$$, or determine that it is impossible to find such $$$a$$$, $$$b$$$ and $$$c$$$.You have to answer $$$t$$$ independent test cases. Print required $$$a$$$, $$$b$$$ and $$$c$$$ in any (arbitrary) order.[SOURCE CODE]n = input()\nfor i in range(n):\n    arr = [int(num) for num in raw_input().split()]\n    arr.sort()\n    if arr[1] == arr[2]:\n        print 'YES'\n        print arr[0], arr[0], arr[1]\n    else:\n        print 'NO'","tags":["math"],"src_uid":"f4804780d9c63167746132c35b2bdd02"}
{"text_full":"[DESCRIPTION]You are given an array $$$a[0 \\ldots n - 1] = [a_0, a_1, \\ldots, a_{n - 1}]$$$ of zeroes and ones only. Note that in this problem, unlike the others, the array indexes are numbered from zero, not from one.In one step, the array $$$a$$$ is replaced by another array of length $$$n$$$ according to the following rules:   First, a new array $$$a^{\\rightarrow d}$$$ is defined as a cyclic shift of the array $$$a$$$ to the right by $$$d$$$ cells. The elements of this array can be defined as $$$a^{\\rightarrow d}_i = a_{(i + n - d) \\bmod n}$$$, where $$$(i + n - d) \\bmod n$$$ is the remainder of integer division of $$$i + n - d$$$ by $$$n$$$.  It means that the whole array $$$a^{\\rightarrow d}$$$ can be represented as a sequence $$$$$$a^{\\rightarrow d} = [a_{n - d}, a_{n - d + 1}, \\ldots, a_{n - 1}, a_0, a_1, \\ldots, a_{n - d - 1}]$$$$$$  Then each element of the array $$$a_i$$$ is replaced by $$$a_i \\,\\&amp;\\, a^{\\rightarrow d}_i$$$, where $$$\\&amp;$$$ is a logical \"AND\" operator. For example, if $$$a = [0, 0, 1, 1]$$$ and $$$d = 1$$$, then $$$a^{\\rightarrow d} = [1, 0, 0, 1]$$$ and the value of $$$a$$$ after the first step will be $$$[0 \\,\\&amp;\\, 1, 0 \\,\\&amp;\\, 0, 1 \\,\\&amp;\\, 0, 1 \\,\\&amp;\\, 1]$$$, that is $$$[0, 0, 0, 1]$$$.The process ends when the array stops changing. For a given array $$$a$$$, determine whether it will consist of only zeros at the end of the process. If yes, also find the number of steps the process will take before it finishes.[SOURCE CODE]for _ in range(int(input())):\n    n,d=map(int,input().split())\n    \n    a = list(map(int, input().split()))\n    \n    used = [False]*n\n\n    fail = False\n    res = 0\n\n    for i in range(n):\n        if used[i]:\n            continue\n        \n        cur = i\n        pr = last = it = ans = 0\n\n        used[cur] = True\n        if (a[cur] == 0):\n            ans = max(ans, last)\n            last = 0\n        else:\n            last += 1\n            if (it == pr): pr+=1\n        \n        cur = (cur+d)%n\n        it += 1\n        while cur != i:\n            used[cur] = True\n            if (a[cur] == 0):\n                ans = max(ans, last)\n                last = 0\n            else:\n                last += 1\n                if (it == pr): pr+=1\n            \n            cur = (cur+d)%n\n            it += 1\n        if it != pr:\n            ans = max(ans, pr+last)\n        else:\n            fail = True\n            break\n        res = max(res, ans)\n    if fail:\n        print(-1)\n        continue\n    print(res)","tags":["graphs","math","number theory"],"src_uid":"c15bce9c4b9eddf5c8c3421b768da98c"}
{"text_full":"[DESCRIPTION]Mocha wants to be an astrologer. There are $$$n$$$ stars which can be seen in Zhijiang, and the brightness of the $$$i$$$-th star is $$$a_i$$$. Mocha considers that these $$$n$$$ stars form a constellation, and she uses $$$(a_1,a_2,\\ldots,a_n)$$$ to show its state. A state is called mathematical if all of the following three conditions are satisfied:  For all $$$i$$$ ($$$1\\le i\\le n$$$), $$$a_i$$$ is an integer in the range $$$[l_i, r_i]$$$. $$$\\sum \\limits _{i=1} ^ n a_i \\le m$$$. $$$\\gcd(a_1,a_2,\\ldots,a_n)=1$$$. Here, $$$\\gcd(a_1,a_2,\\ldots,a_n)$$$ denotes the greatest common divisor (GCD) of integers $$$a_1,a_2,\\ldots,a_n$$$.Mocha is wondering how many different mathematical states of this constellation exist. Because the answer may be large, you must find it modulo $$$998\\,244\\,353$$$.Two states $$$(a_1,a_2,\\ldots,a_n)$$$ and $$$(b_1,b_2,\\ldots,b_n)$$$ are considered different if there exists $$$i$$$ ($$$1\\le i\\le n$$$) such that $$$a_i \\ne b_i$$$.[SOURCE CODE]import sys\ninput=sys.stdin.readline #文字列入力はするな！\n\nmod=998244353\nn,m=map(int,input().split())\nl=[0]\nr=[0]\nfor i in range(n):\n    x,y=map(int,input().split())\n    l.append(x)\n    r.append(y)\n\nf=[0]*(m+10)\nfor g in range(m,0,-1):\n    if m\/\/g<n:continue\n    dp=[0]*(n+3)*(m\/\/g+2)\n    def _(i,k):\n        return k*(n+2)+i\n    dp[_(0,0)]=1\n    sdp=[1]*(m\/\/g+3)\n\n    for i in range(1,n+1):\n        for k in range(m\/\/g+2):\n            x,y=(l[i]+g-1)\/\/g,r[i]\/\/g\n            ma=k-x\n            mi=k-y\n            if ma<0:continue\n\n            if mi<=0:dp[_(i,k)]=sdp[ma]\n            else:dp[_(i,k)]=sdp[ma]-sdp[mi-1]\n            dp[_(i,k)]%=mod\n        sdp[0]=dp[_(i,0)]\n        for k in range(1,m\/\/g+2):\n            sdp[k]=sdp[k-1]+dp[_(i,k)]\n            sdp[k]%=mod\n\n    for k in range(m\/\/g+1):\n        f[g]+=dp[_(n,k)]\n        f[g]%=mod\n\nans=[0]*(m+5)\nfor g in range(m,0,-1):\n    ans[g]=f[g]\n    i=2\n    while i*g<=m:\n        ans[g]-=ans[g*i]\n        ans[g]%=mod\n        i+=1\nprint(ans[1])","tags":["math","number theory"],"src_uid":"4ce699a5633d6d3073c2daa7e10060bd"}
{"text_full":"[DESCRIPTION]Given an array $$$a$$$ of positive integers with length $$$n$$$, determine if there exist three distinct indices $$$i$$$, $$$j$$$, $$$k$$$ such that $$$a_i + a_j + a_k$$$ ends in the digit $$$3$$$.[SOURCE CODE]from collections import *\r\nfrom heapq import *\r\nfrom bisect import *\r\nfrom itertools import *\r\nfrom functools import *\r\nfrom math import *\r\nfrom string import *\r\nimport operator\r\nimport sys\r\n\r\ninput = sys.stdin.readline\r\n\r\n\r\ndef solve():\r\n    n = int(input())\r\n    A = list(map(int, input().split()))\r\n    A = [x % 10 for x in A]\r\n    count = Counter(A)\r\n\r\n    arr = []\r\n    for x in count:\r\n        arr.extend([x] * min(count[x], 3))\r\n\r\n    def two_sum(start, target):\r\n        seen = set()\r\n        for j in range(start, len(arr)):\r\n            subtarget = (target - arr[j]) % 10\r\n            if subtarget in seen:\r\n                return True\r\n            seen.add(arr[j])\r\n\r\n        return False\r\n\r\n    # A[i] + A[j] + A[k] == 3 % 10\r\n    for k in range(len(arr)):\r\n        if two_sum(k + 1, (3 - arr[k]) % 10):\r\n            return True\r\n\r\n    return False\r\n\r\n\r\ndef main():\r\n    tests = int(input())\r\n    for _ in range(tests):\r\n        print(\"YES\" if solve() else \"NO\")\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    main()","tags":["math"],"src_uid":"3ae4f35808348841e0f47540cdf4abe6"}
{"text_full":"[DESCRIPTION]Madoka's father just reached $$$1$$$ million subscribers on Mathub! So the website decided to send him a personalized award — The Mathhub's Bit Button! The Bit Button is a rectangular table with $$$n$$$ rows and $$$m$$$ columns with $$$0$$$ or $$$1$$$ in each cell. After exploring the table Madoka found out that: A subrectangle $$$A$$$ is contained in a subrectangle $$$B$$$ if there's no cell contained in $$$A$$$ but not contained in $$$B$$$. Two subrectangles intersect if there is a cell contained in both of them. A subrectangle is called black if there's no cell with value $$$0$$$ inside it. A subrectangle is called nice if it's black and it's not contained in another black subrectangle. The table is called elegant if there are no two nice intersecting subrectangles.For example, in the first illustration the red subrectangle is nice, but in the second one it's not, because it's contained in the purple subrectangle.  Help Madoka to determine whether the table is elegant.[SOURCE CODE]#!\/usr\/bin\/env python\n# coding: utf-8\n\n# In[13]:\n\n\nimport sys\n# input = sys.stdin.readline\n\n\n# In[2]:\n\n\n# input = sys.stdin.readline\n# def inp():\n#     return(int(input()))\n# def inlt():\n#     return(list(map(int,input().split())))\n# def insr():\n#     s = input()\n# #     return(list(s[:len(s) - 1]))\n#     return(list(s[:len(s)]))\n\n# def invr():\n#     return(map(int,input().split()))\n\n\n# In[3]:\n\n\n# #Problem 1 https:\/\/codeforces.com\/contest\/1647\/problem\/A\n# def findLargest(inputNumber):\n#     if inputNumber%3==0:\n#         return int('21'*int(inputNumber\/3))\n#     if inputNumber%3==1:\n#         return int('1'+(int((inputNumber-1)\/3)*'21'))\n#     if inputNumber%3==2:\n#         return int('2'+(int((inputNumber-2)\/3)*'12'))\n    \n# length=inp()\n# for k in range(length):\n#     myNumber=inp()\n#     print(findLargest(myNumber))    \n\n\n# In[17]:\n\n\ndef checkArray(array, x, y):\n    #loop through columns by two\n    for k in range(x-1):\n        first=array[k]\n        second=array[k+1]\n        #check two columns:\n        for i in range(y-1):\n            a,b,c,d=first[i],first[i+1], second[i], second[i+1]\n            if int(a)+int(b)+int(c)+int(d)==3:\n                print('NO')\n                return\n    print('YES')\n\n\n# In[5]:\n\n\n# length=inp()\n\n# for k in range(length):\n#     firstList=inlt()\n#     x,y=firstList[0], firstList[1]\n#     if (x==1 or y==1):\n#         print('YES')\n#     else:\n#         myArray=[]\n#         for row in range(x):\n#             myArray.append(insr())\n#         checkArray(myArray, x, y)\n\n\n# In[23]:\n\n\nlength=int(input())\n\nfor k in range(length):\n    firstInputList=list(map(int, input().split()))\n    x,y=firstInputList[0], firstInputList[1]\n    myArray=[]\n    for row in range(x):\n        s = input()\n        new=(list(s[:len(s)]))\n        myArray.append(new)\n    if(x==1 or y==1):\n        print('YES')\n    else:\n        checkArray(myArray, x, y)\n\n\n# In[ ]:\n\n\n\n\n\n# In[ ]:\n\n\n\n\n\n# In[ ]:","tags":["graphs"],"src_uid":"b44d59eded2cb3a65686dc7fd07d21b7"}
{"text_full":"[DESCRIPTION]Pak Chanek has $$$n$$$ two-dimensional slices of cheese. The $$$i$$$-th slice of cheese can be represented as a rectangle of dimensions $$$a_i \\times b_i$$$. We want to arrange them on the two-dimensional plane such that:  Each edge of each cheese is parallel to either the x-axis or the y-axis.  The bottom edge of each cheese is a segment of the x-axis.  No two slices of cheese overlap, but their sides can touch.  They form one connected shape. Note that we can arrange them in any order (the leftmost slice of cheese is not necessarily the first slice of cheese). Also note that we can rotate each slice of cheese in any way as long as all conditions still hold.Find the minimum possible perimeter of the constructed shape.[SOURCE CODE]t = int(input())\r\n\r\nwhile t > 0:\r\n    t-=1\r\n\r\n    n = int(input()) # number of slices\r\n    x = n\r\n    slicesH = []\r\n    slicesW = []\r\n    totala = 0\r\n    totalb = 0\r\n    currw = 0\r\n    currh = 0\r\n    existingh = []\r\n    slicesH2 = []\r\n    slicesW2 = []\r\n    existingh2 = []\r\n\r\n    while x>0:\r\n        x-=1\r\n        a,b = map(int, input().split())\r\n        h = 0\r\n        w = 0\r\n\r\n        h = max(a,b)\r\n        w = min(a,b)\r\n    \r\n        slicesH.append(h)\r\n        slicesW.append(w)\r\n\r\n\r\n   \r\n   \r\n    d = {i:ix for ix, i in enumerate(slicesH)}\r\n    slicesH = sorted(slicesH)\r\n    slicesW = sorted(slicesW, key=lambda x: d.get(x, float('inf')))\r\n\r\n    slicesH.reverse()\r\n    slicesW.reverse()\r\n\r\n    #print(slicesH)\r\n    #print(slicesW)\r\n    prevh = 0\r\n    top = 0\r\n    bottom = 0\r\n    sides = 0\r\n    \r\n    \r\n   \r\n    for x in range(len(slicesH)):\r\n        top += slicesW[x]*2\r\n        hdiff = abs(slicesH[x]-prevh)\r\n        sides+=hdiff\r\n        prevh = slicesH[x]\r\n\r\n    sides+= prevh\r\n    \r\n    print(top+bottom+sides)","tags":["geometry"],"src_uid":"7100fa11adfa0c1f5d33f9e3a1c3f352"}
{"text_full":"[DESCRIPTION]Pak Chanek has $$$n$$$ blank heart-shaped cards. Card $$$1$$$ is attached directly to the wall while each of the other cards is hanging onto exactly one other card by a piece of string. Specifically, card $$$i$$$ ($$$i &gt; 1$$$) is hanging onto card $$$p_i$$$ ($$$p_i &lt; i$$$).In the very beginning, Pak Chanek must write one integer number on each card. He does this by choosing any permutation $$$a$$$ of $$$[1, 2, \\dots, n]$$$. Then, the number written on card $$$i$$$ is $$$a_i$$$.After that, Pak Chanek must do the following operation $$$n$$$ times while maintaining a sequence $$$s$$$ (which is initially empty):  Choose a card $$$x$$$ such that no other cards are hanging onto it.  Append the number written on card $$$x$$$ to the end of $$$s$$$.  If $$$x \\neq 1$$$ and the number on card $$$p_x$$$ is larger than the number on card $$$x$$$, replace the number on card $$$p_x$$$ with the number on card $$$x$$$.  Remove card $$$x$$$. After that, Pak Chanek will have a sequence $$$s$$$ with $$$n$$$ elements. What is the maximum length of the longest non-decreasing subsequence$$$^\\dagger$$$ of $$$s$$$ at the end if Pak Chanek does all the steps optimally?$$$^\\dagger$$$ A sequence $$$b$$$ is a subsequence of a sequence $$$c$$$ if $$$b$$$ can be obtained from $$$c$$$ by deletion of several (possibly, zero or all) elements. For example, $$$[3,1]$$$ is a subsequence of $$$[3,2,1]$$$, $$$[4,3,1]$$$ and $$$[3,1]$$$, but not $$$[1,3,3,7]$$$ and $$$[3,10,4]$$$.[SOURCE CODE]import sys, threading\r\nfrom collections import defaultdict\r\ndef main():\r\n\r\n    def dfs(node):\r\n        d = 1\r\n        childs_sum = 0  \r\n        for adj in tree[node]:\r\n            child_depth,childs_val = dfs(adj) \r\n            d = max(d, 1 + child_depth)\r\n            childs_sum += childs_val     \r\n        return (d,max(childs_sum,d))\r\n\r\n    n = int(input()) \r\n    pars = list(map(int, input().split()))\r\n    tree = defaultdict(list) \r\n    for i in range(n - 1):\r\n        v = pars[i] \r\n        tree[v].append(i + 2) \r\n    res = dfs(1) \r\n    print(max(*res))  \r\n\r\n\r\n\r\nsys.setrecursionlimit(1 << 30)\r\nthreading.stack_size(1 << 27)\r\nmain_thread = threading.Thread(target = main)\r\nmain_thread.start()\r\nmain_thread.join()","tags":["trees"],"src_uid":"5be268e0607f2d654d7f5ae4f11e2f08"}
{"text_full":"[DESCRIPTION]Monocarp had a permutation $$$a$$$ of $$$n$$$ integers $$$1$$$, $$$2$$$, ..., $$$n$$$ (a permutation is an array where each element from $$$1$$$ to $$$n$$$ occurs exactly once).Then Monocarp calculated an array of integers $$$b$$$ of size $$$n$$$, where $$$b_i = \\left\\lfloor \\frac{i}{a_i} \\right\\rfloor$$$. For example, if the permutation $$$a$$$ is $$$[2, 1, 4, 3]$$$, then the array $$$b$$$ is equal to $$$\\left[ \\left\\lfloor \\frac{1}{2} \\right\\rfloor, \\left\\lfloor \\frac{2}{1} \\right\\rfloor, \\left\\lfloor \\frac{3}{4} \\right\\rfloor, \\left\\lfloor \\frac{4}{3} \\right\\rfloor \\right] = [0, 2, 0, 1]$$$.Unfortunately, the Monocarp has lost his permutation, so he wants to restore it. Your task is to find a permutation $$$a$$$ that corresponds to the given array $$$b$$$. If there are multiple possible permutations, then print any of them. The tests are constructed in such a way that least one suitable permutation exists.[SOURCE CODE]import heapq\r\n\r\nimport sys\r\ninput = sys.stdin.readline\r\nrounds=int(input())\r\nfor ii in range(rounds):\r\n  out=0\r\n  length=int(input())\r\n  arr=list(map(int,input().split()))\r\n  small=[]\r\n  for l in range(length):\r\n    if arr[l]==0:\r\n      small.append([l+2,length,l])\r\n    else:\r\n      little=(l+1)\/\/(arr[l]+1)+1\r\n      big=(l+1)\/\/arr[l]\r\n      small.append([little,big,l])\r\n  \r\n  small.sort()\r\n  used=set()\r\n  out=[0]*length\r\n  p=1\r\n  hold=[]\r\n  heapq.heapify(hold)\r\n  ind=0\r\n  while p<length+1:\r\n    for j in range(ind,length):\r\n      if p>=small[j][0] and small[j][2] not in used:\r\n        heapq.heappush(hold,(small[j][1],small[j][2]))\r\n        used.add(small[j][2])\r\n      else:\r\n        ind=j\r\n        break\r\n    cur=heapq.heappop(hold)\r\n    out[cur[1]]=p\r\n    p+=1\r\n\r\n  for o in out:\r\n    print(o,end=' ')\r\n  print('')","tags":["math"],"src_uid":"5481863fd03c37cdcb7d6ee40f973cb9"}
{"text_full":"[DESCRIPTION]It is the hard version of the problem. The only difference is that in this version $$$a_i \\le 10^9$$$.You are given an array of $$$n$$$ integers $$$a_0, a_1, a_2, \\ldots a_{n - 1}$$$. Bryap wants to find the longest beautiful subsequence in the array.An array $$$b = [b_0, b_1, \\ldots, b_{m-1}]$$$, where $$$0 \\le b_0 &lt; b_1 &lt; \\ldots &lt; b_{m - 1} &lt; n$$$, is a subsequence of length $$$m$$$ of the array $$$a$$$.Subsequence $$$b = [b_0, b_1, \\ldots, b_{m-1}]$$$ of length $$$m$$$ is called beautiful, if the following condition holds:   For any $$$p$$$ ($$$0 \\le p &lt; m - 1$$$) holds: $$$a_{b_p} \\oplus b_{p+1} &lt; a_{b_{p+1}} \\oplus b_p$$$. Here $$$a \\oplus b$$$ denotes the bitwise XOR of $$$a$$$ and $$$b$$$. For example, $$$2 \\oplus 4 = 6$$$ and $$$3 \\oplus 1=2$$$.Bryap is a simple person so he only wants to know the length of the longest such subsequence. Help Bryap and find the answer to his question.[SOURCE CODE]twopow = []\r\nfor i in range(30):\r\n    twopow.append(2 ** i)\r\ntwopow.reverse()\r\n\r\nmaxN = int(60e6)\r\ntrie = [0] * maxN  # in segments of 6. [l, r, 00, 01, 10, 11]\r\nfor i in range(0, maxN, 6):\r\n    trie[i] = trie[i + 1] = -1  # -1 if not linked to any node\r\n\r\nidx_of_trie = 6\r\ndef get_next_idx_of_trie():\r\n    global idx_of_trie\r\n    idx_of_trie += 6\r\n    return idx_of_trie - 6\r\n\r\ndef clear_trie():\r\n    global idx_of_trie\r\n    temp = idx_of_trie\r\n    \r\n    while idx_of_trie >= 1:\r\n        idx_of_trie -= 1\r\n        trie[idx_of_trie] = 0\r\n    \r\n    for i in range(0, temp, 6):\r\n        trie[i] = trie[i + 1] = -1\r\n    \r\n    idx_of_trie = 6\r\n        \r\n\r\nbitmap = [(1, 0), (0, 0), (1, 1), (0, 1)]\r\n# bitmap[ibit * 2 + aibit] = (jbit, ajbit) where j < i and (aibit ^ jbit) > (ajbit ^ ibit)\r\n\r\ndef main():\r\n    \r\n    def add(i, ai):\r\n        value = i ^ ai\r\n        node = 0\r\n        currmax = 1\r\n        for tp in twopow:\r\n            \r\n            if (i & tp) > 0: ibit = 1\r\n            else: ibit = 0\r\n            if (ai & tp) > 0: aibit = 1\r\n            else: aibit = 0\r\n            \r\n            if (value & tp) > 0:\r\n                if trie[node + 1] == -1:\r\n                    trie[node + 1] = get_next_idx_of_trie()\r\n                neighbour = trie[node]\r\n                node = trie[node + 1]\r\n            else:\r\n                if trie[node] == -1:\r\n                    trie[node] = get_next_idx_of_trie()\r\n                neighbour = trie[node + 1]\r\n                node = trie[node]\r\n            \r\n            if neighbour != -1:\r\n                # ai ^ j == aj ^ i right up to before this node.\r\n                # Need to find max dp for ai ^ j > aj ^ i,\r\n                # where i is current index and j is a previous index.\r\n                # for jbit in range(2):\r\n                #     for ajbit in range(2):\r\n                #         if (aibit ^ jbit) > (ajbit ^ ibit):\r\n                #             currmax = max(currmax, 1 + neighbour.dp[jbit][ajbit])\r\n                    \r\n                # Casework. (aibit ^ jbit) > (ajbit ^ ibit)\r\n                jbit, ajbit = bitmap[ibit * 2 + aibit]\r\n                currmax = max(currmax, 1 + trie[neighbour + 2 + jbit * 2 + ajbit])\r\n        \r\n        # update trie\r\n        node = 0\r\n        for tp in twopow:\r\n            \r\n            if (i & tp) > 0: ibit = 1\r\n            else: ibit = 0\r\n            if (ai & tp) > 0: aibit = 1\r\n            else: aibit = 0\r\n            \r\n            if (value & tp) > 0:\r\n                node = trie[node + 1]\r\n            else:\r\n                node = trie[node]\r\n            \r\n            # node.dp[ibit][aibit] = max(node.dp[ibit][aibit], currmax)\r\n            trie[node + 2 + ibit * 2 + aibit] = max(currmax,\r\n                                                    trie[node + 2 + ibit * 2 + aibit])\r\n        \r\n        return currmax\r\n    \r\n    t = int(input())\r\n    allans = []\r\n    for _ in range(t):\r\n        n = int(input())\r\n        a = readIntArr()\r\n        \r\n        # testdp = [1] * n\r\n        ans = 0\r\n        for i, ai in enumerate(a):\r\n            res = add(i, ai)\r\n            # testdp[i] = res\r\n            ans = max(ans, res)\r\n        \r\n        # print(testdp)  # TEST\r\n        \r\n        allans.append(ans)\r\n        clear_trie()\r\n    multiLineArrayPrint(allans)\r\n    \r\n    return\r\n\r\nimport sys\r\ninput=sys.stdin.buffer.readline #FOR READING PURE INTEGER INPUTS (space separation ok)\r\n# input=lambda: sys.stdin.readline().rstrip(\"\\r\\n\") #FOR READING STRING\/TEXT INPUTS.\r\n \r\ndef oneLineArrayPrint(arr):\r\n    print(' '.join([str(x) for x in arr]))\r\ndef multiLineArrayPrint(arr):\r\n    print('\\n'.join([str(x) for x in arr]))\r\ndef multiLineArrayOfArraysPrint(arr):\r\n    print('\\n'.join([' '.join([str(x) for x in y]) for y in arr]))\r\n \r\ndef readIntArr():\r\n    return [int(x) for x in input().split()]\r\n# def readFloatArr():\r\n#     return [float(x) for x in input().split()]\r\n \r\ndef makeArr(defaultValFactory,dimensionArr): # eg. makeArr(lambda:0,[n,m])\r\n    dv=defaultValFactory;da=dimensionArr\r\n    if len(da)==1:return [dv() for _ in range(da[0])]\r\n    else:return [makeArr(dv,da[1:]) for _ in range(da[0])]\r\n \r\ndef queryInteractive(a, b, c):\r\n    print('? {} {} {}'.format(a, b, c))\r\n    sys.stdout.flush()\r\n    return int(input())\r\n \r\ndef answerInteractive(x1, x2):\r\n    print('! {} {}'.format(x1, x2))\r\n    sys.stdout.flush()\r\n \r\ninf=float('inf')\r\n# MOD=10**9+7\r\n# MOD=998244353\r\n \r\nfrom math import gcd,floor,ceil\r\nimport math\r\n# from math import floor,ceil # for Python2\r\n \r\nfor _abc in range(1):\r\n    main()","tags":["strings","trees"],"src_uid":"41359a6dbfb0bf0887fef84ac748983a"}
{"text_full":"[DESCRIPTION]You are given a positive integer $$$x$$$. Check whether the number $$$x$$$ is representable as the sum of the cubes of two positive integers.Formally, you need to check if there are two integers $$$a$$$ and $$$b$$$ ($$$1 \\le a, b$$$) such that $$$a^3+b^3=x$$$.For example, if $$$x = 35$$$, then the numbers $$$a=2$$$ and $$$b=3$$$ are suitable ($$$2^3+3^3=8+27=35$$$). If $$$x=4$$$, then no pair of numbers $$$a$$$ and $$$b$$$ is suitable.[SOURCE CODE]#!\/usr\/bin\/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"Codeforces Round #702 (Div. 3)\n\nProblem C. Sum of Cubes\n\n:author:         Kitchen Tong\n:mail:    kctong529@gmail.com\n\nPlease feel free to contact me if you have any question\nregarding the implementation below.\n\"\"\"\n\n__version__ = '3.1'\n__date__ = '2021-03-13'\n\n\nimport sys\n\n\ndef solve(x, cubes) -> bool:\n    for c in cubes:\n        if x - c in cubes:\n            return True\n    return False\n \n \ndef main(argv=None):\n    cubes = {pow(i, 3) for i in range(1, 10001)}\n    t = int(input())\n    for _ in range(t):\n        x = int(input())\n        ans = solve(x, cubes)\n        print('YES' if ans == True else 'NO')\n    return 0\n\n\nif __name__ == \"__main__\":\n    STATUS = main()\n    sys.exit(STATUS)","tags":["math"],"src_uid":"b4ca6a5ee6307ab2bcdab2ea5dd5b2b3"}
{"text_full":"[DESCRIPTION]You are given a number $$$n$$$ (divisible by $$$3$$$) and an array $$$a[1 \\dots n]$$$. In one move, you can increase any of the array elements by one. Formally, you choose the index $$$i$$$ ($$$1 \\le i \\le n$$$) and replace $$$a_i$$$ with $$$a_i + 1$$$. You can choose the same index $$$i$$$ multiple times for different moves.Let's denote by $$$c_0$$$, $$$c_1$$$ and $$$c_2$$$ the number of numbers from the array $$$a$$$ that have remainders $$$0$$$, $$$1$$$ and $$$2$$$ when divided by the number $$$3$$$, respectively. Let's say that the array $$$a$$$ has balanced remainders if $$$c_0$$$, $$$c_1$$$ and $$$c_2$$$ are equal.For example, if $$$n = 6$$$ and $$$a = [0, 2, 5, 5, 4, 8]$$$, then the following sequence of moves is possible:   initially $$$c_0 = 1$$$, $$$c_1 = 1$$$ and $$$c_2 = 4$$$, these values are not equal to each other. Let's increase $$$a_3$$$, now the array $$$a = [0, 2, 6, 5, 4, 8]$$$;  $$$c_0 = 2$$$, $$$c_1 = 1$$$ and $$$c_2 = 3$$$, these values are not equal. Let's increase $$$a_6$$$, now the array $$$a = [0, 2, 6, 5, 4, 9]$$$;  $$$c_0 = 3$$$, $$$c_1 = 1$$$ and $$$c_2 = 2$$$, these values are not equal. Let's increase $$$a_1$$$, now the array $$$a = [1, 2, 6, 5, 4, 9]$$$;  $$$c_0 = 2$$$, $$$c_1 = 2$$$ and $$$c_2 = 2$$$, these values are equal to each other, which means that the array $$$a$$$ has balanced remainders. Find the minimum number of moves needed to make the array $$$a$$$ have balanced remainders.[SOURCE CODE]for _ in range(int(input())):\n    n = int(input())\n    arr = list(map(int, input().split()))\n    count = 0\n    ht = {0: 0, 1: 0, 2: 0}\n    for i in arr:\n        ht[i % 3] += 1\n    while True:\n        # print(ht)\n        diff = 1\n        if ht[0] == ht[1] == ht[2]:\n            print(count)\n            break\n        if ht[0] > ht[1] and ht[0] > n \/\/ 3:\n            diff = abs(n \/\/ 3 - ht[0])\n            ht[1] += diff\n            ht[0] -= diff\n        elif ht[1] > ht[2] and ht[1] > n \/\/ 3:\n            diff = abs(n \/\/ 3 - ht[1])\n            ht[2] += diff\n            ht[1] -= diff\n        elif ht[2] > ht[0] and ht[2] > n \/\/ 3:\n            diff = abs(n \/\/ 3 - ht[2])\n            ht[0] += diff\n            ht[2] -= diff\n        count += diff","tags":["math"],"src_uid":"e0de8a6441614d1e41a53223b5fa576b"}
{"text_full":"[DESCRIPTION]Polycarp calls an array dense if the greater of any two adjacent elements is not more than twice bigger than the smaller. More formally, for any $$$i$$$ ($$$1 \\le i \\le n-1$$$), this condition must be satisfied: $$$$$$\\frac{\\max(a[i], a[i+1])}{\\min(a[i], a[i+1])} \\le 2$$$$$$For example, the arrays $$$[1, 2, 3, 4, 3]$$$, $$$[1, 1, 1]$$$ and $$$[5, 10]$$$ are dense. And the arrays $$$[5, 11]$$$, $$$[1, 4, 2]$$$, $$$[6, 6, 1]$$$ are not dense.You are given an array $$$a$$$ of $$$n$$$ integers. What is the minimum number of numbers you need to add to an array to make it dense? You can insert numbers anywhere in the array. If the array is already dense, no numbers need to be added.For example, if $$$a=[4,2,10,1]$$$, then the answer is $$$5$$$, and the array itself after inserting elements into it may look like this: $$$a=[4,2,\\underline{\\textbf{3}},\\underline{\\textbf{5}},10,\\underline{\\textbf{6}},\\underline{\\textbf{4}},\\underline{\\textbf{2}},1]$$$ (there are other ways to build such $$$a$$$).[SOURCE CODE]import math\nn = int(input())\nfor x in range(n):\n    l = int(input())\n    a = list(map(int,input().split()))\n    f = 0\n    for i in range(len(a) - 1):\n        low = min(a[i],a[i+1])\n        high = max(a[i],a[i+1])\n        while high > low * 2:\n            low *= 2\n            f += 1\n    print(f)","tags":["math"],"src_uid":"a544dd9fd96379f66a960de6f973dd50"}
{"text_full":"[DESCRIPTION]Stephen Queen wants to write a story. He is a very unusual writer, he uses only letters 'a', 'b', 'c', 'd' and 'e'!To compose a story, Stephen wrote out $$$n$$$ words consisting of the first $$$5$$$ lowercase letters of the Latin alphabet. He wants to select the maximum number of words to make an interesting story.Let a story be a sequence of words that are not necessarily different. A story is called interesting if there exists a letter which occurs among all words of the story more times than all other letters together.For example, the story consisting of three words \"bac\", \"aaada\", \"e\" is interesting (the letter 'a' occurs $$$5$$$ times, all other letters occur $$$4$$$ times in total). But the story consisting of two words \"aba\", \"abcde\" is not (no such letter that it occurs more than all other letters in total).You are given a sequence of $$$n$$$ words consisting of letters 'a', 'b', 'c', 'd' and 'e'. Your task is to choose the maximum number of them to make an interesting story. If there's no way to make a non-empty story, output $$$0$$$.[SOURCE CODE]from sys import stdin, stdout\n\n\nt = int(stdin.readline())\nfor tt in range(t):\n    n = int(stdin.readline())\n    a = [stdin.readline().strip() for i in range(n)]\n\n    chars = 'abcde'\n    # c_count = [{c: 0 for c in chars} for i in range(n)]\n    # not_c_count = [{c: 0 for c in chars} for i in range(n)]\n    \n    # for i in range(n):\n    #     for c in stdin.readline().strip(): # a[i]:\n    #         c_count[i][c] += 1\n\n    #         for not_c in chars:\n    #             if not_c != c:\n    #                 not_c_count[i][not_c] += 1\n\n    # if n >= 100000:\n    #     del a\n    # sm = {c: sum([c_count[i][c] for i in range(n)]) for c in chars}\n    # print(sm)\n\n    res = {c: 0 for c in chars}\n    for c in chars:\n        # c_minus_not_c = [c_count[i][c] - not_c_count[i][c] for i in range(n)]\n        c_minus_not_c = [0 for i in range(n)]\n        c_sum = 0\n        not_c_sum = 0\n        for i in range(n):\n            for char in a[i]:\n                if char == c:\n                    c_minus_not_c[i] += 1\n                    c_sum += 1\n                else:\n                    c_minus_not_c[i] += -1\n                    not_c_sum += 1\n\n        c_minus_not_c.sort()\n\n        # c_sum = sm[c]\n        # not_c_sum = sum([sm[not_c] for not_c in chars if not_c != c])\n\n        rem_num = 0\n        l = 0\n        while c_sum <= not_c_sum and l < n:\n            if c_minus_not_c[l] >= 0:\n                rem_num = n \n                break\n\n            c_sum -= c_minus_not_c[l]\n            l += 1\n            rem_num += 1\n\n        res[c] = n - rem_num\n        # if n >= 100000:\n        #     del c_minus_not_c\n\n    stdout.write(str(max([res[c] for c in chars])) + '\\n')","tags":["strings"],"src_uid":"18ac51a009c907fe8e4cd2bb8612da20"}
{"text_full":"[DESCRIPTION]Today is a holiday in the residence hall — Oleh arrived, in honor of which the girls gave him a string. Oleh liked the gift a lot, so he immediately thought up and offered you, his best friend, the following problem.You are given a string $$$s$$$ of length $$$n$$$, which consists of the first $$$17$$$ lowercase Latin letters {$$$a$$$, $$$b$$$, $$$c$$$, $$$\\ldots$$$, $$$p$$$, $$$q$$$} and question marks. And $$$q$$$ queries. Each query is defined by a set of pairwise distinct lowercase first $$$17$$$ letters of the Latin alphabet, which can be used to replace the question marks in the string $$$s$$$.The answer to the query is the sum of the number of distinct substrings that are palindromes over all strings that can be obtained from the original string $$$s$$$ by replacing question marks with available characters. The answer must be calculated modulo $$$998\\,244\\,353$$$.Pay attention! Two substrings are different when their start and end positions in the string are different. So, the number of different substrings that are palindromes for the string aba will be $$$4$$$: a, b, a, aba.Consider examples of replacing question marks with letters. For example, from the string aba??ee when querying {$$$a$$$, $$$b$$$} you can get the strings ababaee or abaaaee but you cannot get the strings pizza,  abaee, abacaba, aba?fee, aba47ee, or abatree.Recall that a palindrome is a string that reads the same from left to right as from right to left.[SOURCE CODE]import sys;input=sys.stdin.readline\r\nm,mod=18,998244353\r\nch={chr(i+ord('a')):i for i in range(m)}\r\nn,s=int(input()),' '+input();tot=s.count('?')\r\npo=[[1]*(n+1) for i in range(m)]\r\nfor i in range(1,m):\r\n  for j in range(1,n+1):\r\n    po[i][j]=po[i][j-1]*i%mod\r\na=[[0]*(1<<m) for _ in range(m)]\r\nfor mid in range(1,n+1):\r\n  for d in range(2):\r\n    cnt=use=msk=0;l,r=mid,mid+d\r\n    while l>=1 and r<=n and (s[l]==s[r] or s[l]=='?' or s[r]=='?'):\r\n      if s[l]=='?' and s[r]=='?':cnt+=1\r\n      elif s[l]=='?':msk|=1<<ch[s[r]]\r\n      elif s[r]=='?':msk|=1<<ch[s[l]]\r\n      use+=sum(1 for j in {l,r} if s[j]=='?')\r\n      for i in range(1,m):\r\n        a[i][msk]=(a[i][msk]+po[i][cnt+tot-use])%mod\r\n      l-=1;r+=1\r\nfor i in range(1,m):\r\n  for j in range(m):\r\n    for msk in range(1<<m):\r\n      if msk&(1<<j):\r\n        a[i][msk]=(a[i][msk]+a[i][msk^(1<<j)])%mod\r\n\r\nfor _ in range(int(input())):\r\n  t=input()[:-1]\r\n  print(a[len(t)][sum(1<<ch[c] for c in t)])","tags":["strings"],"src_uid":"1f13db0d8dcd292b55f49077b840e950"}
{"text_full":"[DESCRIPTION]Timur has a stairway with $$$n$$$ steps. The $$$i$$$-th step is $$$a_i$$$ meters higher than its predecessor. The first step is $$$a_1$$$ meters higher than the ground, and the ground starts at $$$0$$$ meters.   The stairs for the first test case. Timur has $$$q$$$ questions, each denoted by an integer $$$k_1, \\dots, k_q$$$. For each question $$$k_i$$$, you have to print the maximum possible height Timur can achieve by climbing the steps if his legs are of length $$$k_i$$$. Timur can only climb the $$$j$$$-th step if his legs are of length at least $$$a_j$$$. In other words, $$$k_i \\geq a_j$$$ for each step $$$j$$$ climbed.Note that you should answer each question independently.[SOURCE CODE]t = int(input())\r\n\r\nfor _ in range(t):\r\n    nq = [int(x) for x in input().split()]\r\n    nnum, qnum = nq[0], nq[1]\r\n    \r\n    n = [int(x) for x in input().split()]\r\n    q = [int(x) for x in input().split()]\r\n    \r\n    qv = []\r\n    for i in range(qnum):\r\n        qv.append([q[i], i])\r\n        \r\n    qv.sort()\r\n    \r\n    retsum = 0\r\n    j = 0\r\n    ans = [0]*qnum\r\n    for i in range(qnum):\r\n        k, index = qv[i][0], qv[i][1]\r\n        while (j < nnum and n[j] <= k):\r\n            retsum += n[j]\r\n            j += 1\r\n        ans[index] = retsum\r\n        \r\n    print(*ans)","tags":["math"],"src_uid":"d5f7228d8d674b8233937702ca044cb0"}
{"text_full":"[DESCRIPTION]Alperen has two strings, $$$s$$$ and $$$t$$$ which are both initially equal to \"a\". He will perform $$$q$$$ operations of two types on the given strings:  $$$1 \\;\\; k \\;\\; x$$$ — Append the string $$$x$$$ exactly $$$k$$$ times at the end of string $$$s$$$. In other words, $$$s := s + \\underbrace{x + \\dots + x}_{k \\text{ times}}$$$.  $$$2 \\;\\; k \\;\\; x$$$ — Append the string $$$x$$$ exactly $$$k$$$ times at the end of string $$$t$$$. In other words, $$$t := t + \\underbrace{x + \\dots + x}_{k \\text{ times}}$$$. After each operation, determine if it is possible to rearrange the characters of $$$s$$$ and $$$t$$$ such that $$$s$$$ is lexicographically smaller$$$^{\\dagger}$$$ than $$$t$$$.Note that the strings change after performing each operation and don't go back to their initial states.$$$^{\\dagger}$$$ Simply speaking, the lexicographical order is the order in which words are listed in a dictionary. A formal definition is as follows: string $$$p$$$ is lexicographically smaller than string $$$q$$$ if there exists a position $$$i$$$ such that $$$p_i &lt; q_i$$$, and for all $$$j &lt; i$$$, $$$p_j = q_j$$$. If no such $$$i$$$ exists, then $$$p$$$ is lexicographically smaller than $$$q$$$ if the length of $$$p$$$ is less than the length of $$$q$$$. For example, $$$\\texttt{abdc} &lt; \\texttt{abe}$$$ and $$$\\texttt{abc} &lt; \\texttt{abcd}$$$, where we write $$$p &lt; q$$$ if $$$p$$$ is lexicographically smaller than $$$q$$$.[SOURCE CODE]t = int(input())\r\nfor _ in range(t):\r\n    q = int(input())\r\n\r\n    s_a_count = 1\r\n    t_a_count = 1\r\n\r\n    other_than_a_t = False\r\n    other_than_a_s = False\r\n\r\n    for _ in range(q):\r\n        line = list(map(str, input().rstrip().split()))\r\n\r\n        if line[0] == '2':\r\n            for char in line[2]:\r\n                if char != 'a':\r\n                    other_than_a_t = True\r\n                    break\r\n                else:\r\n                    t_a_count += int(line[1])\r\n        else:\r\n            for char in line[2]:\r\n                if char != 'a':\r\n                    other_than_a_s = True\r\n                else:\r\n                    s_a_count += int(line[1])\r\n\r\n        print('YES' if other_than_a_t or (not other_than_a_s and s_a_count < t_a_count) else 'NO')","tags":["strings"],"src_uid":"d40f0f3b577a1a5cfad2a657d6a1b90a"}
{"text_full":"[DESCRIPTION]You are given an array consisting of all integers from $$$[l, r]$$$ inclusive. For example, if $$$l = 2$$$ and $$$r = 5$$$, the array would be $$$[2, 3, 4, 5]$$$. What's the minimum number of elements you can delete to make the bitwise AND of the array non-zero?A bitwise AND is a binary operation that takes two equal-length binary representations and performs the AND operation on each pair of the corresponding bits.[SOURCE CODE]psum = [[0] * 18 for _ in range(2 * 10 ** 5 + 1)]\r\nfor i in range(1, 2 * 10 ** 5 + 1):\r\n    for j in range(18):\r\n        psum[i][j] = psum[i - 1][j] + ((i >> j) & 1)  # The reason for &1 is to use only the significant bit.\r\n\r\n\r\ntc = int(input())\r\nfor _ in range(tc):\r\n    L, R = map(int, input().split())\r\n\r\n    max_value = 0\r\n    for i in range(18):\r\n        max_value = max(max_value, psum[R][i] - psum[L - 1][i])\r\n\r\n    print((R - L + 1) - max_value)","tags":["math"],"src_uid":"0601e3636b5d5b6ad0c8c1abb7f83d82"}
{"text_full":"[DESCRIPTION]'Twas the night before Christmas, and Santa's frantically setting up his new Christmas tree! There are $$$n$$$ nodes in the tree, connected by $$$n-1$$$ edges. On each edge of the tree, there's a set of Christmas lights, which can be represented by an integer in binary representation.  He has $$$m$$$ elves come over and admire his tree. Each elf is assigned two nodes, $$$a$$$ and $$$b$$$, and that elf looks at all lights on the simple path between the two nodes. After this, the elf's favorite number becomes the bitwise XOR of the values of the lights on the edges in that path.However, the North Pole has been recovering from a nasty bout of flu. Because of this, Santa forgot some of the configurations of lights he had put on the tree, and he has already left the North Pole! Fortunately, the elves came to the rescue, and each one told Santa what pair of nodes he was assigned $$$(a_i, b_i)$$$, as well as the parity of the number of set bits in his favorite number. In other words, he remembers whether the number of $$$1$$$'s when his favorite number is written in binary is odd or even.Help Santa determine if it's possible that the memories are consistent, and if it is, remember what his tree looked like, and maybe you'll go down in history![SOURCE CODE]from sys import stdin, stdout\r\nfrom collections import deque\r\n\r\ndef parity(n):\r\n    parity = 0\r\n    while n:\r\n        parity = 1-parity\r\n        n = n & (n-1)\r\n    return parity\r\n\r\nt = int(stdin.readline())\r\n\r\nfor _ in range(t):\r\n    n, m = [int(x) for x in stdin.readline().split()]\r\n    edges = []\r\n    fake_edges = {i: [] for i in range(n)}\r\n    possible = True\r\n\r\n    for bar in range(n-1):\r\n        x, y, v = [int(z) for z in stdin.readline().split()]\r\n        x -= 1\r\n        y -= 1\r\n        edges.append((x,y,v))\r\n        if v >= 0:\r\n            p = parity(v)\r\n            fake_edges[x].append((y,p))\r\n            fake_edges[y].append((x,p))\r\n\r\n    for bar in range(m):\r\n        x, y, v = [int(z) for z in stdin.readline().split()]\r\n        x -= 1\r\n        y -= 1\r\n        fake_edges[x].append((y,v))\r\n        fake_edges[y].append((x,v))\r\n\r\n    r_values = [-1]*n\r\n    touched = [False]*n\r\n\r\n    for i in range(n):\r\n        if not possible:\r\n            break\r\n        if not touched[i]:\r\n            queue = deque()\r\n            queue.append(i)\r\n            r_values[i] = 0\r\n            touched[i] = True\r\n\r\n            while len(queue) > 0:\r\n                if not possible:\r\n                    break\r\n                v = queue.popleft()\r\n                for w,p in fake_edges[v]:\r\n                    if r_values[w] == -1:\r\n                        r_values[w] = r_values[v] ^ p\r\n                        touched[w] = True\r\n                        queue.append(w)\r\n                    else:\r\n                        if r_values[w] != r_values[v] ^ p:\r\n                            possible = False\r\n                            break\r\n\r\n    if possible:\r\n        stdout.write('YES\\n')\r\n        for v, w, new_temp in edges:\r\n            if new_temp == -1:\r\n                new_temp = r_values[v] ^ r_values[w]\r\n            stdout.write('{} {} {}\\n'.format(v+1,w+1,new_temp))\r\n\r\n    else:\r\n        stdout.write('NO\\n')","tags":["graphs","trees"],"src_uid":"884e547e8ccb05e618ec80904b2ea107"}
{"text_full":"[DESCRIPTION]Mark has just purchased a rack of $$$n$$$ lightbulbs. The state of the lightbulbs can be described with binary string $$$s = s_1s_2\\dots s_n$$$, where $$$s_i=\\texttt{1}$$$ means that the $$$i$$$-th lightbulb is turned on, while $$$s_i=\\texttt{0}$$$ means that the $$$i$$$-th lightbulb is turned off.Unfortunately, the lightbulbs are broken, and the only operation he can perform to change the state of the lightbulbs is the following:  Select an index $$$i$$$ from $$$2,3,\\dots,n-1$$$ such that $$$s_{i-1}\\ne s_{i+1}$$$.  Toggle $$$s_i$$$. Namely, if $$$s_i$$$ is $$$\\texttt{0}$$$, set $$$s_i$$$ to $$$\\texttt{1}$$$ or vice versa. Mark wants the state of the lightbulbs to be another binary string $$$t$$$. Help Mark determine the minimum number of operations to do so.[SOURCE CODE]import sys\r\nfrom array import array\r\n\r\ninput = lambda: sys.stdin.buffer.readline().decode().strip()\r\nout = []\r\n\r\nfor _ in range(int(input())):\r\n    n, ans = int(input()), 0\r\n    s = array('b', [int(x) for x in input()])\r\n    t = array('b', [int(x) for x in input()])\r\n    sxor = array('b', [s[i] ^ s[i - 1] for i in range(1, n)])\r\n    txor = array('b', [t[i] ^ t[i - 1] for i in range(1, n)])\r\n\r\n    if s[0] != t[0] or s[-1] != t[-1] or sum(sxor) != sum(txor):\r\n        out.append(-1)\r\n    else:\r\n        for i in range(n - 2, -1, -1):\r\n            if sxor[i] == 0:\r\n                while txor[-1]:\r\n                    txor.pop()\r\n\r\n                txor.pop()\r\n                ans += abs(i - len(txor))\r\n        out.append(ans)\r\nprint('\\n'.join(map(str, out)))","tags":["math"],"src_uid":"b540db49c0a509e3807e06397cf74aa8"}
{"text_full":"[DESCRIPTION]This is an interactive problem. The only difference between the easy and hard version is the limit on number of questions.There are $$$n$$$ players labelled from $$$1$$$ to $$$n$$$. It is guaranteed that $$$n$$$ is a multiple of $$$3$$$.Among them, there are $$$k$$$ impostors and $$$n-k$$$ crewmates. The number of impostors, $$$k$$$, is not given to you. It is guaranteed that $$$\\frac{n}{3} &lt; k &lt; \\frac{2n}{3}$$$.In each question, you can choose three distinct integers $$$a$$$, $$$b$$$, $$$c$$$ ($$$1 \\le a, b, c \\le n$$$) and ask: \"Among the players labelled $$$a$$$, $$$b$$$ and $$$c$$$, are there more impostors or more crewmates?\" You will be given the integer $$$0$$$ if there are more impostors than crewmates, and $$$1$$$ otherwise.Find the number of impostors $$$k$$$ and the indices of players that are impostors after asking at most $$$n+6$$$ questions.The jury is adaptive, which means the indices of impostors may not be fixed beforehand and can depend on your questions. It is guaranteed that there is at least one set of impostors which fulfills the constraints and the answers to your questions at any time.[SOURCE CODE]def ask(a, b, c):\r\n    print(f'? {a} {b} {c}', flush=True)\r\n    s = input()\r\n    if s == '-1':\r\n        exit()\r\n    else:\r\n        return int(s)\r\n\r\nfor _ in range(int(input())):\r\n    n = int(input())\r\n    ans = [0]*n\r\n    fp = [0]*2\r\n    sp = [0]*2\r\n    tp = [0]*2\r\n    fop= [0]*2\r\n    fp[0]= ['0000', '0010', '0100', '1000', '0001', '0011', '0101', '1001' ]\r\n    fp[1] = ['1111', '1101', '1011', '0111', '1110', '1100', '1010', '0110']\r\n    sp[0] = ['0000', '0010', '0100', '0110', '0001', '0011', '1000', '1010']\r\n    sp[1] = ['1111', '1101', '1011', '1001', '1110', '1100', '0111', '0101']\r\n    tp[0] = ['0000', '1000', '0100', '1100', '0010', '1010', '0001', '1001']\r\n    tp[1] = ['1111', '0111', '1011', '0011', '1101', '0101', '1110', '0110']\r\n    fop[0] = ['0000', '0100', '1000', '1100', '0010', '0110', '0001', '0101']\r\n    fop[1] = ['1111', '1011', '0111', '0011', '1101', '1001', '1110', '1010']\r\n    m = ask(1, 2, 3)\r\n    for k in range(1,n\/\/3):\r\n        i = 3*k\r\n        tmp = ask(i + 1, i + 2, i + 3)\r\n        if tmp!= m:\r\n            break\r\n    if tmp == 1:\r\n        r = tp[1]\r\n        j = 3*(k-1)\r\n        p = fp[ask(j + 1, i + 1, i + 2)]\r\n        q = sp[ask(j + 1, i + 1, i + 3)]\r\n        s = fop[ask(j + 1, i + 2, i + 3)]\r\n        x =  list(((set(p)&set(q)) & set(r)) & set(s))\r\n        if len(x) == 1:\r\n            ans[j] = '0'\r\n            ans[i:i+3] = list(x[0])[1:]\r\n            zeropos = j+1\r\n            onepos = i+ list(x[0]).index('1')\r\n        else:\r\n            p = fp[ask(j + 2, i + 1, i + 2)]\r\n            q = sp[ask(j + 2, i + 1, i + 3)]\r\n            s = fop[ask(j + 2, i + 2, i + 3)]\r\n            x = list(((set(p) & set(q)) & set(r)) & set(s))\r\n            if len(x) == 1:\r\n                ans[j+1] = '0'\r\n                ans[i:i + 3] = list(x[0])[1:]\r\n                zeropos = j + 2\r\n                onepos = i + list(x[0]).index('1')\r\n            else:\r\n                ans[i:i+3] = list('111')\r\n                onepos = i + 1\r\n                t = ask(j+1, j+2, onepos)\r\n                if  t== 0:\r\n                    ans[j] = '0'\r\n                    ans[j+1] = '0'\r\n                    zeropos = j+1\r\n                else:\r\n                    ans[j+2] = '0'\r\n                    zeropos = j+3\r\n        for z in range(j+1,j+4):\r\n            if z!= zeropos:\r\n                ans[z-1] = str(ask(z, zeropos, onepos))\r\n        for c in range(0,k-1):\r\n            d = 3*c\r\n            b = ask(d+1, d+2, onepos)\r\n            if b == 0:\r\n                ans[d] = '0'\r\n                ans[d+1] = '0'\r\n                ans[d+2] = str(ask(zeropos, d + 3, onepos))\r\n            else:\r\n                ans[d+2] = '0'\r\n                ans[d + 1] = str(ask(d + 2, zeropos, onepos))\r\n                ans[d] = str(1- int(ans[d+1]))\r\n    else:\r\n        r = tp[0]\r\n        j = 3 * (k - 1)\r\n        p = fp[ask(j + 1, i + 1, i + 2)]\r\n        q = sp[ask(j + 1, i + 1, i + 3)]\r\n        s = fop[ask(j + 1, i + 2, i + 3)]\r\n        x = list(((set(p) & set(q)) & set(r)) & set(s))\r\n        if len(x) == 1:\r\n            ans[j] = '1'\r\n            ans[i :i + 3] = list(x[0])[1:]\r\n            onepos = j + 1\r\n            zeropos = i  + list(x[0]).index('0')\r\n        else:\r\n            p = fp[ask(j + 2, i + 1, i + 2)]\r\n            q = sp[ask(j + 2, i + 1, i + 3)]\r\n            s = fop[ask(j + 2, i + 2, i + 3)]\r\n            x = list(((set(p) & set(q)) & set(r)) & set(s))\r\n            if len(x) == 1:\r\n                ans[j + 1] = '1'\r\n                ans[i :i + 3] = list(x[0][1:])\r\n                onepos = j + 2\r\n                zeropos = i + list(x[0]).index('0')\r\n            else:\r\n                ans[i :i + 3] = list('000')\r\n                zeropos = i + 1\r\n                t = ask(j + 1, j + 2, zeropos)\r\n                if t == 1:\r\n                    ans[j] = '1'\r\n                    ans[j + 1] = '1'\r\n                    onepos = j + 1\r\n                else:\r\n                    ans[j + 2] = '1'\r\n                    onepos = j + 3\r\n\r\n        for z in range(j+1,j+4):\r\n            if z!= onepos:\r\n                ans[z-1] = str(ask(z, zeropos, onepos))\r\n\r\n        for c in range(0,k-1):\r\n            d = 3*c\r\n            b = str(ask(d+1, d+2, zeropos))\r\n            if b == '1':\r\n                ans[d] = '1'\r\n                ans[d+1] = '1'\r\n                ans[d+2] = str(ask(d + 3, zeropos, onepos))\r\n            else:\r\n                ans[d+2] = '1'\r\n                ans[d + 1] = str(ask(d + 2, zeropos, onepos))\r\n                ans[d] = str(1- int(ans[d+1]))\r\n\r\n    for l in range(i+4,n+1):\r\n        ans[l - 1] = str(ask(l, zeropos, onepos))\r\n    #print(ans)\r\n    indans = [str(i+1) for i in range(n) if ans[i] == '0']\r\n    fans = '! '+str(len(indans)) + ' ' + ' '.join(indans)\r\n    print(fans, flush=True)","tags":["math"],"src_uid":"98c584b0479eb26d8b0307bd72fc48fd"}
{"text_full":"[DESCRIPTION]You are given an array $$$a$$$ of length $$$n$$$, and an integer $$$x$$$. You can perform the following operation as many times as you would like (possibly zero): replace two adjacent elements of the array by their sum. For example, if the initial array was $$$[3, 6, 9]$$$, in a single operation one can replace the last two elements by their sum, yielding an array $$$[3, 15]$$$, or replace the first two elements to get an array $$$[9, 9]$$$. Note that the size of the array decreases after each operation.The beauty of an array $$$b=[b_1, \\ldots, b_k]$$$ is defined as $$$\\sum_{i=1}^k \\left\\lceil \\frac{b_i}{x} \\right\\rceil$$$, which means that we divide each element by $$$x$$$, round it up to the nearest integer, and sum up the resulting values. For example, if $$$x = 3$$$, and the array is $$$[4, 11, 6]$$$, the beauty of the array is equal to $$$\\left\\lceil \\frac{4}{3} \\right\\rceil + \\left\\lceil \\frac{11}{3} \\right\\rceil + \\left\\lceil \\frac{6}{3} \\right\\rceil = 2 + 4 + 2 = 8$$$.Please determine the minimum and the maximum beauty you can get by performing some operations on the original array.[SOURCE CODE]import math\r\nfor i in range(int(input())):\r\n    n,x=map(int,input().strip().split())\r\n    a=list(map(int,input().strip().split()))\r\n    c=sum(a)\r\n    z=math.ceil(c\/x)\r\n    g=0\r\n    h=[]\r\n    for j in range(len(a)):\r\n        g=g+math.ceil(a[j]\/x)\r\n    h.append(z)\r\n    h.append(g)\r\n    print(*h)","tags":["math","number theory"],"src_uid":"b36d7f840abe998185a988fe8dd2ec75"}
{"text_full":"[DESCRIPTION]You have given an array $$$a$$$ of length $$$n$$$ and an integer $$$x$$$ to a brand new robot. What the robot does is the following: it iterates over the elements of the array, let the current element be $$$q$$$. If $$$q$$$ is divisible by $$$x$$$, the robot adds $$$x$$$ copies of the integer $$$\\frac{q}{x}$$$ to the end of the array, and moves on to the next element. Note that the newly added elements could be processed by the robot later. Otherwise, if $$$q$$$ is not divisible by $$$x$$$, the robot shuts down.Please determine the sum of all values of the array at the end of the process.[SOURCE CODE]#######puzzleVerma#######\r\n \r\n \r\nimport sys\r\nimport math\r\nLI=lambda:[int(k) for k in input().split()]\r\ninput = lambda: sys.stdin.readline().rstrip()\r\nIN=lambda:int(input())\r\nS=lambda:input()\r\n \r\n \r\nfor i in range(IN()):\r\n    n,x=LI()\r\n    a=LI()\r\n    sm=sum(a)\r\n    ans=0\r\n    ndi=0\r\n    co=10**9\r\n    for i in range(n):\r\n        ele=a[i]\r\n        tco=1\r\n        while ele%x==0:\r\n            tco+=1\r\n            ele\/=x\r\n        if tco<co:\r\n            co=tco\r\n            ndi=i\r\n    ans+=sum(a[:ndi])\r\n    ans+=(sm*co)\r\n    print(ans)","tags":["math"],"src_uid":"09c8db43681d7bc72f83287897a62f3c"}
{"text_full":"[DESCRIPTION]You are given an integer $$$x$$$ and an array of integers $$$a_1, a_2, \\ldots, a_n$$$. You have to determine if the number $$$a_1! + a_2! + \\ldots + a_n!$$$ is divisible by $$$x!$$$.Here $$$k!$$$ is a factorial of $$$k$$$ — the product of all positive integers less than or equal to $$$k$$$. For example, $$$3! = 1 \\cdot 2 \\cdot 3 = 6$$$, and $$$5! = 1 \\cdot 2 \\cdot 3 \\cdot 4 \\cdot 5 = 120$$$.[SOURCE CODE]n,val=map(int,input().split())\r\nif val==1:\r\n    print('Yes')\r\nelse:\r\n    numeri=list(map(int,input().split())) \r\n    m=min(numeri)\r\n    occorrenze=[0]*(val-m+1)\r\n    for i in numeri:\r\n        occorrenze[i-m]=occorrenze[i-m]+1   \r\n    for j in range(len(occorrenze)-1):\r\n        if occorrenze[j]%(j+m+1)!=0:\r\n            print('No')\r\n            quit()\r\n        elif j<len(occorrenze)-1:\r\n            occorrenze[j+1]=occorrenze[j+1]+(occorrenze[j]\/\/(j+m+1))\r\n    print('Yes')","tags":["math","number theory"],"src_uid":"c5ec8b18c39720098f6ac2dbc0ddd4f4"}
{"text_full":"[DESCRIPTION]Andrew loves the sea. That's why, at the height of the summer season, he decided to go to the beach, taking a sunbed with him to sunbathe.The beach is a rectangular field with $$$n$$$ rows and $$$m$$$ columns. Some cells of the beach are free, some have roads, stones, shops and other non-movable objects. Some of two adjacent along the side cells can have sunbeds located either horizontally or vertically.Andrew hopes to put his sunbed somewhere, but that's a bad luck, there may no longer be free places for him! That's why Andrew asked you to help him to find a free place for his sunbed. Andrew's sunbed also should be places on two adjacent cells. If there are no two adjacent free cells, then in order to free some place for a sunbed, you will have to disturb other tourists. You can do the following actions:  Come to some sunbed and, after causing $$$p$$$ units of discomfort to its owner, lift the sunbed by one of its sides and rotate it by $$$90$$$ degrees. One half of the sunbed must remain in the same cell and another half of the sunbed must move to the free cell. At the same time, anything could be on the way of a sunbed during the rotation .   Rotation of the sunbed by $$$90$$$ degrees around cell $$$(1, 2)$$$.  Come to some sunbed and, after causing $$$q$$$ units of discomfort to its owner, shift the sunbed along its long side by one cell. One half of the sunbed must move to the place of another, and another — to the free cell.   Shift of the sunbed by one cell to the right. In any moment each sunbed occupies two adjacent free cells. You cannot move more than one sunbed at a time.Help Andrew to free a space for his sunbed, causing the minimum possible number of units of discomfort to other tourists, or detect that it is impossible.[SOURCE CODE]import heapq\r\nimport sys, os, io\r\ninput = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\r\n \r\ndef f(u, v):\r\n    return u * m + v\r\n \r\ndef dijkstra():\r\n    dist = [inf] * l\r\n    visit = [0] * l\r\n    h = []\r\n    for i in range(n):\r\n        si = s[i]\r\n        for j in range(m):\r\n            if si[j] == 46:\r\n                u = f(i, j)\r\n                dist[u] = 0\r\n                heapq.heappush(h, (dist[u], u))\r\n    while h:\r\n        d, u = heapq.heappop(h)\r\n        if dist[u] < d:\r\n            continue\r\n        visit[u] = 1\r\n        for v in G[u]:\r\n            c = q if u \/\/ m == v \/\/ m or not (u - v) % m else p\r\n            nd = dist[u] + c\r\n            if not visit[v] and nd < dist[v]:\r\n                dist[v] = nd\r\n                heapq.heappush(h, (dist[v], v))\r\n    return dist\r\n \r\nn, m = map(int, input().split())\r\np, q = map(int, input().split())\r\ns = [list(input().rstrip()) for _ in range(n)]\r\nl = n * m\r\nG = [[] for _ in range(l)]\r\nv = [(1, 0), (-1, 0), (0, 1), (0, -1)]\r\nfor i in range(n):\r\n    si = s[i]\r\n    for j in range(m):\r\n        if si[j] == 76:\r\n            x, y = f(i, j), f(i, j + 1)\r\n            for k in range(2):\r\n                for di, dj in v:\r\n                    ni, nj = i + di, j + k + dj\r\n                    if not 0 <= ni < n or not 0 <= nj < m:\r\n                        continue\r\n                    z = f(ni, nj)\r\n                    if x == z or y == z or s[ni][nj] == 35:\r\n                        continue\r\n                    if not k:\r\n                        G[z].append(y)\r\n                    else:\r\n                        G[z].append(x)\r\n        elif si[j] == 85:\r\n            x, y = f(i, j), f(i + 1, j)\r\n            for k in range(2):\r\n                for di, dj in v:\r\n                    ni, nj = i + k + di, j + dj\r\n                    if not 0 <= ni < n or not 0 <= nj < m:\r\n                        continue\r\n                    z = f(ni, nj)\r\n                    if x == z or y == z or s[ni][nj] == 35:\r\n                        continue\r\n                    if not k:\r\n                        G[z].append(y)\r\n                    else:\r\n                        G[z].append(x)\r\ninf = pow(10, 15) + 1\r\ndist = dijkstra()\r\nans = inf\r\nfor i in range(n):\r\n    for j in range(m - 1):\r\n        ans = min(ans, dist[f(i, j)] + dist[f(i, j + 1)])\r\nfor i in range(n - 1):\r\n    for j in range(m):\r\n        ans = min(ans, dist[f(i, j)] + dist[f(i + 1, j)])\r\nans = (ans + 1) % (inf + 1) - 1\r\nprint(ans)","tags":["graphs"],"src_uid":"35b9acbe61226923a0c45452f23166c8"}
{"text_full":"[DESCRIPTION]You are given a binary array $$$a$$$ (all elements of the array are $$$0$$$ or $$$1$$$) of length $$$n$$$. You wish to sort this array, but unfortunately, your algorithms teacher forgot to teach you sorting algorithms. You perform the following operations until $$$a$$$ is sorted:  Choose two random indices $$$i$$$ and $$$j$$$ such that $$$i &lt; j$$$. Indices are chosen equally probable among all pairs of indices $$$(i, j)$$$ such that $$$1 \\le i &lt; j \\le n$$$.  If $$$a_i &gt; a_j$$$, then swap elements $$$a_i$$$ and $$$a_j$$$. What is the expected number of such operations you will perform before the array becomes sorted?It can be shown that the answer can be expressed as an irreducible fraction $$$\\frac{p}{q}$$$, where $$$p$$$ and $$$q$$$ are integers and $$$q \\not \\equiv 0 \\pmod{998\\,244\\,353}$$$. Output the integer equal to $$$p \\cdot q^{-1} \\bmod 998\\,244\\,353$$$. In other words, output such an integer $$$x$$$ that $$$0 \\le x &lt; 998\\,244\\,353$$$ and $$$x \\cdot q \\equiv p \\pmod{998\\,244\\,353}$$$.[SOURCE CODE]for _ in range(int(input())):\r\n    n = int(input())\r\n    a = [int(x) for x in input().split()]\r\n    zeros = n - sum(a)\r\n    ones = sum(a[:zeros])\r\n    rv = n * (n - 1) \/\/ 2 * sum(pow(i, -2, 998244353) for i in range(1, ones + 1)) % 998244353\r\n    print(rv)","tags":["math","probabilities"],"src_uid":"2b391638a9fea31986fe8e41c97b640a"}
{"text_full":"[DESCRIPTION]This is an interactive problem.Alice and Bob are playing a game. There is $$$n\\times n$$$ grid, initially empty. We refer to the cell in row $$$i$$$ and column $$$j$$$ by $$$(i, j)$$$ for $$$1\\le i, j\\le n$$$. There is an infinite supply of tokens that come in $$$3$$$ colors labelled $$$1$$$, $$$2$$$, and $$$3$$$.The game proceeds with turns as follows. Each turn begins with Alice naming one of the three colors, let's call it $$$a$$$. Then, Bob chooses a color $$$b\\ne a$$$, chooses an empty cell, and places a token of color $$$b$$$ on that cell.We say that there is a conflict if there exist two adjacent cells containing tokens of the same color. Two cells are considered adjacent if they share a common edge.If at any moment there is a conflict, Alice wins. Otherwise, if $$$n^2$$$ turns are completed (so that the grid becomes full) without any conflicts, Bob wins.We have a proof that Bob has a winning strategy. Play the game as Bob and win.The interactor is adaptive. That is, Alice's color choices can depend on Bob's previous moves.[SOURCE CODE]n=int(input())\r\nblack=[]\r\nwhite=[]\r\nfor i in range(1,n+1):\r\n    for j in range(1,n+1):\r\n        if (i+j)%2:\r\n            white.append((i,j))\r\n        else:\r\n            black.append((i,j))\r\nmove=0\r\nwhile move<n**2:\r\n    p=int(input())\r\n    move+=1\r\n    if p==1:\r\n        if black:\r\n            x,y=black.pop()\r\n            print(2,x,y)\r\n        else :\r\n            x,y=white.pop()\r\n            print(3,x,y)\r\n    elif p==2:\r\n        if white:\r\n            x,y=white.pop()\r\n            print(1,x,y)\r\n        else :\r\n            x,y=black.pop()\r\n            print(3,x,y)\r\n    else :\r\n        if black:\r\n            x,y=black.pop()\r\n            print(2,x,y)\r\n        else:\r\n            x,y=white.pop()\r\n            print(1,x,y)","tags":["games","graphs"],"src_uid":"7c721cdb8e5709bba242957344851d48"}
{"text_full":"[DESCRIPTION]You are wandering in the explorer space of the 2050 Conference.The explorer space can be viewed as an undirected weighted grid graph with size $$$n\\times m$$$. The set of vertices is $$$\\{(i, j)|1\\le i\\le n, 1\\le j\\le m\\}$$$. Two vertices $$$(i_1,j_1)$$$ and $$$(i_2, j_2)$$$ are connected by an edge if and only if $$$|i_1-i_2|+|j_1-j_2|=1$$$.At each step, you can walk to any vertex connected by an edge with your current vertex. On each edge, there are some number of exhibits. Since you already know all the exhibits, whenever you go through an edge containing $$$x$$$ exhibits, your boredness increases by $$$x$$$.For each starting vertex $$$(i, j)$$$, please answer the following question: What is the minimum possible boredness if you walk from $$$(i, j)$$$ and go back to it after exactly $$$k$$$ steps?You can use any edge for multiple times but the boredness on those edges are also counted for multiple times. At each step, you cannot stay on your current vertex. You also cannot change direction while going through an edge. Before going back to your starting vertex $$$(i, j)$$$ after $$$k$$$ steps, you can visit $$$(i, j)$$$ (or not) freely.[SOURCE CODE]def roll(i,j):\r\n    ways = []\r\n    if j:\r\n        ways.append( 2 * horizontal[i][j-1] + grid[i][j-1])\r\n    if m-1-j:\r\n        ways.append(2 * horizontal[i][j] + grid[i][j+1])\r\n    if i:\r\n        ways.append(2 * vertical[i-1][j] + grid[i-1][j])\r\n    if n-1-i:\r\n        ways.append(2 * vertical[i][j] + grid[i+1][j])\r\n    return min(ways)\r\n \r\nn , m , k = map(int, input().split())\r\n\r\nhorizontal = [list(map(int, input().split())) for _ in range(n)]\r\nvertical = [list(map(int, input().split())) for _ in range(n-1)]\r\n \r\n \r\ngrid = [[0]*m for _ in range(n)]\r\nif k%2:\r\n    for _ in range(n):\r\n        print(\" \".join([\"-1\"]*m))\r\nelse:\r\n    for _ in range(k\/\/2):\r\n        new_grid = [[roll(i,j) for j in range(m)] for i in range(n)]\r\n        grid = new_grid[:]\r\n    for i in range(n):\r\n        print(\" \".join(map(str,grid[i])))","tags":["graphs"],"src_uid":"7b13ee633c81abdcf912542ba1779a45"}
{"text_full":"[DESCRIPTION]Everyone was happy coding, until suddenly a power shortage happened and the best competitive programming site went down. Fortunately, a system administrator bought some new equipment recently, including some UPSs. Thus there are some servers that are still online, but we need all of them to be working in order to keep the round rated.Imagine the servers being a binary string $$$s$$$ of length $$$n$$$. If the $$$i$$$-th server is online, then $$$s_i = 1$$$, and $$$s_i = 0$$$ otherwise.A system administrator can do the following operation called electricity spread, that consists of the following phases:   Select two servers at positions $$$1 \\le i &lt; j \\le n$$$ such that both are online (i.e. $$$s_i=s_j=1$$$). The spread starts only from online servers.  Check if we have enough power to make the spread. We consider having enough power if the number of turned on servers in range $$$[i, j]$$$ is at least the number of turned off servers in range $$$[i, j]$$$. More formally, check whether $$$2 \\cdot (s_i + s_{i+1} + \\ldots + s_j) \\ge j - i + 1$$$. If the check is positive, turn on all the offline servers in range $$$[i, j]$$$. More formally, make $$$s_k := 1$$$ for all $$$k$$$ from $$$i$$$ to $$$j$$$. We call a binary string $$$s$$$ of length $$$n$$$ rated if we can turn on all servers (i.e. make $$$s_i = 1$$$ for $$$1 \\le i \\le n$$$) using the electricity spread operation any number of times (possibly, $$$0$$$). Your task is to find the number of rated strings of length $$$n$$$ modulo $$$m$$$.[SOURCE CODE]n, m = map(int, input().split())\r\n\r\ndef modmul(a, b, c = 0):\r\n    return (a * b + c) % m\r\n\r\nhalf = [0, 0, 1] + [0] * (3 * n)\r\npref = [0, 0, 1] + [0] * (3 * n)\r\ngood = [-1, 1]\r\nbad =  [-1, 0]\r\n\r\nfor i in range(2, n + 1):\r\n    nb = 0\r\n    \r\n    for j in range(1, i):\r\n        prev = i - 2 * j - 1\r\n        if prev < 0:\r\n            continue\r\n\r\n        add = modmul(pref[prev], good[j])\r\n        nb += add\r\n\r\n        half[j + i] += add\r\n        half[j + i] %= m\r\n\r\n    pref[i] = (pref[i - 1] + half[i]) % m\r\n    nb %= m\r\n    \r\n    bad.append(nb)\r\n    tot = pow(2, i-2, m)\r\n    good.append((tot - nb) % m)\r\n\r\n    half[2 * i] += good[i]\r\nprint(good[n] % m)","tags":["math","strings"],"src_uid":"4840c4ddf8d9ca82c6e8fcf71802539a"}
{"text_full":"[DESCRIPTION]We call an array $$$a$$$ of length $$$n$$$ fancy if for each $$$1 &lt; i \\le n$$$ it holds that $$$a_i = a_{i-1} + 1$$$.Let's call $$$f(p)$$$ applied to a permutation$$$^\\dagger$$$ of length $$$n$$$ as the minimum number of subarrays it can be partitioned such that each one of them is fancy. For example $$$f([1,2,3]) = 1$$$, while $$$f([3,1,2]) = 2$$$ and $$$f([3,2,1]) = 3$$$.Given $$$n$$$ and a permutation $$$p$$$ of length $$$n$$$, we define a permutation $$$p'$$$ of length $$$n$$$ to be $$$k$$$-special if and only if:  $$$p'$$$ is lexicographically smaller$$$^\\ddagger$$$ than $$$p$$$, and  $$$f(p') = k$$$. Your task is to count for each $$$1 \\le k \\le n$$$ the number of $$$k$$$-special permutations modulo $$$m$$$.$$$^\\dagger$$$ A permutation is an array consisting of $$$n$$$ distinct integers from $$$1$$$ to $$$n$$$ in arbitrary order. For example, $$$[2,3,1,5,4]$$$ is a permutation, but $$$[1,2,2]$$$ is not a permutation ($$$2$$$ appears twice in the array) and $$$[1,3,4]$$$ is also not a permutation ($$$n=3$$$ but there is $$$4$$$ in the array).$$$^\\ddagger$$$ A permutation $$$a$$$ of length $$$n$$$ is lexicographically smaller than a permutation $$$b$$$ of length $$$n$$$ if and only if the following holds: in the first position where $$$a$$$ and $$$b$$$ differ, the permutation $$$a$$$ has a smaller element than the corresponding element in $$$b$$$.[SOURCE CODE]n, m = map(int, input().split())\r\n\r\ndef modmul(a, b, c = 0):\r\n    return (a * b + c) % m\r\n\r\n\r\ncomb = [[1]]\r\nfor i in range(2010):\r\n    prev = comb[-1]\r\n    nex = [1]\r\n    for i in range(i):\r\n        nex.append((prev[i] + prev[i + 1]) % m)\r\n    nex.append(1)\r\n    comb.append(nex)\r\n\r\nfact = [1]\r\nfor i in range(1, 3000):\r\n    fact.append((i * fact[i - 1]) % m)\r\n\r\np = list(map(lambda x: int(x) - 1, input().split()))\r\nrem = [1] * n\r\npairs = n - 1\r\n\r\nbase = 0\r\n\r\nout = [[0] * (n + 1) for _ in range(n + 1)]\r\nfor i in range(n):\r\n    diff = [0] * 3\r\n    spec = [0] * 3\r\n\r\n    for j in range(p[i]):\r\n        d = 0\r\n\r\n        if rem[j] == 0:\r\n            continue\r\n        \r\n        if j and rem[j - 1]:\r\n            d += 1\r\n\r\n        #if j < n - 1 and rem[j + 1]:\r\n        #    d += 1\r\n\r\n        if i and j == p[i - 1] + 1:\r\n            spec[d] += 1\r\n        else:\r\n            diff[d] += 1\r\n\r\n    for d in range(3):\r\n        pp = pairs - d\r\n        if pp < 0:\r\n            continue\r\n        if diff[d] == 0 and spec[d] == 0:\r\n            continue\r\n\r\n        remain = n - i - 1\r\n\r\n        for sq in range(pp + 1):\r\n            ways = comb[pp][sq]\r\n            order = remain - sq\r\n            assert order >= 0\r\n\r\n            ct = modmul(ways, fact[order])\r\n            \r\n            out[base][sq] += modmul(ct, diff[d] + spec[d])\r\n            if spec[d]:\r\n                out[base][sq + 1] += ct\r\n\r\n    j = p[i]\r\n    rem[j] = 0\r\n    if j and rem[j - 1]:\r\n        pairs -= 1\r\n    if j < n - 1 and rem[j + 1]:\r\n        pairs -= 1\r\n\r\n    if i and p[i] == p[i - 1] + 1:\r\n        base += 1\r\n\r\nwhile len(out) > 1:\r\n    prev = out.pop()\r\n    for i in range(n):\r\n        out[-1][i] += prev[i]\r\n        if i > 0:\r\n            out[-1][i] += prev[i - 1]\r\n\r\nout = out[0]\r\n\r\nres = []\r\nfor i in range(n):\r\n    basee = out[n - 1 - i]\r\n    for j in range(i):\r\n        basee -= modmul(res[j], comb[n - j - 1][n - i - 1])\r\n        #print(i, j, basee)\r\n    res.append(basee % m)\r\nprint(' '.join(map(str, res)))","tags":["math"],"src_uid":"bc0089608493d9160eefb769e5c87475"}
{"text_full":"[DESCRIPTION]You are given the strings $$$a$$$ and $$$b$$$, consisting of lowercase Latin letters. You can do any number of the following operations in any order:   if $$$|a| &gt; 0$$$ (the length of the string $$$a$$$ is greater than zero), delete the first character of the string $$$a$$$, that is, replace $$$a$$$ with $$$a_2 a_3 \\ldots a_n$$$;  if $$$|a| &gt; 0$$$, delete the last character of the string $$$a$$$, that is, replace $$$a$$$ with $$$a_1 a_2 \\ldots a_{n-1}$$$;  if $$$|b| &gt; 0$$$ (the length of the string $$$b$$$ is greater than zero), delete the first character of the string $$$b$$$, that is, replace $$$b$$$ with $$$b_2 b_3 \\ldots b_n$$$;  if $$$|b| &gt; 0$$$, delete the last character of the string $$$b$$$, that is, replace $$$b$$$ with $$$b_1 b_2 \\ldots b_{n-1}$$$. Note that after each of the operations, the string $$$a$$$ or $$$b$$$ may become empty.For example, if $$$a=$$$\"hello\" and $$$b=$$$\"icpc\", then you can apply the following sequence of operations:   delete the first character of the string $$$a$$$ $$$\\Rightarrow$$$ $$$a=$$$\"ello\" and $$$b=$$$\"icpc\";  delete the first character of the string $$$b$$$ $$$\\Rightarrow$$$ $$$a=$$$\"ello\" and $$$b=$$$\"cpc\";  delete the first character of the string $$$b$$$ $$$\\Rightarrow$$$ $$$a=$$$\"ello\" and $$$b=$$$\"pc\";  delete the last character of the string $$$a$$$ $$$\\Rightarrow$$$ $$$a=$$$\"ell\" and $$$b=$$$\"pc\";  delete the last character of the string $$$b$$$ $$$\\Rightarrow$$$ $$$a=$$$\"ell\" and $$$b=$$$\"p\". For the given strings $$$a$$$ and $$$b$$$, find the minimum number of operations for which you can make the strings $$$a$$$ and $$$b$$$ equal. Note that empty strings are also equal.[SOURCE CODE]import sys\r\n\r\ndef stringComparator(a, b):\r\n    n = len(a)\r\n    m = len(b)\r\n    size = 0\r\n\r\n    for i in range(1, min(n,m) + 1):\r\n        for j in range(0, n - i + 1):\r\n            for k in range(0, m - i + 1):\r\n                if (a[j: j + i] == b[k: k + i]):\r\n                    size = max(size, i)\r\n\r\n    #print(\"final size:\",size)                \r\n    return((len(a) + len(b)) - (size * 2))\r\n    \r\n\r\nif __name__ == '__main__':\r\n    n = int(sys.stdin.readline())\r\n    arr = []\r\n    for i in range (0, n):\r\n        a = input()\r\n        b = input()\r\n        arr.append(stringComparator(a, b))\r\n    for i in range(0, len(arr)):\r\n        print(arr[i])","tags":["strings"],"src_uid":"36aec7a06c02052f562ea3d44d4a62e4"}
{"text_full":"[DESCRIPTION]You are given a string $$$s$$$, consisting of lowercase Latin letters. While there is at least one character in the string $$$s$$$ that is repeated at least twice, you perform the following operation:   you choose the index $$$i$$$ ($$$1 \\le i \\le |s|$$$) such that the character at position $$$i$$$ occurs at least two times in the string $$$s$$$, and delete the character at position $$$i$$$, that is, replace $$$s$$$ with $$$s_1 s_2 \\ldots s_{i-1} s_{i+1} s_{i+2} \\ldots s_n$$$. For example, if $$$s=$$$\"codeforces\", then you can apply the following sequence of operations:   $$$i=6 \\Rightarrow s=$$$\"codefrces\";  $$$i=1 \\Rightarrow s=$$$\"odefrces\";  $$$i=7 \\Rightarrow s=$$$\"odefrcs\"; Given a given string $$$s$$$, find the lexicographically maximum string that can be obtained after applying a certain sequence of operations after which all characters in the string become unique.A string $$$a$$$ of length $$$n$$$ is lexicographically less than a string $$$b$$$ of length $$$m$$$, if:   there is an index $$$i$$$ ($$$1 \\le i \\le \\min(n, m)$$$) such that the first $$$i-1$$$ characters of the strings $$$a$$$ and $$$b$$$ are the same, and the $$$i$$$-th character of the string $$$a$$$ is less than $$$i$$$-th character of string $$$b$$$;  or the first $$$\\min(n, m)$$$ characters in the strings $$$a$$$ and $$$b$$$ are the same and $$$n &lt; m$$$. For example, the string $$$a=$$$\"aezakmi\" is lexicographically less than the string $$$b=$$$\"aezus\".[SOURCE CODE]in1 = lambda : int(input())\r\nin2 = lambda : list(map(int, input().split()))\r\n#Solve\r\nimport math\r\n\r\ndef solve():\r\n    s = input()\r\n    #print(\"RES: \", end='')\r\n    n = len(s)\r\n    stack = []\r\n    seen = set()\r\n    d = {c : idx for idx, c in enumerate(s)}\r\n\r\n    for i in range(n):\r\n        if s[i] not in seen:\r\n            while stack and stack[-1] < s[i] and d[stack[-1]] > i:\r\n                seen.discard(stack.pop())\r\n            stack.append(s[i])\r\n            seen.add(s[i])\r\n    print(\"\".join(stack))\r\n        \r\nif __name__ == \"__main__\":\r\n    t = 1\r\n    t = in1()\r\n    for i in range(t):\r\n        solve()","tags":["strings"],"src_uid":"a30f6f5273fc6c02ac1f2bc2b0ee893e"}
{"text_full":"[DESCRIPTION]Authors have come up with the string $$$s$$$ consisting of $$$n$$$ lowercase Latin letters.You are given two permutations of its indices (not necessary equal) $$$p$$$ and $$$q$$$ (both of length $$$n$$$). Recall that the permutation is the array of length $$$n$$$ which contains each integer from $$$1$$$ to $$$n$$$ exactly once.For all $$$i$$$ from $$$1$$$ to $$$n-1$$$ the following properties hold: $$$s[p_i] \\le s[p_{i + 1}]$$$ and $$$s[q_i] \\le s[q_{i + 1}]$$$. It means that if you will write down all characters of $$$s$$$ in order of permutation indices, the resulting string will be sorted in the non-decreasing order.Your task is to restore any such string $$$s$$$ of length $$$n$$$ consisting of at least $$$k$$$ distinct lowercase Latin letters which suits the given permutations.If there are multiple answers, you can print any of them.[SOURCE CODE]# adapted some python code from https:\/\/www.geeksforgeeks.org\/strongly-connected-components\/\nfrom collections import defaultdict, deque\n   \n#This class represents a directed graph using adjacency list representation \nclass Graph: \n   \n    def __init__(self,vertices): \n        self.V= vertices #No. of vertices \n        self.graph = defaultdict(list) # default dictionary to store graph \n   \n    # function to add an edge to graph \n    def addEdge(self,u,v): \n        self.graph[u].append(v) \n   \n    # A function used by DFS \n    def DFSUtil(self,v,visited): \n        'generate all nodes in one partition'\n\n        answer = []\n\n        nodes_to_visit = deque()\n        nodes_to_visit.append(v)\n        while len(nodes_to_visit)>0:\n            v = nodes_to_visit.popleft()\n            # Mark the current node as visited and print it \n            visited[v]= True\n            answer.append(v)\n            #Recur for all the vertices adjacent to this vertex \n            for i in self.graph[v]: \n                if visited[i]==False: \n                    nodes_to_visit.appendleft(i)\n        return answer\n  \n  \n    def fillOrder(self,v,visited, stack): \n        # # Mark the current node as visited  \n        # visited[v]= True\n        # #Recur for all the vertices adjacent to this vertex \n        # for i in self.graph[v]: \n        #     if visited[i]==False: \n        #         self.fillOrder(i, visited, stack) \n        # stack = stack.append(v) \n\n\n        ext_stack = deque()\n        nodes = deque()\n        nodes.append(v)\n        while len(nodes)>0:\n            v = nodes.popleft()\n            visited[v]=True\n            for i in self.graph[v]:\n                if visited[i] == False:\n                    nodes.appendleft(i)\n            ext_stack.append(v)\n\n        while len(ext_stack)>0:\n            stack.append(ext_stack.pop())\n      \n  \n    # Function that returns reverse (or transpose) of this graph \n    def getTranspose(self): \n        g = Graph(self.V) \n  \n        # Recur for all the vertices adjacent to this vertex \n        for i in self.graph: \n            for j in self.graph[i]: \n                g.addEdge(j,i) \n        return g \n  \n   \n   \n    # The main function that finds and prints all strongly \n    # connected components \n    def printSCCs(self): \n        'generate all components of graph (generator of lists)'\n          \n        stack = [] \n        # Mark all the vertices as not visited (For first DFS) \n        visited =[False]*(self.V) \n        # Fill vertices in stack according to their finishing \n        # times \n        for i in range(self.V): \n            if visited[i]==False: \n                self.fillOrder(i, visited, stack) \n  \n        # Create a reversed graph \n        gr = self.getTranspose() \n           \n         # Mark all the vertices as not visited (For second DFS) \n        visited =[False]*(self.V) \n  \n         # Now process all vertices in order defined by Stack \n        while stack: \n             i = stack.pop() \n             if visited[i]==False: \n                yield list(gr.DFSUtil(i, visited))\n                \n\nn,k = map(int, raw_input().split())\np = [x-1 for x in map(int, raw_input().split())]\nq = [x-1 for x in map(int, raw_input().split())]\n\nimport sys\n\n# Create a graph given in the above diagram \ng = Graph(n)\nfor i in xrange(n-1):\n    g.addEdge(p[i], p[i+1]) \n    g.addEdge(q[i], q[i+1]) \n\ndef next_letter(letter):\n    if letter < 'z':\n        return chr(ord(letter)+1)\n    else:\n        return letter\n\npartition = sorted(map(sorted, list(g.printSCCs())))\ninverse = [None] * n\nfor i,part in enumerate(partition):\n    for j in part:\n        inverse[j] = i\n\nif len(partition) < k:\n    print 'NO'\nelse:\n    print 'YES'\n    answer = [None] * n\n    \n    # for eveyrthing in the component containing p[0], give it the letter 'a'\n    letter = 'a'\n    for u in xrange(n):\n        if answer[p[u]] is None:\n            i = inverse[p[u]]\n            for j in partition[i]:\n                answer[j] = letter\n            letter = next_letter(letter)\n\n    print ''.join(answer)","tags":["graphs","strings"],"src_uid":"591846c93bd221b732c4645e50fae617"}
{"text_full":"[DESCRIPTION]We are sum for we are manySome NumberThis version of the problem differs from the next one only in the constraint on $$$t$$$. You can make hacks only if both versions of the problem are solved.You are given two positive integers $$$l$$$ and $$$r$$$.Count the number of distinct triplets of integers $$$(i, j, k)$$$ such that $$$l \\le i &lt; j &lt; k \\le r$$$ and $$$\\operatorname{lcm}(i,j,k) \\ge i + j + k$$$.Here $$$\\operatorname{lcm}(i, j, k)$$$ denotes the least common multiple (LCM) of integers $$$i$$$, $$$j$$$, and $$$k$$$.[SOURCE CODE]import sys\r\ninput = sys.stdin.buffer.readline\r\n\r\n# from collections import defaultdict, deque, Counter\r\nfrom math import gcd, lcm\r\nfrom functools import reduce\r\n# from itertools import accumulate, chain, islice, starmap\r\n# from operator import add, sub, mul, floordiv, truediv\r\n\r\n\r\n# def f(L,R,tup):\r\n\r\ndef lcm3(tup):\r\n\ta,b,c = tup\r\n\tif c%b or c%a:\r\n\t\treturn 2*c\r\n\telse:\r\n\t\treturn c\r\n\r\n\r\ndef tup_gen(hi=2*10**5,a=1,b=1):\r\n\t# if a * b <= hi:\r\n\tyield (a,b)\r\n\t# k = 1\r\n\t# while a*k+b <= hi\/\/a:\r\n\tfor k in range(1, (hi\/\/a-b)\/\/a+1):\r\n\t\tfor i in tup_gen(hi, a*k+b, a):\r\n\t\t\tyield i\r\n\t\t# k+=1\r\n\r\n# s = set(tuple(sorted((b,a,a*b))) for (a,b) in tup_gen())\r\n# s.add((3,4,6))\r\n# s.add((6,10,15))\r\n\r\nma = 0\r\n\r\n\r\nfor _ in range(int(input())):\r\n\tL, R = map(int,input().split())\r\n\r\n\ttot = (R-L+1)*(R-L)*(R-L-1) \/\/ 6\r\n\t# ans = tot\r\n\ttmp = 0\r\n\t\r\n\t# s = set()\r\n\tif R > ma:\r\n\t\tma = R\r\n\t# s = set(tuple(sorted((b,a,a*b))) for (a,b) in tup_gen(R))\r\n\t# l = list(tuple(sorted((b,a,a*b))) for (a,b) in tup_gen(R))\r\n\t\tl = list(tup_gen(R))\r\n\t# s.add((3,4,6))\r\n\t# s.add((6,10,15))\r\n\r\n\t# for a, b in tup_gen(R, L, 1,1):\r\n\t# \t# cands = [(b,a,a*b),(2*b,a,a*b),(b,2*a,a*b),(2*b,2*a,a*b),(b,a,a*b*2),(2*b,a,a*b*2),(b,2*a,a*b*2),(2*b,2*a,a*b*2)]\r\n\t# \tcands = [(b,a,a*b),(2*b,a,a*b),(b,2*a,a*b),(2*b,2*a,a*b)]\r\n\t# \tfor cand in cands:\r\n\t# \t\tif not all(x%2==0 for x in cand):\r\n\t# \t\t\t# assert reduce(gcd,cand) < 2\r\n\t# \t\t\ts.add(tuple(sorted(cand)))\r\n\r\n\r\n\r\n\r\n\t# s2 = set()\r\n\r\n\tl2 = list()\r\n\r\n\t# for tup in s:\r\n\t# \ta,b,c=tup\r\n\t# \tc2 = 0\r\n\t# \tfor n in range(1,R\/\/c+1):\r\n\t# \t\tc2 += c\r\n\t# \t\tif a<b<c2:\r\n\t# \t\t\ttup2=(a,b,c2)\r\n\t# \t\t\tif lcm3(tup2) < sum(tup2) and not all(x%2==0 for x in tup2):# and tup2 not in s:\r\n\t# \t\t\t\t# if tup2 in s:\r\n\t# \t\t\t\t# \tprint(\"?????\",tup2,n)\r\n\t# \t\t\t\t# assert reduce(gcd,tup2) < 2\r\n\t# \t\t\t\ts2.add(tup2)\r\n\t# \t\t\t\t# l2.append(tup2)\r\n\t# \t\t\telif n > 1:\r\n\t# \t\t\t\tbreak\r\n\t# \t# s2.add(tup)\r\n\r\n\t# for tup in l:\r\n\t# for b,a in tup_gen(R):\r\n\tfor b,a in l:\r\n\t\t# a,b,c=tup\r\n\t\t# a,b=min(a,b),max(a,b)\r\n\t\tc = a*b\r\n\t\ttup = (a,b,c)\r\n\t\tsu=a+b+c\r\n\t\tif a<b<c:\r\n\t\t\tif lcm3(tup) < su:\r\n\t\t\t\t\t# assert reduce(gcd,tup) < 2\r\n\t\t\t\t\t# s2.add(tup)\r\n\t\t\t\t\t# l2.append(tup)\r\n\t\t\t\t\tlo,hi=(L+a-1)\/\/a, R\/\/c\r\n\t\t\t\t\tif lo <= hi:\r\n\t\t\t\t\t\ttmp += hi-lo+1\r\n\t\t\t# else:\r\n\t\t\t# \tbreak\r\n\t\t\r\n\t\tif a<b<=c:\r\n\t\t\tfor n in range(2,R\/\/c+1):\r\n\t\t\t\tsu+=c\r\n\t\t\t\ttup2=(a,b,c*n)\r\n\t\t\t\tif lcm3(tup2) < su:# and not all(x%2==0 for x in tup2):# and tup2 not in s:\r\n\t\t\t\t\t# if tup2 in s:\r\n\t\t\t\t\t# \tprint(\"?????\",tup2,n)\r\n\t\t\t\t\t# assert reduce(gcd,tup2) < 2\r\n\t\t\t\t\t# s2.add(tup2)\r\n\t\t\t\t\t# l2.append(tup2)\r\n\t\t\t\t\tlo,hi=(L+a-1)\/\/a, R\/\/(c*n)\r\n\t\t\t\t\tif lo <= hi:\r\n\t\t\t\t\t\ttmp += hi-lo+1\r\n\t\t\t\telse:\r\n\t\t\t\t\tbreak\r\n\t\t\t# s2.add(tup)\r\n\r\n\t# s2.add((3,4,6))\r\n\t# s2.add((6,10,15))\r\n\r\n\tl2.append((3,4,6))\r\n\tl2.append((6,10,15))\r\n\r\n\t\r\n\tfor tup in l2:\r\n\t\ta,b,c=tup\r\n\t\t# if a<b<c:\r\n\t\t\t# s4 = set()\r\n\t\tlo,hi=(L+a-1)\/\/a, R\/\/c\r\n\t\tif lo <= hi:\r\n\t\t\ttmp += hi-lo+1\r\n\t\t\t# for d in range((L+a-1)\/\/a, R\/\/c+1):\r\n\t\t\t# \ttup2 = (d*a,d*b,d*c)\r\n\t\t\t# \tif tup2 in s3:\r\n\t\t\t# \t\tprint(tup2,\"?????\")\r\n\t\t\t# \ts3.add(tup2)\r\n\t\t\t# \ts4.add(tup2)\r\n\t\t\t# assert tmp == len(s3), (L,R,lo,hi,tup, s3,s4)\r\n\r\n\r\n\t\t# s32= set(list(s3))\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\t# for tup in s3:\r\n\t# \ta,b,c=tup\r\n\t# \tif L<=a<b<c<=R:# and lcm3(tup) < sum(tup):\r\n\t# \t\t# s4.add(tup)\r\n\t# \t\tans -= 1\r\n\r\n\t# print(tot - len(s3))\r\n\tprint(tot-tmp)","tags":["math","number theory"],"src_uid":"2cc753baa293ee832054de494dee0f15"}
{"text_full":"[DESCRIPTION]Chanek Jones is back, helping his long-lost relative Indiana Jones, to find a secret treasure in a maze buried below a desert full of illusions.The map of the labyrinth forms a tree with $$$n$$$ rooms numbered from $$$1$$$ to $$$n$$$ and $$$n - 1$$$ tunnels connecting them such that it is possible to travel between each pair of rooms through several tunnels.The $$$i$$$-th room ($$$1 \\leq i \\leq n$$$) has $$$a_i$$$ illusion rate. To go from the $$$x$$$-th room to the $$$y$$$-th room, there must exist a tunnel between $$$x$$$ and $$$y$$$, and it takes $$$\\max(|a_x + a_y|, |a_x - a_y|)$$$ energy. $$$|z|$$$ denotes the absolute value of $$$z$$$.To prevent grave robbers, the maze can change the illusion rate of any room in it. Chanek and Indiana would ask $$$q$$$ queries.There are two types of queries to be done:  $$$1\\ u\\ c$$$ — The illusion rate of the $$$x$$$-th room is changed to $$$c$$$ ($$$1 \\leq u \\leq n$$$, $$$0 \\leq |c| \\leq 10^9$$$).  $$$2\\ u\\ v$$$ — Chanek and Indiana ask you the minimum sum of energy needed to take the secret treasure at room $$$v$$$ if they are initially at room $$$u$$$ ($$$1 \\leq u, v \\leq n$$$). Help them, so you can get a portion of the treasure![SOURCE CODE]def naiveSolve():\r\n    \r\n    \r\n    \r\n    return\r\n\r\n\r\n\r\ndef solve():\r\n    \r\n    \r\n    \r\n    return\r\n\r\nfrom types import GeneratorType\r\ndef bootstrap(f, stack=[]):\r\n    def wrappedfunc(*args, **kwargs):\r\n        if stack:\r\n            return f(*args, **kwargs)\r\n        else:\r\n            to = f(*args, **kwargs)\r\n            while True:\r\n                if type(to) is GeneratorType:\r\n                    stack.append(to)\r\n                    to = next(to)\r\n                else:\r\n                    stack.pop()\r\n                    if not stack:\r\n                        break\r\n                    to = stack[-1].send(to)\r\n            return to\r\n    return wrappedfunc\r\n\r\nclass SegmentTree():\r\n    def __init__(self,arr,combinerFunction,isCommutative=True): # isCommutative means f(a,b)==f(b,a)\r\n        self.n=len(arr)\r\n        def cmb(a,b):\r\n            if a==None: return b\r\n            if b==None: return a\r\n            return combinerFunction(a,b)\r\n        self.cmb=cmb\r\n        self.sz=self.n if isCommutative else pow(2,((self.n-1).bit_length())) # non-commutative needs power of 2 size\r\n        self.t=[None]*(2*self.sz) # use None as initial value\r\n        for i in range(self.n): self.t[i+self.sz]=arr[i]\r\n        for i in range(self.sz-1,0,-1): self.pull(i)\r\n    def pull(self,p):\r\n        self.t[p]=self.cmb(self.t[2*p],self.t[2*p+1])\r\n    def update(self,idx,val): # set val at idx\r\n        idx+=self.sz\r\n        self.t[idx]=val\r\n        idx\/\/=2\r\n        while idx>0:\r\n            self.pull(idx)\r\n            idx\/\/=2\r\n    def query(self,l,r): # aggregated value in [l,r] inclusive\r\n        l+=self.sz; r+=self.sz+1\r\n        a=b=None\r\n        while l<r:\r\n            if l%2==1: a=self.cmb(a,self.t[l]); l+=1\r\n            if r%2==1: r-=1; b=self.cmb(self.t[r],b)\r\n            l\/\/=2; r\/\/=2\r\n        return self.cmb(a,b)\r\ndef getMaxSegTree(arr):\r\n    return SegmentTree(arr,lambda a,b:max(a,b),True)\r\ndef getMinSegTree(arr):\r\n    return SegmentTree(arr,lambda a,b:min(a,b),True)\r\ndef getSumSegTree(arr):\r\n    return SegmentTree(arr,lambda a,b:a+b,True)\r\n\r\ndef main():\r\n    \r\n    n,q=readIntArr()\r\n    a=readIntArr()\r\n    for i in range(n):\r\n        a[i]=abs(a[i])\r\n    \r\n    adj=[[] for _ in range(n)]\r\n    for _ in range(n-1):\r\n        u,v=readIntArr(); u-=1; v-=1\r\n        adj[u].append(v)\r\n        adj[v].append(u)\r\n    \r\n    # Using the fact that max(abs(x+y),abs(x-y))=abs(x)+abs(y),\r\n    # and using an Euler tour to \"flatten\" the tree to allow for querying.\r\n    # Store an array of size 2*n. Save the entry and exit indexes in the\r\n    # euler tour array. When entering, store abs(a) in euler tour array.\r\n    # When exiting, store -abs(a).\r\n    # To update, change the entry and exit indexes of euler tour array.\r\n    # To get distance from root, query from 0 to the entry index.\r\n    # Use LCA to find common ancestor, and subtract the dist from node to\r\n    # common ancestor.\r\n    \r\n    root=0 ## To modify accordingly\r\n    @bootstrap\r\n    def eulerTour(node,p): # O(n)\r\n        up[node][0]=p\r\n        tin[node]=time[0]\r\n        eulerTourArr[time[0]]=2*a[node] # add cost\r\n        time[0]+=1\r\n        for v in adj[node]: # adj[u]=[v1,v2,v3,...]\r\n            if v!=p:\r\n                yield eulerTour(v,node)\r\n        tout[node]=time[0]\r\n        eulerTourArr[time[0]]=-2*a[node] # subtract cost for prefix sum to give cost from root to node\r\n        time[0]+=1\r\n        yield None\r\n    time=[0]\r\n    tin=[-1]*(n) # this is also the node entry index in eulerTourArr\r\n    tout=[-1]*(n) # this is also the node exit index in eulerTourArr\r\n    maxPow=0\r\n    while pow(2,maxPow)<n:\r\n        maxPow+=1\r\n    maxPow+=1\r\n    up=[[-1 for _ in range(maxPow)] for __ in range(n+1)]\r\n    \r\n    eulerTourArr=[0]*(2*n) # stores the energy sum for 2 * node\r\n    \r\n    \r\n    eulerTour(root,-1)\r\n    for i in range(1,maxPow): # Build up in O(nlogn)\r\n        for u in range(1,n+1):\r\n            if up[u][i-1]==-1 or up[up[u][i-1]][i-1]==-1: # reached beyond root\r\n                continue\r\n            up[u][i]=up[up[u][i-1]][i-1]\r\n    \r\n    def isAncestor(u,v): # True if u is ancestor of v\r\n        return tin[u]<=tin[v] and tout[u]>=tout[v]\r\n    \r\n    def findLCA(u,v): # Find LCA in O(logn)\r\n        # traverse u to LCA\r\n        if not isAncestor(u,v):\r\n            u2=u\r\n            for i in range(maxPow-1,-1,-1):\r\n                if up[u2][i]!=-1 and not isAncestor(up[u2][i],v):\r\n                    u2=up[u2][i]\r\n            # next level up is lca\r\n            lca=up[u2][0]\r\n        else:\r\n            lca=u\r\n        return lca\r\n    \r\n    st=getSumSegTree(eulerTourArr)\r\n    allans=[]\r\n    # print(tin)\r\n    # print(tout)\r\n    for _ in range(q):\r\n        x,u,v=readIntArr(); u-=1\r\n        if x==1: # update u to c\r\n            c=abs(v)\r\n            st.update(tin[u],2*c)\r\n            st.update(tout[u],-2*c)\r\n            a[u]=c\r\n        else: # query u to v\r\n            v-=1\r\n            # print(eulerTourArr)\r\n            rootToU=st.query(0,tin[u])-a[root]-a[u]\r\n            rootToV=st.query(0,tin[v])-a[root]-a[v]\r\n            lca=findLCA(u,v)\r\n            rootToLCA=st.query(0,tin[lca])-a[root]-a[lca]\r\n            ans=rootToU+rootToV-2*rootToLCA\r\n            allans.append(ans)\r\n            # print('u:{} v:{} rootToU:{} roottoV:{} lca:{}'.format(\r\n                # u+1,v+1,rootToU,rootToV,lca+1))\r\n            \r\n    multiLineArrayPrint(allans)\r\n    \r\n    return\r\n\r\n\r\nimport sys\r\ninput=sys.stdin.buffer.readline #FOR READING PURE INTEGER INPUTS (space separation ok)\r\n# input=lambda: sys.stdin.readline().rstrip(\"\\r\\n\") #FOR READING STRING\/TEXT INPUTS.\r\n\r\ndef oneLineArrayPrint(arr):\r\n    print(' '.join([str(x) for x in arr]))\r\ndef multiLineArrayPrint(arr):\r\n    print('\\n'.join([str(x) for x in arr]))\r\ndef multiLineArrayOfArraysPrint(arr):\r\n    print('\\n'.join([' '.join([str(x) for x in y]) for y in arr]))\r\n \r\ndef readIntArr():\r\n    return [int(x) for x in input().split()]\r\n# def readFloatArr():\r\n#     return [float(x) for x in input().split()]\r\n \r\ndef makeArr(defaultValFactory,dimensionArr): # eg. makeArr(lambda:0,[n,m])\r\n    dv=defaultValFactory;da=dimensionArr\r\n    if len(da)==1:return [dv() for _ in range(da[0])]\r\n    else:return [makeArr(dv,da[1:]) for _ in range(da[0])]\r\n \r\ndef queryInteractive(x):\r\n    print('{}'.format(x))\r\n    sys.stdout.flush()\r\n    return int(input())\r\n \r\ndef answerInteractive(ans):\r\n    print('! {}'.format(ans))\r\n    sys.stdout.flush()\r\n \r\ninf=float('inf')\r\n# MOD=10**9+7\r\n# MOD=998244353\r\n\r\nfrom math import gcd,floor,ceil\r\n# from math import floor,ceil # for Python2\r\n \r\nfor _abc in range(1):\r\n    main()","tags":["trees"],"src_uid":"99e3ab8db0a27cdb6882486dcd46ef0b"}
{"text_full":"[DESCRIPTION]You have a statistic of price changes for one product represented as an array of $$$n$$$ positive integers $$$p_0, p_1, \\dots, p_{n - 1}$$$, where $$$p_0$$$ is the initial price of the product and $$$p_i$$$ is how the price was increased during the $$$i$$$-th month.Using these price changes you are asked to calculate the inflation coefficients for each month as the ratio of current price increase $$$p_i$$$ to the price at the start of this month $$$(p_0 + p_1 + \\dots + p_{i - 1})$$$.Your boss said you clearly that the inflation coefficients must not exceed $$$k$$$ %, so you decided to increase some values $$$p_i$$$ in such a way, that all $$$p_i$$$ remain integers and the inflation coefficients for each month don't exceed $$$k$$$ %.You know, that the bigger changes — the more obvious cheating. That's why you need to minimize the total sum of changes.What's the minimum total sum of changes you need to make all inflation coefficients not more than $$$k$$$ %?[SOURCE CODE]#import io, os\r\n#input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\r\n\r\nimport math\r\nt = int(input())\r\nfor _ in range(t):\r\n  \r\n  n, k = map(int,input().split())\r\n  k = k\r\n  arr = list(map(int,input().split()))\r\n\r\n  running_total = arr[0]\r\n  ans = 0\r\n  \r\n  for i in range(1,len(arr)):\r\n\r\n    if (arr[i] \/ running_total) > k\/100:\r\n\r\n      ans += math.ceil(100 * arr[i] \/ k ) - running_total\r\n      running_total += math.ceil(100 * arr[i] \/ k ) - running_total\r\n\r\n    \r\n\r\n    running_total +=  arr[i]\r\n    \r\n  print(ans)","tags":["math"],"src_uid":"53975eea2503bb47bfd0a5119406aea3"}
{"text_full":"[DESCRIPTION]You are given two integers $$$n$$$ and $$$k$$$.You should create an array of $$$n$$$ positive integers $$$a_1, a_2, \\dots, a_n$$$ such that the sum $$$(a_1 + a_2 + \\dots + a_n)$$$ is divisible by $$$k$$$ and maximum element in $$$a$$$ is minimum possible.What is the minimum possible maximum element in $$$a$$$?[SOURCE CODE]t = int(input())\r\nfor i in range(t):\r\n    n, k = list(map(int, input().split()))\r\n        \r\n    if k % n == 0:\r\n        print(k\/\/n)\r\n        \r\n    elif n % k == 0:\r\n        print(1)\r\n        \r\n    else:\r\n        if k > n:\r\n            print((k\/\/n) + 1) \r\n        elif k < n:\r\n            print(2)\r\n        else:\r\n            print(1)","tags":["math"],"src_uid":"a28b84c9d1a54e322ab2d54bd5ab45c8"}
{"text_full":"[DESCRIPTION]Masha meets a new friend and learns his phone number — $$$s$$$. She wants to remember it as soon as possible. The phone number — is a string of length $$$m$$$ that consists of digits from $$$0$$$ to $$$9$$$. The phone number may start with 0.Masha already knows $$$n$$$ phone numbers (all numbers have the same length $$$m$$$). It will be easier for her to remember a new number if the $$$s$$$ is represented as segments of numbers she already knows. Each such segment must be of length at least $$$2$$$, otherwise there will be too many segments and Masha will get confused.For example, Masha needs to remember the number: $$$s = $$$ '12345678' and she already knows $$$n = 4$$$ numbers: '12340219', '20215601', '56782022', '12300678'. You can represent $$$s$$$ as a $$$3$$$ segment: '1234' of number one, '56' of number two, and '78' of number three. There are other ways to represent $$$s$$$.Masha asks you for help, she asks you to break the string $$$s$$$ into segments of length $$$2$$$ or more of the numbers she already knows. If there are several possible answers, print any of them.[SOURCE CODE]import math,sys;input=sys.stdin.readline;S=lambda:input().rstrip();I=lambda:int(S());M=lambda:map(int,S().split());L=lambda:list(M());mod1=1000000007;mod2=998244353\r\n\r\nfor _ in range(I()):\r\n\tS();n,m=M();have={};pos={};dp=[0]*(m+1);pr=[0]*(m+1);dp[0]=1\r\n\tfor i in range(n):\r\n\t\tcur=S()\r\n\t\tfor j in range(m):\r\n\t\t\tt=cur[j]\r\n\t\t\tfor k in range(1,3):\r\n\t\t\t\tif k+j>=m:break\r\n\t\t\t\tt+=cur[j+k]\r\n\t\t\t\tif not have.get(t,0):\r\n\t\t\t\t\thave[t]=1\r\n\t\t\t\t\tpos[t]=(j,j+k,i)\t\r\n\ts=S()\r\n\tfor i in range(m):\r\n\t\tt=s[i]\r\n\t\tfor k in range(1,3):\r\n\t\t\tif i-k<0:break\r\n\t\t\tt=s[i-k]+t\r\n\t\t\tif have.get(t,0) and dp[i-k]:\r\n\t\t\t\tdp[i+1]=1\r\n\t\t\t\tpr[i+1]=i-k\r\n\t\t\tif dp[i+1]:break\r\n\tif not dp[m]:print(-1);continue\r\n\tk=m;ans=[]\r\n\twhile k>0:\r\n\t\tp=pr[k]\t\r\n\t\tt=s[p:k]\r\n\t\tans.append(pos[t])\r\n\t\tk=p\r\n\tprint(len(ans));ans.reverse()\r\n\tfor i in ans:print(i[0]+1,i[1]+1,i[2]+1)","tags":["strings"],"src_uid":"a4f4ad94387b16e8760e7c7fd45b93b3"}
{"text_full":"[DESCRIPTION]You are given an array $$$a$$$ consisting of $$$n$$$ positive integers. You can perform operations on it.In one operation you can replace any element of the array $$$a_i$$$ with $$$\\lfloor \\frac{a_i}{2} \\rfloor$$$, that is, by an integer part of dividing $$$a_i$$$ by $$$2$$$ (rounding down).See if you can apply the operation some number of times (possible $$$0$$$) to make the array $$$a$$$ become a permutation of numbers from $$$1$$$ to $$$n$$$ —that is, so that it contains all numbers from $$$1$$$ to $$$n$$$, each exactly once.For example, if $$$a = [1, 8, 25, 2]$$$, $$$n = 4$$$, then the answer is yes. You could do the following:  Replace $$$8$$$ with $$$\\lfloor \\frac{8}{2} \\rfloor = 4$$$, then $$$a = [1, 4, 25, 2]$$$.  Replace $$$25$$$ with $$$\\lfloor \\frac{25}{2} \\rfloor = 12$$$, then $$$a = [1, 4, 12, 2]$$$.  Replace $$$12$$$ with $$$\\lfloor \\frac{12}{2} \\rfloor = 6$$$, then $$$a = [1, 4, 6, 2]$$$.  Replace $$$6$$$ with $$$\\lfloor \\frac{6}{2} \\rfloor = 3$$$, then $$$a = [1, 4, 3, 2]$$$.[SOURCE CODE]def solve(): \r\n    n=int(input());l=[]\r\n    arr=[int(i) for i in input().split()]\r\n    if max(arr)<n:\r\n        print(\"NO\")\r\n        return \r\n    for i in arr : \r\n        while i>0 :\r\n            if i<=n and i not in l :\r\n                l.append(i)\r\n                break\r\n            i\/\/=2\r\n    if len(l)==n :\r\n        print(\"YES\")\r\n        return \r\n    print(\"NO\")\r\n    return \r\nif __name__==\"__main__\" :\r\n    for x in range(int(input())) : solve()","tags":["math"],"src_uid":"645459e0a41ec63b13648ea8dbe0f053"}
{"text_full":"[DESCRIPTION]You are given a rooted tree. It contains $$$n$$$ vertices, which are numbered from $$$1$$$ to $$$n$$$. The root is the vertex $$$1$$$.Each edge has two positive integer values. Thus, two positive integers $$$a_j$$$ and $$$b_j$$$ are given for each edge.Output $$$n-1$$$ numbers $$$r_2, r_3, \\dots, r_n$$$, where $$$r_i$$$ is defined as follows.Consider the path from the root (vertex $$$1$$$) to $$$i$$$ ($$$2 \\le i \\le n$$$). Let the sum of the costs of $$$a_j$$$ along this path be $$$A_i$$$. Then $$$r_i$$$ is equal to the length of the maximum prefix of this path such that the sum of $$$b_j$$$ along this prefix does not exceed $$$A_i$$$.    Example for $$$n=9$$$. The blue color shows the costs of $$$a_j$$$, and the red color shows the costs of $$$b_j$$$. Consider an example. In this case:  $$$r_2=0$$$, since the path to $$$2$$$ has an amount of $$$a_j$$$ equal to $$$5$$$, only the prefix of this path of length $$$0$$$ has a smaller or equal amount of $$$b_j$$$; $$$r_3=3$$$, since the path to $$$3$$$ has an amount of $$$a_j$$$ equal to $$$5+9+5=19$$$, the prefix of length $$$3$$$ of this path has a sum of $$$b_j$$$ equal to $$$6+10+1=17$$$ ( the number is $$$17 \\le 19$$$); $$$r_4=1$$$, since the path to $$$4$$$ has an amount of $$$a_j$$$ equal to $$$5+9=14$$$, the prefix of length $$$1$$$ of this path has an amount of $$$b_j$$$ equal to $$$6$$$ (this is the longest suitable prefix, since the prefix of length $$$2$$$ already has an amount of $$$b_j$$$ equal to $$$6+10=16$$$, which is more than $$$14$$$); $$$r_5=2$$$, since the path to $$$5$$$ has an amount of $$$a_j$$$ equal to $$$5+9+2=16$$$, the prefix of length $$$2$$$ of this path has a sum of $$$b_j$$$ equal to $$$6+10=16$$$ (this is the longest suitable prefix, since the prefix of length $$$3$$$ already has an amount of $$$b_j$$$ equal to $$$6+10+1=17$$$, what is more than $$$16$$$); $$$r_6=1$$$, since the path up to $$$6$$$ has an amount of $$$a_j$$$ equal to $$$2$$$, the prefix of length $$$1$$$ of this path has an amount of $$$b_j$$$ equal to $$$1$$$; $$$r_7=1$$$, since the path to $$$7$$$ has an amount of $$$a_j$$$ equal to $$$5+3=8$$$, the prefix of length $$$1$$$ of this path has an amount of $$$b_j$$$ equal to $$$6$$$ (this is the longest suitable prefix, since the prefix of length $$$2$$$ already has an amount of $$$b_j$$$ equal to $$$6+3=9$$$, which is more than $$$8$$$); $$$r_8=2$$$, since the path up to $$$8$$$ has an amount of $$$a_j$$$ equal to $$$2+4=6$$$, the prefix of length $$$2$$$ of this path has an amount of $$$b_j$$$ equal to $$$1+3=4$$$; $$$r_9=3$$$, since the path to $$$9$$$ has an amount of $$$a_j$$$ equal to $$$2+4+1=7$$$, the prefix of length $$$3$$$ of this path has a sum of $$$b_j$$$ equal to $$$1+3+3=7$$$.[SOURCE CODE]import sys, io, os\r\nimport time\r\n\r\n\r\ninput = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\r\n\r\n\r\ndef find_prefix_length(b_stack, sum_a_, starting_prefix):\r\n    lo = starting_prefix\r\n    hi = len(b_stack) - 1\r\n\r\n    while (hi - lo) > 1:\r\n        mid = (lo + hi) \/\/ 2\r\n        if b_stack[mid] <= sum_a_:\r\n            lo = mid\r\n        else:\r\n            hi = mid - 1\r\n\r\n    if b_stack[hi] <= sum_a_:\r\n        return hi\r\n\r\n    return lo\r\n\r\n\r\ndef estimate_prefix(tree, n):\r\n    global start\r\n    b_stack = []\r\n    output = [None] * n\r\n    started = [False] * n\r\n\r\n    stack = [(0, 0, 0, 0)]\r\n    count = 0\r\n    while len(stack) > 0:\r\n        node, sum_a, prefix_length, old_b = stack[-1]\r\n\r\n        if started[node]:\r\n            b_stack.pop()\r\n            stack.pop()\r\n            continue\r\n        else:\r\n            sum_b = 0\r\n            if len(b_stack) > 0:\r\n                sum_b = b_stack[-1]\r\n            b_stack.append(sum_b + old_b)\r\n            started[node] = True\r\n            count += 1\r\n\r\n\r\n        output[node] = prefix_length\r\n\r\n        for child_node, a, b in tree[node]:\r\n            sum_a_ = sum_a + a\r\n            b_stack.append(b_stack[-1] + b)\r\n            prefix_length_ = find_prefix_length(b_stack, sum_a_, prefix_length)\r\n            stack += [(child_node, sum_a_, prefix_length_, b)]\r\n            b_stack.pop()\r\n\r\n    return output\r\n\r\n\r\nfor _ in range(int(input())):\r\n    start = time.time()\r\n    n = int(input())\r\n    tree = [[] for _ in range(n)]\r\n\r\n    for i in range(1, n):\r\n        p, a, b = map(int, input().split())\r\n        tree[p - 1] += [(i, a, b)]\r\n\r\n    b_stack = []\r\n    output = estimate_prefix(tree, n)\r\n    sys.stdout.write(f\"{' '.join(map(str, output[1:]))}\\n\")","tags":["trees"],"src_uid":"8629aa74df60537987611c6c1ef1a140"}
{"text_full":"[DESCRIPTION]Vlad, like everyone else, loves to sleep very much.Every day Vlad has to do $$$n$$$ things, each at a certain time. For each of these things, he has an alarm clock set, the $$$i$$$-th of them is triggered on $$$h_i$$$ hours $$$m_i$$$ minutes every day ($$$0 \\le h_i &lt; 24, 0 \\le m_i &lt; 60$$$). Vlad uses the $$$24$$$-hour time format, so after $$$h=12, m=59$$$ comes $$$h=13, m=0$$$ and after $$$h=23, m=59$$$ comes $$$h=0, m=0$$$.This time Vlad went to bed at $$$H$$$ hours $$$M$$$ minutes ($$$0 \\le H &lt; 24, 0 \\le M &lt; 60$$$) and asks you to answer: how much he will be able to sleep until the next alarm clock.If any alarm clock rings at the time when he went to bed, then he will sleep for a period of time of length $$$0$$$.[SOURCE CODE]tt = int(input())\n\nfor i in range(0, tt):\n    \n    n_a, v_h, v_m = input().split(' ')\n    v_h = int(v_h)\n    v_m = int(v_m)\n\n    ans = []\n    f = False\n    v_t = v_h * 60 + v_m\n    d_cycle = 60 * 24\n\n\n\n    for i in range(0, int(n_a)):\n        al_h, al_m = input().split(' ')\n\n        al_h = int(al_h)\n        al_m = int(al_m)\n\n        dt = (al_h * 60 + al_m) - v_t\n        if(dt == 0):\n            f = True\n        if(dt < 0):\n            dt = dt + d_cycle\n            ans.append(dt)\n        else:\n            ans.append(dt)\n\n            \n    if(f):\n        print(\"0 0\")\n    else:\n        m = 2 ** 32\n        for i in range(0, len(ans)):\n            if(ans[i] < m):\n                m = ans[i]\n        print(m\/\/60,m%60)","tags":["math"],"src_uid":"ce0579e9c5b4c157bc89103c76ddd4c3"}
{"text_full":"[DESCRIPTION]You are given an array of $$$n$$$ integers $$$a_1, a_2, \\dots, a_n$$$You can apply the following operation an arbitrary number of times:   select an index $$$i$$$ ($$$1 \\le i \\le n$$$) and replace the value of the element $$$a_i$$$ with the value $$$a_i + (a_i \\bmod 10)$$$, where $$$a_i \\bmod 10$$$ is the remainder of the integer dividing $$$a_i$$$ by $$$10$$$. For a single index (value $$$i$$$), this operation can be applied multiple times. If the operation is applied repeatedly to the same index, then the current value of $$$a_i$$$ is taken into account each time. For example, if $$$a_i=47$$$ then after the first operation we get $$$a_i=47+7=54$$$, and after the second operation we get $$$a_i=54+4=58$$$.Check if it is possible to make all array elements equal by applying multiple (possibly zero) operations.For example, you have an array $$$[6, 11]$$$.   Let's apply this operation to the first element of the array. Let's replace $$$a_1 = 6$$$ with $$$a_1 + (a_1 \\bmod 10) = 6 + (6 \\bmod 10) = 6 + 6 = 12$$$. We get the array $$$[12, 11]$$$.  Then apply this operation to the second element of the array. Let's replace $$$a_2 = 11$$$ with $$$a_2 + (a_2 \\bmod 10) = 11 + (11 \\bmod 10) = 11 + 1 = 12$$$. We get the array $$$[12, 12]$$$. Thus, by applying $$$2$$$ operations, you can make all elements of an array equal.[SOURCE CODE]t = int(input())\r\nfor ti in range(t):\r\n    n = int(input())\r\n    a = sorted(list(map(int, input().split())))\r\n    is0 = False\r\n    res = \"YES\"\r\n    while a[0] % 10 != 2:\r\n        a[0] += a[0] % 10\r\n        if a[0] % 10 == 0:\r\n            is0 = True\r\n            break\r\n    for i in range(n - 1):\r\n        while a[i + 1] % 10 != 2:\r\n            a[i + 1] += a[i + 1] % 10\r\n            if a[i + 1] % 10 == 0:\r\n                if not is0:\r\n                    res = \"NO\"\r\n                break\r\n        if res == \"NO\":\r\n            break\r\n        if is0:\r\n            if a[i] != a[i + 1]:\r\n                res = \"NO\"\r\n        if (a[i + 1] - a[i]) % 20 != 0:\r\n            res = \"NO\"\r\n    print(res)","tags":["math","number theory"],"src_uid":"2d27f3530aa140be0add639a1edfd880"}
{"text_full":"[DESCRIPTION]You are given a connected undirected graph consisting of $$$n$$$ vertices and $$$m$$$ edges. The weight of the $$$i$$$-th edge is $$$i$$$.Here is a wrong algorithm of finding a minimum spanning tree (MST) of a graph:vis := an array of length ns := a set of edgesfunction dfs(u):    vis[u] := true    iterate through each edge (u, v) in the order from smallest to largest edge weight        if vis[v] = false            add edge (u, v) into the set (s)            dfs(v)function findMST(u):    reset all elements of (vis) to false    reset the edge set (s) to empty    dfs(u)    return the edge set (s)Each of the calls findMST(1), findMST(2), ..., findMST(n) gives you a spanning tree of the graph. Determine which of these trees are minimum spanning trees.[SOURCE CODE]import sys\r\nimport io, os\r\ninput = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\r\n\r\n\r\nn,m=map(int,input().split())\r\nEDGE=[tuple(map(int,input().split())) for i in range(m)]\r\n\r\n# UnionFind\r\n\r\nGroup = [i for i in range(n+1)] # グループ分け\r\nNodes = [1]*(n+1) # 各グループのノードの数\r\n\r\ndef find(x):\r\n    while Group[x] != x:\r\n        x=Group[x]\r\n    return x\r\n\r\ndef Union(x,y):\r\n    if find(x) != find(y):\r\n        if Nodes[find(x)] < Nodes[find(y)]:\r\n            \r\n            Nodes[find(y)] += Nodes[find(x)]\r\n            Nodes[find(x)] = 0\r\n            Group[find(x)] = find(y)\r\n            \r\n        else:\r\n            Nodes[find(x)] += Nodes[find(y)]\r\n            Nodes[find(y)] = 0\r\n            Group[find(y)] = find(x)\r\n\r\nUSE=[0]*m\r\n\r\nfor i in range(m):\r\n    x,y=EDGE[i]\r\n\r\n    if find(x)==find(y):\r\n        USE[i]=0\r\n    else:\r\n        USE[i]=1\r\n        Union(x,y)\r\n\r\nE=[[] for i in range(n+1)]\r\n\r\nOK=[0]*(n+1)\r\n\r\nfor i in range(m):\r\n    if USE[i]==1:\r\n        x,y = EDGE[i]\r\n        E[x].append(y)\r\n        E[y].append(x)\r\n\r\n        OK[x]=1\r\n        OK[y]=1\r\n\r\n# 木のHL分解+LCA\r\n\r\nN=n+1\r\nROOT=1\r\n\r\nQUE=[ROOT] \r\nParent=[-1]*(N+1)\r\nHeight=[-1]*(N+1)\r\nParent[ROOT]=N # ROOTの親を定めておく.\r\nHeight[ROOT]=0\r\nChild=[[] for i in range(N+1)]\r\nTOP_SORT=[] # トポロジカルソート\r\n\r\nwhile QUE: # トポロジカルソートと同時に親を見つける\r\n    x=QUE.pop()\r\n    TOP_SORT.append(x)\r\n    for to in E[x]:\r\n        if Parent[to]==-1:\r\n            Parent[to]=x\r\n            Height[to]=Height[x]+1\r\n            Child[x].append(to)\r\n            QUE.append(to)\r\n\r\nChildren=[1]*(N+1)\r\n\r\nfor x in TOP_SORT[::-1]: #（自分を含む）子ノードの数を調べる\r\n    Children[Parent[x]]+=Children[x]\r\n\r\nUSE=[0]*N\r\nGroup=[i for i in range(N)]\r\n\r\nfor x in TOP_SORT: # HL分解によるグループ分け\r\n    USE[x]=1\r\n    MAX_children=0\r\n    select_node=0\r\n\r\n    for to in E[x]:\r\n        if USE[to]==0 and Children[to]>MAX_children:\r\n            select_node=to\r\n            MAX_children=Children[to]\r\n\r\n    for to in E[x]:\r\n        if USE[to]==0 and to==select_node:\r\n            Group[to]=Group[x]\r\n\r\ndef LCA(a,b): # HL分解を利用してLCAを求める\r\n    while Group[a]!=Group[b]:\r\n        if Children[Parent[Group[a]]]<Children[Parent[Group[b]]]:\r\n            a=Parent[Group[a]]\r\n        else:\r\n            b=Parent[Group[b]]\r\n\r\n    if Children[a]>Children[b]:\r\n        return a\r\n    else:\r\n        return b\r\n\r\nParents=[Parent]\r\n\r\nfor i in range(30):\r\n    X=[-1]*(N+1)\r\n\r\n    for i in range(N+1):\r\n        X[i]=Parents[-1][Parents[-1][i]]\r\n\r\n    Parents.append(X)\r\n\r\ndef LCA_mae(x,y):\r\n    while Height[x]>Height[y]+1:\r\n        for i in range(30):\r\n            k=Parents[i][x]\r\n\r\n            if k==-1 or k>=n or Height[k]<=Height[y]:\r\n                x=Parents[i-1][x]\r\n                break\r\n    return x\r\n\r\nDOWN=[0]*(N+1)\r\n\r\nscore=0\r\n\r\nfor x,y in EDGE:\r\n    if OK[x]==1 and OK[y]==1:\r\n        if Parent[x]==y or Parent[y]==x:\r\n            continue\r\n\r\n        k=LCA(x,y)\r\n\r\n        if k==x:\r\n            DOWN[y]+=1\r\n            k=LCA_mae(y,x)\r\n            DOWN[k]-=1\r\n            \r\n        elif k==y:\r\n            DOWN[x]+=1\r\n            k=LCA_mae(x,y)\r\n            DOWN[k]-=1\r\n\r\n        else:\r\n            score+=1\r\n            DOWN[x]+=1\r\n            DOWN[y]+=1\r\n\r\nfor x in TOP_SORT[1:]:\r\n    DOWN[x]+=DOWN[Parent[x]]\r\n\r\nANS=[0]*N\r\n\r\nfor i in range(N):\r\n    if OK[i]==1 and DOWN[i]==score:\r\n        ANS[i]=1\r\n\r\nprint(\"\".join(map(str,ANS[1:N])))","tags":["graphs","trees"],"src_uid":"2bf41400fa51f472f1d3904baa06d6a8"}
{"text_full":"[DESCRIPTION]You are given three positive integers $$$a$$$, $$$b$$$, $$$c$$$ ($$$a &lt; b &lt; c$$$). You have to find three positive integers $$$x$$$, $$$y$$$, $$$z$$$ such that:$$$$$$x \\bmod y = a,$$$$$$ $$$$$$y \\bmod z = b,$$$$$$ $$$$$$z \\bmod x = c.$$$$$$Here $$$p \\bmod q$$$ denotes the remainder from dividing $$$p$$$ by $$$q$$$. It is possible to show that for such constraints the answer always exists.[SOURCE CODE]if __name__ == \"__main__\":\n    for i in range(int(input())):\n        abc = list(map(int, input().split(\" \")))\n        print(abc[0] + abc[1] + abc[2], abc[1] + abc[2], abc[2])","tags":["math"],"src_uid":"f0c22161cb5a9bc17320ccd05517f867"}
{"text_full":"[DESCRIPTION]A string $$$s$$$ of length $$$n$$$ ($$$1 \\le n \\le 26$$$) is called alphabetical if it can be obtained using the following algorithm:  first, write an empty string to $$$s$$$ (i.e. perform the assignment $$$s$$$ := \"\");  then perform the next step $$$n$$$ times;  at the $$$i$$$-th step take $$$i$$$-th lowercase letter of the Latin alphabet and write it either to the left of the string $$$s$$$ or to the right of the string $$$s$$$ (i.e. perform the assignment $$$s$$$ := $$$c+s$$$ or $$$s$$$ := $$$s+c$$$, where $$$c$$$ is the $$$i$$$-th letter of the Latin alphabet). In other words, iterate over the $$$n$$$ first letters of the Latin alphabet starting from 'a' and etc. Each time we prepend a letter to the left of the string $$$s$$$ or append a letter to the right of the string $$$s$$$. Strings that can be obtained in that way are alphabetical.For example, the following strings are alphabetical: \"a\", \"ba\", \"ab\", \"bac\" and \"ihfcbadeg\". The following strings are not alphabetical: \"z\", \"aa\", \"ca\", \"acb\", \"xyz\" and \"ddcba\".From the given string, determine if it is alphabetical.[SOURCE CODE]t = int(input())\nimport string\n\ndef is_abc(S):\n    abc = list(string.ascii_lowercase)\n    del abc[0]\n\n    if S == 'a':\n        return True\n    \n    if S == '':\n        return True\n\n \n    if len(set(S)) == len(S) and 'a' in S:\n        a = S.index('a')\n        prev_S = list(reversed(S[:a]))\n        post_S = S[a+1:]\n        c = len(prev_S) + len(post_S)\n\n        for i in range(c):\n            current_S = abc[i]\n            prev = prev_S[0] if prev_S else None\n            post = post_S[0] if post_S else None\n\n            if current_S == prev:\n                del prev_S[0]\n            elif current_S == post:\n                del post_S[0]\n            else:\n                return False\n        return True\n    else:\n        return False\n                \nfor i in range(t):\n    S = list(input())\n    if is_abc(S):\n        print('YES') \n    else:\n        print('NO')","tags":["strings"],"src_uid":"801bf7c73c44c68eaa61c714d5aedf50"}
{"text_full":"[DESCRIPTION]Given an integer sequence $$$a_1, a_2, \\dots, a_n$$$ of length $$$n$$$, your task is to compute the number, modulo $$$998244353$$$, of ways to partition it into several non-empty continuous subsequences such that the sums of elements in the subsequences form a balanced sequence.A sequence $$$s_1, s_2, \\dots, s_k$$$ of length $$$k$$$ is said to be balanced, if $$$s_{i} = s_{k-i+1}$$$ for every $$$1 \\leq i \\leq k$$$. For example, $$$[1, 2, 3, 2, 1]$$$ and $$$[1,3,3,1]$$$ are balanced, but $$$[1,5,15]$$$ is not. Formally, every partition can be described by a sequence of indexes $$$i_1, i_2, \\dots, i_k$$$ of length $$$k$$$ with $$$1 = i_1 &lt; i_2 &lt; \\dots &lt; i_k \\leq n$$$ such that   $$$k$$$ is the number of non-empty continuous subsequences in the partition;  For every $$$1 \\leq j \\leq k$$$, the $$$j$$$-th continuous subsequence starts with $$$a_{i_j}$$$, and ends exactly before $$$a_{i_{j+1}}$$$, where $$$i_{k+1} = n + 1$$$. That is, the $$$j$$$-th subsequence is $$$a_{i_j}, a_{i_j+1}, \\dots, a_{i_{j+1}-1}$$$.  There are $$$2^{n-1}$$$ different partitions in total. Let $$$s_1, s_2, \\dots, s_k$$$ denote the sums of elements in the subsequences with respect to the partition $$$i_1, i_2, \\dots, i_k$$$. Formally, for every $$$1 \\leq j \\leq k$$$, $$$$$$ s_j = \\sum_{i=i_{j}}^{i_{j+1}-1} a_i = a_{i_j} + a_{i_j+1} + \\dots + a_{i_{j+1}-1}. $$$$$$ For example, the partition $$$[1\\,|\\,2,3\\,|\\,4,5,6]$$$ of sequence $$$[1,2,3,4,5,6]$$$ is described by the sequence $$$[1,2,4]$$$ of indexes, and the sums of elements in the subsequences with respect to the partition is $$$[1,5,15]$$$.Two partitions $$$i_1, i_2, \\dots, i_k$$$ and $$$i'_1, i'_2, \\dots, i'_{k'}$$$ (described by sequences of indexes) are considered to be different, if at least one of the following holds.   $$$k \\neq k'$$$,  $$$i_j \\neq i'_j$$$ for some $$$1 \\leq j \\leq \\min\\left\\{ k, k' \\right\\}$$$.[SOURCE CODE]MOD = 998244353\r\nMAX=100005\r\nfact=[1]\r\nfor zz in range(1,MAX+1):\r\n    fact.append((fact[-1]*zz)%MOD) #with MOD\r\n#    fact.append(fact[-1]*zz) #without MOD\r\ndef nCr(n,r): #choose, MOD is prime\r\n    num=fact[n]\r\n    den=(fact[r]*fact[n-r])%MOD\r\n    return (num*pow(den,MOD-2,MOD))%MOD #with MOD, O(log(MOD))\r\n#    den= fact[r]*fact[n-r]# without MOD\r\n#    return num\/\/den # without MOD\r\n\r\ndef main():\r\n    \r\n    t = int(input())\r\n    allans = []\r\n    for _ in range(t):\r\n        n = int(input())\r\n        a = readIntArr()\r\n        \r\n        p = a.copy()\r\n        for i in range(1, n):\r\n            p[i] += p[i - 1]\r\n        def q(l, r):\r\n            if r + 1 == l:\r\n                return 0\r\n            if l == 0:\r\n                return p[r]\r\n            return p[r] - p[l - 1]\r\n        cnts = 1  # entire array\r\n        l = 0\r\n        r = n - 1\r\n        while l + 1 <= r:\r\n            while q(0, l) > q(r, n - 1):\r\n                r -= 1\r\n                if l + 1 > r:\r\n                    break\r\n            if l + 1 > r:\r\n                break\r\n            if q(0, l) == q(r, n - 1):\r\n                if q(l + 1, r - 1) == 0:  # all zeroes in the middle\r\n                    gaps = r - l\r\n                    cnts2 = 0\r\n                    for r in range(1, gaps + 1):\r\n                        cnts2 += nCr(gaps, r)\r\n                        cnts2 %= MOD\r\n                    cnts = cnts + (cnts * cnts2) % MOD\r\n                    cnts %= MOD\r\n                    # print('gaps:{} cnts2:{}'.format(gaps, cnts2))\r\n                    break\r\n                \r\n                # Count left\r\n                l2 = l\r\n                left_cnt = 1\r\n                while a[l2 + 1] == 0:\r\n                    left_cnt += 1\r\n                    l2 += 1\r\n                \r\n                # Count right\r\n                r2 = r\r\n                right_cnt = 1\r\n                while a[r2 - 1] == 0:\r\n                    right_cnt += 1\r\n                    r2 -= 1\r\n                \r\n                cnts2 = 0\r\n                z = min(left_cnt, right_cnt)\r\n                for y in range(1, z + 1):\r\n                    cnts2 += (nCr(left_cnt, y) * nCr(right_cnt, y)) % MOD\r\n                    cnts2 %= MOD\r\n                cnts = cnts + (cnts * cnts2) % MOD\r\n                cnts %= MOD\r\n                \r\n                # print('l:{} r:{} left_cnt:{} right_cnt:{} z:{} cnts2:{}'.format(\r\n                #     l, r, left_cnt, right_cnt, z, cnts2))\r\n                \r\n                l = l2\r\n                r = r2\r\n            l += 1\r\n        allans.append(cnts)\r\n    multiLineArrayPrint(allans)\r\n    \r\n    return\r\n\r\n\r\nimport sys\r\ninput=sys.stdin.buffer.readline #FOR READING PURE INTEGER INPUTS (space separation ok)\r\n# input=lambda: sys.stdin.readline().rstrip(\"\\r\\n\") #FOR READING STRING\/TEXT INPUTS.\r\n \r\ndef oneLineArrayPrint(arr):\r\n    print(' '.join([str(x) for x in arr]))\r\ndef multiLineArrayPrint(arr):\r\n    print('\\n'.join([str(x) for x in arr]))\r\ndef multiLineArrayOfArraysPrint(arr):\r\n    print('\\n'.join([' '.join([str(x) for x in y]) for y in arr]))\r\n \r\ndef readIntArr():\r\n    return [int(x) for x in input().split()]\r\n# def readFloatArr():\r\n#     return [float(x) for x in input().split()]\r\n \r\ndef makeArr(defaultValFactory,dimensionArr): # eg. makeArr(lambda:0,[n,m])\r\n    dv=defaultValFactory;da=dimensionArr\r\n    if len(da)==1:return [dv() for _ in range(da[0])]\r\n    else:return [makeArr(dv,da[1:]) for _ in range(da[0])]\r\n \r\ndef queryInteractive(a, b):\r\n    print('? {} {}'.format(a, b))\r\n    sys.stdout.flush()\r\n    return int(input())\r\n \r\ndef answerInteractive(ans):\r\n    print('! {}'.format(ans))\r\n    sys.stdout.flush()\r\n \r\ninf=float('inf')\r\n# MOD=10**9+7\r\n# MOD=998244353\r\n \r\nfrom math import gcd,floor,ceil\r\nimport math\r\n# from math import floor,ceil # for Python2\r\n \r\nfor _abc in range(1):\r\n    main()","tags":["math"],"src_uid":"fad12986a0a97a96109734fdce3bd7a7"}
{"text_full":"[DESCRIPTION]This is an interactive problem.Given a simple undirected graph with $$$n$$$ vertices numbered from $$$1$$$ to $$$n$$$, your task is to color all the vertices such that for every color $$$c$$$, the following conditions hold:   The set of vertices with color $$$c$$$ is connected;  $$$s_c \\leq n_c^2$$$, where $$$n_c$$$ is the number of vertices with color $$$c$$$, and $$$s_c$$$ is the sum of degrees of vertices with color $$$c$$$.  It can be shown that there always exists a way to color all the vertices such that the above conditions hold. Initially, you are only given the number $$$n$$$ of vertices and the degree of each vertex. In each query, you can choose a vertex $$$u$$$. As a response, you will be given the $$$k$$$-th edge incident to $$$u$$$, if this is the $$$k$$$-th query on vertex $$$u$$$. You are allowed to make at most $$$n$$$ queries.An undirected graph is simple if it does not contain multiple edges or self-loops.The degree of a vertex is the number of edges incident to it. A set $$$S$$$ of vertices is connected if for every two different vertices $$$u, v \\in S$$$, there is a path, which only passes through vertices in $$$S$$$, that connects $$$u$$$ and $$$v$$$. That is, there is a sequence of edges $$$(u_1, v_1), (u_2, v_2), \\dots, (u_k, v_k)$$$ with $$$k \\geq 1$$$ such that   $$$u_1 = u$$$, $$$v_k = v$$$, and $$$v_i = u_{i+1}$$$ for every $$$1 \\leq i &lt; k$$$; and  $$$u_k \\in S$$$ and $$$v_k \\in S$$$ for every $$$1 \\leq i \\leq k$$$.  Especially, a set containing only one vertex is connected.[SOURCE CODE]#!\/usr\/bin\/env python3\nimport sys, getpass\nimport math, random\nimport functools, itertools, collections, heapq, bisect\nfrom collections import Counter, defaultdict, deque\ninput = sys.stdin.readline  # to read input quickly\n\n# available on Google, AtCoder Python3, not available on Codeforces\n# import numpy as np\n# import scipy\n\nm9 = 10**9 + 7  # 998244353\n# d4 = [(1,0),(0,1),(-1,0),(0,-1)]\n# d8 = [(1,0),(1,1),(0,1),(-1,1),(-1,0),(-1,-1),(0,-1),(1,-1)]\n# d6 = [(2,0),(1,1),(-1,1),(-2,0),(-1,-1),(1,-1)]  # hexagonal layout\nMAXINT = sys.maxsize\ne18 = 10**18 + 10\n\n# if testing locally, print to terminal with a different color\nOFFLINE_TEST = getpass.getuser() == \"htong\"\n# OFFLINE_TEST = False  # codechef does not allow getpass\ndef log(*args):\n    if OFFLINE_TEST:\n        print('\\033[36m', *args, '\\033[0m', file=sys.stderr)\n\n# ---------------------------- template ends here ----------------------------\n\ndef query(pos):\n    print(\"? {}\".format(pos+1), flush=True)\n    response = int(input()) - 1\n    assert response >= 0\n    return response\n\ndef alert(arr):\n    print(\"! {}\".format(\" \".join(str(x) for x in arr)), flush=True)\n\n# -----------------------------------------------------------------------------\n\nclass DisjointSet:\n    # github.com\/not522\/ac-library-python\/blob\/master\/atcoder\/dsu.py\n\n    def __init__(self, n: int = 0) -> None:\n        if n > 0:  # constant size DSU\n            self.parent_or_size = [-1]*n\n        else:\n            self.parent_or_size = defaultdict(lambda: -1)\n\n    def union(self, a: int, b: int) -> int:\n        x = self.find(a)\n        y = self.find(b)\n\n        if x == y:\n            return x\n\n        if -self.parent_or_size[x] < -self.parent_or_size[y]:\n            x, y = y, x\n\n        self.parent_or_size[x] += self.parent_or_size[y]\n        self.parent_or_size[y] = x\n\n        return x\n\n    def find(self, a: int) -> int:\n        parent = self.parent_or_size[a]\n        while parent >= 0:\n            if self.parent_or_size[parent] < 0:\n                return parent\n            self.parent_or_size[a], a, parent = (\n                self.parent_or_size[parent],\n                self.parent_or_size[parent],\n                self.parent_or_size[self.parent_or_size[parent]]\n            )\n        return a\n\n    def size(self, a: int) -> int:\n        return -self.parent_or_size[self.find(a)]\n\nimport random\n# get highest degree\n# get adjacent nodes\n# if nodes is in previous group, join\n\nfor case_num in range(int(input())):\n\n    # read line as an integer\n    n = int(input())\n\n    # read line as a string\n    # srr = input().strip()\n\n    # read one line and parse each word as a string\n    # lst = input().split()\n\n    ds = DisjointSet(n)\n    for i in range(n):\n        ds.find(i)\n    # read one line and parse each word as an integer\n    # a,b,c = list(map(int,input().split()))\n    degrees = list(map(int,input().split()))\n\n    taken = set()\n    arr = [(x,i) for i,x in enumerate(degrees)]\n    # random.shuffle(arr)\n    arr.sort()\n    # arr.reverse()\n\n    # log(arr)\n    query_cnt = 0\n\n    while arr:\n        x,cur = arr.pop()\n        if cur in taken:\n            continue\n        taken.add(cur)\n        for _ in range(x):\n            nex = query(cur)\n            query_cnt += 1\n            ds.union(cur, nex)\n            if nex in taken:\n                break\n            taken.add(nex)\n\n    assert query_cnt <= n\n\n    for i in range(n):\n        ldr = ds.find(i)\n\n    cntr = 1\n    val_to_cntr = {}\n    for i in range(n):\n        ldr = ds.find(i)\n        if ldr not in val_to_cntr:\n            val_to_cntr[ldr] = cntr\n            cntr += 1\n\n    res = [-1 for _ in range(n)]\n    for i in range(n):\n        res[i] = val_to_cntr[ds.find(i)]\n\n    assert max(res) <= n\n    assert min(res) >= 1\n\n    cnt_nodes = defaultdict(int)\n    cnt_edges = defaultdict(int)\n    for i,x in enumerate(res):\n        cnt_nodes[x] += 1\n        cnt_edges[x] += degrees[i]\n    \n    for i in cnt_nodes.keys():\n        assert cnt_edges[i] <= cnt_nodes[i]**2\n\n    alert(res)\n\n    # -----------------------------------------------------------------------------\n\n    # your code here\nsys.exit()","tags":["graphs","trees"],"src_uid":"cb05d81d82d16ac3fdf8ec33e69d5ae8"}
{"text_full":"[DESCRIPTION]You are given a permutation $$$a$$$ of size $$$n$$$ and you should perform $$$n$$$ operations on it. In the $$$i$$$-th operation, you can choose a non-empty suffix of $$$a$$$ and increase all of its elements by $$$i$$$. How can we perform the operations to minimize the number of inversions in the final array?Note that you can perform operations on the same suffix any number of times you want.A permutation of size $$$n$$$ is an array of size $$$n$$$ such that each integer from $$$1$$$ to $$$n$$$ occurs exactly once in this array. A suffix is several consecutive elements of an array that include the last element of the array. An inversion in an array $$$a$$$ is a pair of indices $$$(i, j)$$$ such that $$$i &gt; j$$$ and $$$a_{i} &lt; a_{j}$$$.[SOURCE CODE]import collections\r\nimport heapq\r\nimport sys\r\nimport math\r\nimport itertools\r\nimport bisect\r\nfrom io import BytesIO, IOBase\r\nimport os\r\n######################################################################################\r\n#--------------------------------------funs here-------------------------------------#\r\n######################################################################################\r\ndef values(): return tuple(map(int, sys.stdin.readline().split()))\r\ndef inlsts(): return [int(i) for i in sys.stdin.readline().split()]\r\ndef inp(): return int(sys.stdin.readline())\r\ndef instr(): return sys.stdin.readline().strip()\r\ndef words(): return [i for i in sys.stdin.readline().strip().split()]\r\ndef chars(): return [i for i in sys.stdin.readline().strip()]\r\n######################################################################################\r\n#--------------------------------------code here-------------------------------------#\r\n######################################################################################\r\n\r\n\r\ndef solve():\r\n    n = inp()\r\n    l=values()\r\n    d={}\r\n    for i in range(n): d[l[i]]=i\r\n       \r\n    \r\n    print(*[d[n-i]+1 for i in range(n)])\r\n   \r\n    \r\n \r\n  \r\n\r\n\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    for i in range(inp()):\r\n        solve()","tags":["math"],"src_uid":"188c9dbb3e1851b7b762ed6b4b23d1bd"}
{"text_full":"[DESCRIPTION]Kawashiro Nitori is a girl who loves competitive programming.One day she found a string and an integer. As an advanced problem setter, she quickly thought of a problem.Given a string $$$s$$$ and a parameter $$$k$$$, you need to check if there exist $$$k+1$$$ non-empty strings $$$a_1,a_2...,a_{k+1}$$$, such that $$$$$$s=a_1+a_2+\\ldots +a_k+a_{k+1}+R(a_k)+R(a_{k-1})+\\ldots+R(a_{1}).$$$$$$ Here $$$+$$$ represents concatenation. We define $$$R(x)$$$ as a reversed string $$$x$$$. For example $$$R(abcd) = dcba$$$. Note that in the formula above the part $$$R(a_{k+1})$$$ is intentionally skipped.[SOURCE CODE]ans_list = []\r\nfor i in range(int(input())):\r\n\tn, k = map(int, input().split())\r\n\tstrings = input()\r\n\r\n\tskip = False\r\n\tif(n == 2 * k):\r\n\t\tans_list.append(\"NO\")\r\n\t\tcontinue\r\n\r\n\tfor i in range(k):\r\n\t\tif(strings[i] == strings[n - 1 - i]):\r\n\t\t\tpass\r\n\t\telse:\r\n\t\t\tans_list.append(\"NO\")\r\n\t\t\tskip = True\r\n\t\t\tbreak\r\n\r\n\tif(skip == False):\r\n\t\tans_list.append(\"YES\")\r\n\r\nfor ans in ans_list:\r\n\tprint(ans)","tags":["strings"],"src_uid":"6fbf41dc32d1c28351d78a9ec5fc0026"}
{"text_full":"[DESCRIPTION]You are given a connected weighted undirected graph, consisting of $$$n$$$ vertices and $$$m$$$ edges.You are asked $$$k$$$ queries about it. Each query consists of a single integer $$$x$$$. For each query, you select a spanning tree in the graph. Let the weights of its edges be $$$w_1, w_2, \\dots, w_{n-1}$$$. The cost of a spanning tree is $$$\\sum \\limits_{i=1}^{n-1} |w_i - x|$$$ (the sum of absolute differences between the weights and $$$x$$$). The answer to a query is the lowest cost of a spanning tree.The queries are given in a compressed format. The first $$$p$$$ $$$(1 \\le p \\le k)$$$ queries $$$q_1, q_2, \\dots, q_p$$$ are provided explicitly. For queries from $$$p+1$$$ to $$$k$$$, $$$q_j = (q_{j-1} \\cdot a + b) \\mod c$$$.Print the xor of answers to all queries.[SOURCE CODE]from bisect import bisect_left\r\nfrom collections import defaultdict\r\nI = lambda: [int(x) for x in input().split()]\r\n\r\nclass DSU:\r\n    def __init__(self, N):\r\n        self.p = list(range(N))\r\n\r\n    def find(self, x):\r\n        if self.p[x] != x:\r\n            self.p[x] = self.find(self.p[x])\r\n        return self.p[x]\r\n\r\n    def union(self, x, y):\r\n        self.p[self.find(x)] = self.find(y)\r\n\r\n\r\nedges = []\r\nn, m = I()\r\nfor _ in range(m):\r\n    x, y, w = I()\r\n    edges += [(x - 1, y - 1, w)]\r\n\r\np, k, a, b, c = I()\r\nQ = I()\r\nfor _ in range(k - p):\r\n    Q += [(Q[-1] * a + b) % c]\r\n\r\ndef kruskal(x):\r\n    dsu, ans, W, sgn = DSU(n), [], 0, 0\r\n    E = sorted(edges, key=lambda q: abs(x - q[2]))\r\n    for u, v, w in E:\r\n        if dsu.find(u) == dsu.find(v): continue\r\n        s = -1 + 2 * int(x <= w)\r\n        dsu.union(u, v)\r\n        ans += [w]\r\n        W += w * s\r\n        sgn += s\r\n    return sorted(ans), W, sgn\r\n\r\npoints = defaultdict(tuple)\r\nat, maxval = 0, 10**8\r\n\r\nwhile at <= maxval:\r\n    cur_weights = kruskal(at)[0]\r\n    lo, hi = at, maxval\r\n    while lo < hi:\r\n        mid = (lo + hi + 1) \/\/ 2\r\n        if kruskal(mid)[0] == cur_weights:\r\n            lo = mid\r\n        else:\r\n            hi = mid - 1\r\n\r\n    points[lo] = kruskal(lo)\r\n    at = lo + 1\r\n\r\nfor _, _, w in edges:\r\n    points[w] = kruskal(w)\r\n\r\nw, out = sorted(points), 0\r\n\r\nfor x in Q:\r\n    idx = bisect_left(w, x)\r\n    if idx >= len(w): idx -= 1\r\n    out ^= (points[w[idx]][1] - x*points[w[idx]][2])\r\n\r\nprint(out)","tags":["graphs","math","trees"],"src_uid":"2fad8bea91cf6db14b34271e88ab093c"}
{"text_full":"[DESCRIPTION]We call a string good, if after merging all the consecutive equal characters, the resulting string is palindrome. For example, \"aabba\" is good, because after the merging step it will become \"aba\".Given a string, you have to find two values:  the number of good substrings of even length;  the number of good substrings of odd length.[SOURCE CODE]s = input()\na = []\nfor c in s:\n    a.append(ord(c) - ord('a'))\ncnt = [[0, 0], [0, 0]]\nans = [0, 0]\nfor i in range(len(a)):\n    cnt[a[i]][i % 2] += 1\n    ans[0] += cnt[a[i]][i % 2]\n    ans[1] += cnt[a[i]][1 - i % 2]\nprint(ans[1], ans[0])","tags":["math"],"src_uid":"4ebbda2fc1a260e9827205a25addd9c4"}
{"text_full":"[DESCRIPTION]You have a string $$$s$$$ and a chip, which you can place onto any character of this string. After placing the chip, you move it to the right several (maybe zero) times, i. e. you perform the following operation several times: if the current position of the chip is $$$i$$$, you move it to the position $$$i + 1$$$. Of course, moving the chip to the right is impossible if it is already in the last position.After moving the chip to the right, you move it to the left several (maybe zero) times, i. e. you perform the following operation several times: if the current position of the chip is $$$i$$$, you move it to the position $$$i - 1$$$. Of course, moving the chip to the left is impossible if it is already in the first position.When you place a chip or move it, you write down the character where the chip ends up after your action. For example, if $$$s$$$ is abcdef, you place the chip onto the $$$3$$$-rd character, move it to the right $$$2$$$ times and then move it to the left $$$3$$$ times, you write down the string cdedcb.You are given two strings $$$s$$$ and $$$t$$$. Your task is to determine whether it's possible to perform the described operations with $$$s$$$ so that you write down the string $$$t$$$ as a result.[SOURCE CODE]t = int(input())\r\nres = []\r\nfor _ in range(t):\r\n    a = list(input())\r\n    isAnswered = False\r\n    a1 = list(input())\r\n    isConversely = False\r\n    for j in range(len(a)):\r\n        if(a1[0] == a[j]):\r\n            if(len(a1) == 1):\r\n                res.append(\"YES\")\r\n                isAnswered = True\r\n                break\r\n            o = 1\r\n            i = j\r\n            check = 0\r\n            ckeck1 = 0\r\n            while(o < len(a1) and i + 1 < len(a) and a1[o] == a[i + 1]):\r\n                if(a[i - 1] == a[i + 1]):\r\n                    check = o - 1\r\n                    check1 = i\r\n                    while(check1 >= 0 and check1 < len(a) and check < len(a1) and a1[check] == a[check1]):\r\n                        if check == len(a1) - 1:\r\n                            res.append(\"YES\")\r\n                            isAnswered = True\r\n                            break\r\n                        check += 1\r\n                        check1 -= 1\r\n                if(isAnswered):\r\n                    break\r\n                o += 1\r\n                i += 1\r\n                isConversely = True\r\n                if o == len(a1):\r\n                    res.append(\"YES\")\r\n                    isAnswered = True\r\n                    break\r\n            if isAnswered:\r\n                break\r\n            elif isConversely:\r\n                i = o - 1\r\n                o += j - 1\r\n            else:\r\n                i = 0\r\n                o = j\r\n            while(i >= 0 and o < len(a) and a1[i] == a[o] and o >= 0):\r\n                if i == len(a1) - 1:\r\n                    res.append(\"YES\")\r\n                    isAnswered = True\r\n                    break\r\n                i += 1\r\n                o -= 1\r\n    if(not isAnswered):\r\n        res.append(\"NO\")\r\nprint(*res, sep=\"\\n\")","tags":["strings"],"src_uid":"d69e10bb05d119ec2ad4b5c0e4304336"}
{"text_full":"[DESCRIPTION]A binary tree of $$$n$$$ nodes is given. Nodes of the tree are numbered from $$$1$$$ to $$$n$$$ and the root is the node $$$1$$$. Each node can have no child, only one left child, only one right child, or both children. For convenience, let's denote $$$l_u$$$ and $$$r_u$$$ as the left and the right child of the node $$$u$$$ respectively, $$$l_u = 0$$$ if $$$u$$$ does not have the left child, and $$$r_u = 0$$$ if the node $$$u$$$ does not have the right child.Each node has a string label, initially is a single character $$$c_u$$$. Let's define the string representation of the binary tree as the concatenation of the labels of the nodes in the in-order. Formally, let $$$f(u)$$$ be the string representation of the tree rooted at the node $$$u$$$. $$$f(u)$$$ is defined as follows: $$$$$$ f(u) = \\begin{cases} \\texttt{&lt;empty string&gt;}, &amp; \\text{if }u = 0; \\\\ f(l_u) + c_u + f(r_u) &amp; \\text{otherwise}, \\end{cases} $$$$$$ where $$$+$$$ denotes the string concatenation operation.This way, the string representation of the tree is $$$f(1)$$$.For each node, we can duplicate its label at most once, that is, assign $$$c_u$$$ with $$$c_u + c_u$$$, but only if $$$u$$$ is the root of the tree, or if its parent also has its label duplicated.You are given the tree and an integer $$$k$$$. What is the lexicographically smallest string representation of the tree, if we can duplicate labels of at most $$$k$$$ nodes?A string $$$a$$$ is lexicographically smaller than a string $$$b$$$ if and only if one of the following holds:   $$$a$$$ is a prefix of $$$b$$$, but $$$a \\ne b$$$;  in the first position where $$$a$$$ and $$$b$$$ differ, the string $$$a$$$ has a letter that appears earlier in the alphabet than the corresponding letter in $$$b$$$.[SOURCE CODE]import sys\r\nI=lambda:[*map(int, sys.stdin.readline().split())]\r\n\r\nleft = []\r\nright = []\r\nn, k = I()\r\nparents = [-1] * n\r\ns = input()\r\nfor i in range(n):\r\n\tl, r = I()\r\n\tl -= 1\r\n\tr -= 1\r\n\tleft.append(l)\r\n\tright.append(r)\r\n\tif l >= 0:\r\n\t\tparents[l] = i\r\n\tif r >= 0:\r\n\t\tparents[r] = i\r\n\r\ncovered = [0] * n\r\ncovered.append(1)\r\norder = []\r\ncurr = 0\r\nwhile len(order) < n:\r\n\tif covered[left[curr]]:\r\n\t\tif covered[curr]:\r\n\t\t\tif covered[right[curr]]:\r\n\t\t\t\tcurr = parents[curr]\r\n\t\t\telse:\r\n\t\t\t\tcurr = right[curr]\r\n\t\telse:\r\n\t\t\tcovered[curr] = 1\r\n\t\t\torder.append(curr)\r\n\telse:\r\n\t\tcurr = left[curr]\r\n\r\nafter = 'a'\r\nwant = [0] * n\r\ncurr = s[order[-1]]\r\nfor i in range(n - 2, -1, -1):\r\n\tnew = s[order[i]]\r\n\tif new != curr:\r\n\t\tafter = curr\r\n\t\tcurr = new\r\n\tif curr < after:\r\n\t\twant[order[i]] = 1\r\n\r\ndist = [float('inf')] * n\r\nfor v in order:\r\n\tif want[v]:\r\n\t\tdist[v] = 0\r\n\telif left[v] >= 0:\r\n\t\tdist[v] = dist[left[v]] + 1\r\n\r\ndupe = [0] * n\r\nchecked = [0] * n\r\ncurr = 0\r\nlef = k\r\nwhile lef > 0 and curr != -1:\r\n\tif dupe[curr]:\r\n\t\tif left[curr] >= 0 and dupe[left[curr]] == 0 and checked[left[curr]] == 0:\r\n\t\t\tcurr = left[curr]\r\n\t\telif right[curr] >= 0 and dupe[right[curr]] == 0 and checked[right[curr]] == 0:\r\n\t\t\tcurr = right[curr]\r\n\t\telse:\r\n\t\t\tcurr = parents[curr]\r\n\telse:\r\n\t\tif dist[curr] < lef:\r\n\t\t\tlef -= dist[curr] + 1\r\n\t\t\tdupe[curr] = 1\r\n\t\t\tfor i in range(dist[curr]):\r\n\t\t\t\tcurr = left[curr]\r\n\t\t\t\tdupe[curr] = 1\r\n\t\telse:\r\n\t\t\tchecked[curr] = 1\r\n\t\t\tcurr = parents[curr]\r\n\r\nout = []\r\nfor guy in order:\r\n\tif dupe[guy]:\r\n\t\tout.append(2 * s[guy])\r\n\telse:\r\n\t\tout.append(s[guy])\r\nprint(''.join(out))","tags":["strings","trees"],"src_uid":"9463dd8f054eeaeeeeaec020932301c3"}
{"text_full":"[DESCRIPTION]Last summer, Feluda gifted Lalmohan-Babu a balanced bracket sequence $$$s$$$ of length $$$2 n$$$.Topshe was bored during his summer vacations, and hence he decided to draw an undirected graph of $$$2 n$$$ vertices using the balanced bracket sequence $$$s$$$. For any two distinct vertices $$$i$$$ and $$$j$$$ ($$$1 \\le i &lt; j \\le 2 n$$$), Topshe draws an edge (undirected and unweighted) between these two nodes if and only if the subsegment $$$s[i \\ldots j]$$$ forms a balanced bracket sequence.Determine the number of connected components in Topshe's graph.See the Notes section for definitions of the underlined terms.[SOURCE CODE]n = int(input())\r\nfor i in range(n):\r\n    trash = int(input())\r\n    miew = input()\r\n    balance = 0\r\n    groups = 0\r\n    recently_closed = False\r\n    for j in range(len(miew)):\r\n        char = miew[j]\r\n        if char == '(':\r\n            balance += 1\r\n            recently_closed = False\r\n        else:\r\n            if balance > 0 and recently_closed:\r\n                groups += 1\r\n            if balance > 0:\r\n                balance -= 1\r\n                recently_closed = True\r\n            else:\r\n                groups += 1\r\n        # print(groups, j)\r\n    groups += balance + 1\r\n    print(groups)","tags":["graphs"],"src_uid":"6280a3373ab8fc34bb41fd98648019a6"}
{"text_full":"[DESCRIPTION]A permutation $$$p$$$ of length $$$n$$$ is called almost perfect if for all integer $$$1 \\leq i \\leq n$$$, it holds that $$$\\lvert p_i - p^{-1}_i \\rvert \\le 1$$$, where $$$p^{-1}$$$ is the inverse permutation of $$$p$$$ (i.e. $$$p^{-1}_{k_1} = k_2$$$ if and only if $$$p_{k_2} = k_1$$$).Count the number of almost perfect permutations of length $$$n$$$ modulo $$$998244353$$$.[SOURCE CODE]mod = 998244353\r\n\r\n\r\ndef main():\r\n    import sys\r\n    input = sys.stdin.readline\r\n\r\n    # comb init\r\n    nmax = 3 * 10 ** 5 + 10  # change here\r\n    fac = [0] * nmax\r\n    finv = [0] * nmax\r\n    inv = [0] * nmax\r\n    fac[0] = 1\r\n    fac[1] = 1\r\n    finv[0] = 1\r\n    finv[1] = 1\r\n    inv[1] = 1\r\n    for i in range(2, nmax):\r\n        fac[i] = fac[i - 1] * i % mod\r\n        inv[i] = mod - inv[mod % i] * (mod \/\/ i) % mod\r\n        finv[i] = finv[i - 1] * inv[i] % mod\r\n\r\n    def comb(n, r):\r\n        if n < r:\r\n            return 0\r\n        else:\r\n            return (fac[n] * ((finv[r] * finv[n - r]) % mod)) % mod\r\n\r\n    F = [1, 1]\r\n    for i in range(2, 3 * 10 ** 5 + 1):\r\n        F.append((F[-1] + (i - 1) * F[-2]) % mod)\r\n\r\n    for _ in range(int(input())):\r\n        N = int(input())\r\n        ans = 0\r\n        tmp = 1\r\n        pow2 = 1\r\n        for k in range(N+1):\r\n            if N - 4 * k < 0:\r\n                break\r\n            ans = (ans + ((comb(N - 2 * k, 2 * k) * F[N - 4 * k]) % mod * (tmp * pow2) % mod) % mod) % mod\r\n            tmp = (tmp * (2 * k + 1)) % mod\r\n            pow2 = (pow2 * 2) % mod\r\n        print(ans)\r\n\r\n\r\nif __name__ == '__main__':\r\n    main()","tags":["math"],"src_uid":"0b3f93005a639a9a51279fae65c15301"}
{"text_full":"[DESCRIPTION]You have a sequence $$$a$$$ with $$$n$$$ elements $$$1, 2, 3, \\dots, k - 1, k, k - 1, k - 2, \\dots, k - (n - k)$$$ ($$$k \\le n &lt; 2k$$$).Let's call as inversion in $$$a$$$ a pair of indices $$$i &lt; j$$$ such that $$$a[i] &gt; a[j]$$$.Suppose, you have some permutation $$$p$$$ of size $$$k$$$ and you build a sequence $$$b$$$ of size $$$n$$$ in the following manner: $$$b[i] = p[a[i]]$$$.Your goal is to find such permutation $$$p$$$ that the total number of inversions in $$$b$$$ doesn't exceed the total number of inversions in $$$a$$$, and $$$b$$$ is lexicographically maximum.Small reminder: the sequence of $$$k$$$ integers is called a permutation if it contains all integers from $$$1$$$ to $$$k$$$ exactly once.Another small reminder: a sequence $$$s$$$ is lexicographically smaller than another sequence $$$t$$$, if either $$$s$$$ is a prefix of $$$t$$$, or for the first $$$i$$$ such that $$$s_i \\ne t_i$$$, $$$s_i &lt; t_i$$$ holds (in the first position that these sequences are different, $$$s$$$ has smaller number than $$$t$$$).[SOURCE CODE]T=int(input())\r\nfor _ in range(T):\r\n  n,k=map(int,input().split())\r\n  ans=[i for i in range(1,k+1)]\r\n  temp=2*k-n-1;k1=k\r\n  for i in range(temp,k):\r\n     ans[i]=k1\r\n     k1-=1\r\n  print(*ans)","tags":["math"],"src_uid":"67de9506ac2458ee67346bae1a9e3926"}
{"text_full":"[DESCRIPTION]You are given a rooted tree consisting of $$$n$$$ vertices numbered from $$$1$$$ to $$$n$$$. The root is vertex $$$1$$$. There is also a string $$$s$$$ denoting the color of each vertex: if $$$s_i = \\texttt{B}$$$, then vertex $$$i$$$ is black, and if $$$s_i = \\texttt{W}$$$, then vertex $$$i$$$ is white.A subtree of the tree is called balanced if the number of white vertices equals the number of black vertices. Count the number of balanced subtrees.A tree is a connected undirected graph without cycles. A rooted tree is a tree with a selected vertex, which is called the root. In this problem, all trees have root $$$1$$$.The tree is specified by an array of parents $$$a_2, \\dots, a_n$$$ containing $$$n-1$$$ numbers: $$$a_i$$$ is the parent of the vertex with the number $$$i$$$ for all $$$i = 2, \\dots, n$$$. The parent of a vertex $$$u$$$ is a vertex that is the next vertex on a simple path from $$$u$$$ to the root.The subtree of a vertex $$$u$$$ is the set of all vertices that pass through $$$u$$$ on a simple path to the root. For example, in the picture below, $$$7$$$ is in the subtree of $$$3$$$ because the simple path $$$7 \\to 5 \\to 3 \\to 1$$$ passes through $$$3$$$. Note that a vertex is included in its subtree, and the subtree of the root is the entire tree.  The picture shows the tree for $$$n=7$$$, $$$a=[1,1,2,3,3,5]$$$, and $$$s=\\texttt{WBBWWBW}$$$. The subtree at the vertex $$$3$$$ is balanced.[SOURCE CODE]# cook your dish here\r\n#!\/usr\/bin\/env python\r\nfrom bisect import bisect_left\r\nfrom cmath import inf\r\nimport os\r\nfrom math import ceil, factorial, fmod,pi,sqrt,log\r\nimport sys\r\nfrom collections import Counter\r\nfrom io import BytesIO, IOBase, StringIO\r\nsys.setrecursionlimit(4*10**4)\r\ndef modFact(n, p):\r\n    if n >= p:\r\n        return 0   \r\n \r\n    result = 1\r\n    for i in range(1, n + 1):\r\n        result = (result * i) % p\r\n \r\n    return result\r\n \r\ndef calculate(p, q):\r\n     \r\n    mod = 998244353\r\n    expo = 0\r\n    expo = mod - 2\r\n \r\n    # Loop to find the value\r\n    # until the expo is not zero\r\n    while (expo):\r\n \r\n        # Multiply p with q\r\n        # if expo is odd\r\n        if (expo & 1):\r\n            p = (p * q) % mod\r\n        q = (q * q) % mod\r\n \r\n        # Reduce the value of\r\n        # expo by 2\r\n        expo >>= 1\r\n \r\n    return p\r\ndef compute_gcd(x, y):\r\n\r\n   while(y):\r\n       x, y = y, x % y\r\n   return x\r\n\r\n# This function computes LCM\r\ndef compute_lcm(x, y):\r\n   lcm = (x*y)\/\/compute_gcd(x,y)\r\n   return lcm\r\n\r\ndef read_arr():\r\n    return [int(x) for x in input().split()]\r\n\r\ndef bin_search(num, arr):\r\n    start = 0\r\n    end = len(arr)-1\r\n    while start <= end:\r\n        mid=(start+end)\/\/2\r\n        if arr[mid] == num:\r\n            return mid\r\n        elif arr[mid] > num:\r\n            end= mid-1\r\n        else:\r\n            start = mid + 1\r\n    return -1\r\n\r\n\r\ndef factors(n) :\r\n     \r\n    # Note that this loop runs till square root\r\n    i = 1\r\n    ans=[]\r\n    while i <= sqrt(n):\r\n         \r\n        if (n % i == 0) :\r\n             \r\n            # If divisors are equal, print only one\r\n            if (n \/ i == i) :\r\n                ans.append(i)\r\n            else :\r\n                # Otherwise print both\r\n                \r\n                ans.append(i)\r\n                ans.append(int(n\/i))\r\n        i = i + 1\r\n    return ans\r\n\r\ndef is_palindrome(n):\r\n    for j in range(len(n)\/\/2):\r\n        if n[j]!=n[len(n)-j-1]:\r\n            return False\r\n    return True\r\n\r\ndef nCr(n, r):\r\n     \r\n    return (fact(n) \/ (fact(r)\r\n                * fact(n - r)))\r\n \r\n# Returns factorial of n\r\ndef fact(n):\r\n \r\n    res = 1\r\n     \r\n    for i in range(2, n+1):\r\n        res = res * i\r\n    return res\r\ncnt=0\r\ndef recur(graph,root,s,num):\r\n    global cnt\r\n    if s[root-1]==\"B\":\r\n        num[root] -= 1\r\n    else:\r\n        num[root] += 1\r\n    for j in graph[root]:\r\n        num[root]+=recur(graph,j,s,num)\r\n    if num[root]==0:\r\n        cnt += 1\r\n    return num[root]\r\n\r\n\r\n\r\n\r\ndef main():\r\n    for i in range(int(input())):\r\n        global cnt\r\n        cnt=0\r\n        n = int(input())\r\n        arr=list(map(int, input().split()))\r\n        s=[x for x in input()]\r\n        graph={}\r\n        for j in range(1,n+5):\r\n            graph[j]=[]\r\n        for j in range(n-1):\r\n            graph[arr[j]].append(j+2)\r\n        num=[0 for j in range(n+1)]\r\n        recur(graph,1,s,num)\r\n        print(cnt)\r\n\r\n        \r\n\r\nBUFSIZE = 8192\r\n \r\n \r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n \r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n \r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n \r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n \r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\n \r\n \r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\n \r\n \r\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\n \r\n# endregion\r\n \r\nif __name__ == \"__main__\":\r\n    main()","tags":["graphs","trees"],"src_uid":"504613b285d10fbf1e45b9c4ace25865"}
{"text_full":"[DESCRIPTION]This is an interactive problem!In the last regional contest Hemose, ZeyadKhattab and YahiaSherif — members of the team Carpe Diem — did not qualify to ICPC because of some unknown reasons. Hemose was very sad and had a bad day after the contest, but ZeyadKhattab is very wise and knows Hemose very well, and does not want to see him sad.Zeyad knows that Hemose loves tree problems, so he gave him a tree problem with a very special device.Hemose has a weighted tree with $$$n$$$ nodes and $$$n-1$$$ edges. Unfortunately, Hemose doesn't remember the weights of edges.Let's define $$$Dist(u, v)$$$ for $$$u\\neq v$$$ as the greatest common divisor of the weights of all edges on the path from node $$$u$$$ to node $$$v$$$.Hemose has a special device. Hemose can give the device a set of nodes, and the device will return the largest $$$Dist$$$ between any two nodes from the set. More formally, if Hemose gives the device a set $$$S$$$ of nodes, the device will return the largest value of $$$Dist(u, v)$$$ over all pairs $$$(u, v)$$$ with $$$u$$$, $$$v$$$ $$$\\in$$$ $$$S$$$ and $$$u \\neq v$$$.Hemose can use this Device at most $$$12$$$ times, and wants to find any two distinct nodes $$$a$$$, $$$b$$$, such that $$$Dist(a, b)$$$ is maximum possible. Can you help him?[SOURCE CODE]# import os,sys\r\n# from io import BytesIO, IOBase\r\n\r\n# from collections import defaultdict,deque,Counter\r\n# from bisect import bisect_left,bisect_right\r\n# from heapq import heappush,heappop\r\n# from functools import lru_cache\r\n# from itertools import accumulate\r\n# import math\r\n\r\n# # Fast IO Region\r\n# BUFSIZE = 8192\r\n# class FastIO(IOBase):\r\n#     newlines = 0\r\n#     def __init__(self, file):\r\n#         self._fd = file.fileno()\r\n#         self.buffer = BytesIO()\r\n#         self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n#         self.write = self.buffer.write if self.writable else None\r\n#     def read(self):\r\n#         while True:\r\n#             b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n#             if not b:\r\n#                 break\r\n#             ptr = self.buffer.tell()\r\n#             self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n#         self.newlines = 0\r\n#         return self.buffer.read()\r\n#     def readline(self):\r\n#         while self.newlines == 0:\r\n#             b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n#             self.newlines = b.count(b\"\\n\") + (not b)\r\n#             ptr = self.buffer.tell()\r\n#             self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n#         self.newlines -= 1\r\n#         return self.buffer.readline()\r\n#     def flush(self):\r\n#         if self.writable:\r\n#             os.write(self._fd, self.buffer.getvalue())\r\n#             self.buffer.truncate(0), self.buffer.seek(0)\r\n# class IOWrapper(IOBase):\r\n#     def __init__(self, file):\r\n#         self.buffer = FastIO(file)\r\n#         self.flush = self.buffer.flush\r\n#         self.writable = self.buffer.writable\r\n#         self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n#         self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n#         self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\n# sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\n# input = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\n\r\n# for _ in range(int(input())):\r\n#     n = int(input())\r\n#     a = list(map(int, input().split(' ')))\r\n\r\n# for _ in range(int(input())):\r\n#     n, h = list(map(int, input().split(' ')))\r\n#     a = list(map(int, input().split(' ')))\r\n#     a.sort()\r\n#     x, y = a[-2], a[-1]\r\n#     if x == y:\r\n#         print(math.ceil(h \/ x))\r\n#     else:\r\n#         ans = h \/\/ (x + y) * 2\r\n#         h %= x + y\r\n#         if h > 0:\r\n#             ans += 1\r\n#         if h > y:\r\n#             ans += 1\r\n#         print(ans)\r\n\r\n# for _ in range(int(input())):\r\n#     n, x = list(map(int, input().split(' ')))\r\n#     a = list(map(int, input().split(' ')))\r\n#     b = sorted(a)\r\n#     for i in range(n - x, x):\r\n#         if a[i] != b[i]:\r\n#             print('NO')\r\n#             break\r\n#     else:\r\n#         print('YES')\r\n\r\nimport sys\r\nfrom collections import deque\r\nn = int(input())\r\nadj = [[] for _ in range(n + 1)]\r\nfor _ in range(n - 1):\r\n    u, v = list(map(int, input().split(' ')))\r\n    adj[u].append(v)\r\n    adj[v].append(u)\r\n\r\nq = deque([1])\r\norder = []\r\nparent = [-1] * (n + 1)\r\nvis = set()\r\nvis.add(1)\r\nwhile q:\r\n    u = q.popleft()\r\n    order.append(u)\r\n    for v in adj[u]:\r\n        if v not in vis:\r\n            parent[v] = u\r\n            q.append(v)\r\n            vis.add(v)\r\n\r\nprint(\"?\", len(order), *order)\r\nsys.stdout.flush()\r\nmx = int(input())\r\n\r\nl, r = 0, n - 1\r\nwhile l < r - 1:\r\n    mid = (l + r) \/\/ 2\r\n    print(\"?\", len(order[:mid + 1]), *order[:mid + 1])\r\n    sys.stdout.flush()\r\n    x = int(input())\r\n    if x == mx:\r\n        r = mid\r\n    else:\r\n        l = mid\r\n    \r\nprint(\"!\", order[r], parent[order[r]])\r\nsys.stdout.flush()","tags":["math","number theory","trees"],"src_uid":"905e3f3e6f7d8f13789b89e77a3ef65e"}
{"text_full":"[DESCRIPTION]Pchelyonok decided to give Mila a gift. Pchelenok has already bought an array $$$a$$$ of length $$$n$$$, but gifting an array is too common. Instead of that, he decided to gift Mila the segments of that array!Pchelyonok wants his gift to be beautiful, so he decided to choose $$$k$$$ non-overlapping segments of the array $$$[l_1,r_1]$$$, $$$[l_2,r_2]$$$, $$$\\ldots$$$ $$$[l_k,r_k]$$$ such that:  the length of the first segment $$$[l_1,r_1]$$$ is $$$k$$$, the length of the second segment $$$[l_2,r_2]$$$ is $$$k-1$$$, $$$\\ldots$$$, the length of the $$$k$$$-th segment $$$[l_k,r_k]$$$ is $$$1$$$  for each $$$i&lt;j$$$, the $$$i$$$-th segment occurs in the array earlier than the $$$j$$$-th (i.e. $$$r_i&lt;l_j$$$)  the sums in these segments are strictly increasing (i.e. let $$$sum(l \\ldots r) = \\sum\\limits_{i=l}^{r} a_i$$$ — the sum of numbers in the segment $$$[l,r]$$$ of the array, then $$$sum(l_1 \\ldots r_1) &lt; sum(l_2 \\ldots r_2) &lt; \\ldots &lt; sum(l_k \\ldots r_k)$$$). Pchelenok also wants his gift to be as beautiful as possible, so he asks you to find the maximal value of $$$k$$$ such that he can give Mila a gift![SOURCE CODE]import os\r\nimport sys\r\nfrom collections import *\r\nfrom itertools import *\r\nfrom math import *\r\nfrom array import *\r\nfrom functools import lru_cache\r\nimport heapq\r\nimport bisect\r\nimport random\r\nimport re\r\n\r\nif sys.hexversion == 50924784:\r\n    sys.stdin = open('cfinput.txt')\r\nelse:\r\n    input = sys.stdin.buffer.readline\r\nMOD = 10 ** 9 + 7\r\n\r\n\r\ndef RI():\r\n    return map(int, input().split())\r\n\r\n\r\ndef RILST():\r\n    return list(RI())\r\n\r\n\r\ndef solve(n, a):\r\n    a = a[::-1]  # 逆序，题目转化成：子数组长度+1递增，但求和递减\r\n    # print(a)\r\n    pre = list(accumulate(a, initial=0))\r\n    # print(pre)\r\n    m = int((1 + 8 * n) ** 0.5 - 1) \/\/ 2\r\n    f = [[0] * (n + 1) for _ in range(m + 2)]  # f[i][j]代表 从以j为结尾的前缀里，选出i个子数组，最后一组数组的最大和（ij均从1开始）\r\n    f[0] = [inf] * (n + 1)\r\n    ans = 1\r\n    # print(f,m)\r\n    for i in range(1, m + 1):\r\n        if ans < i - 1:\r\n            return print(ans)\r\n        for j in range(i * (i + 1) \/\/ 2, n + 1):\r\n            f[i][j] = f[i][j - 1]\r\n            s = pre[j] - pre[j - i]\r\n            if s < f[i - 1][j - i]:\r\n                ans = i\r\n                f[i][j] = max(f[i][j], s)\r\n        # print(f)\r\n\r\n    print(ans)\r\n\r\n\r\ndef solve2(n, a):\r\n    a = a[::-1]  # 逆序，题目转化成：子数组长度+1递增，但求和递减\r\n    pre = list(accumulate(a, initial=0))\r\n    # print(pre)\r\n    m = int((1 + 8 * n) ** 0.5 - 1) \/\/ 2\r\n    f = [0] * (n + 1)  # f[i][j]代表 从以j为结尾的前缀里，选出i个子数组，最后一组数组的最大和（ij均从1开始）\r\n    f = [inf] * (n + 1)\r\n    g = [0] * (n + 1)\r\n    ans = 1\r\n    # print(f,m)\r\n    for i in range(1, m + 1):\r\n        if ans < i - 1:\r\n            return print(ans)\r\n        g[i * (i + 1) \/\/ 2 - 1] = 0\r\n        for j in range(i * (i + 1) \/\/ 2, n + 1):\r\n            g[j] = g[j - 1]\r\n            s = pre[j] - pre[j - i]\r\n            if s < f[j - i]:\r\n                ans = i\r\n                g[j] = max(g[j], s)\r\n        f, g = g, f\r\n        # print(f,g)\r\n\r\n    print(ans)\r\n\r\n\r\ndef solve3(n, a):\r\n    # 逆序，题目转化成：子数组长度+1递增，但求和递减\r\n    pre = list(accumulate(a[::-1], initial=0))\r\n    m = int((1 + 8 * n) ** 0.5 - 1) \/\/ 2  # 长度为n的数组最多能选出m组\r\n    # f[i][j]代表 从以j为结尾的前缀里，选出i个子数组，最后一组数组的最大和（ij均从1开始）\r\n    f = [inf] * (n + 1)  # f[0][j]都置INF，因为长度为1的数组无求和上限要求,认为长度0的数组求和都是inf\r\n    g = [0] * (n + 1)  # 实测滚动数组时间优化一小半\r\n\r\n    ans = 1\r\n    for i in range(1, m + 1):\r\n        g[i * (i + 1) \/\/ 2 - 1] = 0  # 长度不够选不出来，结尾段求和置0，方便转移\r\n        for j in range(i * (i + 1) \/\/ 2, n + 1):\r\n            g[j] = g[j - 1]  # 从前缀转移\r\n            s = pre[j] - pre[j - i]\r\n            if g[j] < s < f[j - i]:  # 本段符合要求，尝试以它结尾（作为第i个子段）\r\n                ans = i\r\n                g[j] = s\r\n\r\n        if not g[n]:\r\n            break\r\n        f, g = g, f\r\n\r\n    print(ans)\r\n\r\n\r\nif __name__ == '__main__':\r\n    t, = RI()\r\n    for _ in range(t):\r\n        n, = RI()\r\n        a = RILST()\r\n        solve(n, a)","tags":["math"],"src_uid":"cc21fe2f33fed13e6fe0fb25f197ca8f"}
{"text_full":"[DESCRIPTION]This is an interactive problem. Remember to flush your output while communicating with the testing program. You may use fflush(stdout) in C++, system.out.flush() in Java, stdout.flush() in Python or flush(output) in Pascal to flush the output. If you use some other programming language, consult its documentation. You may also refer to the guide on interactive problems: https:\/\/codeforces.com\/blog\/entry\/45307.There is a city in which Dixit lives. In the city, there are $$$n$$$ houses. There is  exactly one directed road between every pair of houses. For example, consider two houses A and B, then there is a directed road either from A to B or from B to A but not both. The number of roads leading to the $$$i$$$-th house is $$$k_i$$$.Two houses A and B are bi-reachable if A is reachable from B and B is reachable from A. We say that house B is reachable from house A when there is a path from house A to house B.Dixit wants to buy two houses in the city, that is, one for living and one for studying. Of course, he would like to travel from one house to another. So, he wants to find a pair of bi-reachable houses A and B. Among all such pairs, he wants to choose one with the maximum value of $$$|k_A - k_B|$$$, where $$$k_i$$$ is the number of roads leading to the house $$$i$$$. If more than one optimal pair exists, any of them is suitable.Since Dixit is busy preparing CodeCraft, can you help him find the desired pair of houses, or tell him that no such houses exist?In the problem input, you are not given the direction of each road. You are given — for each house — only the number of incoming roads to that house ($$$k_i$$$).You are allowed to ask only one type of query from the judge: give two houses A and B, and the judge answers whether B is reachable from A. There is no upper limit on the number of queries. But, you cannot ask more queries after the judge answers \"Yes\" to any of your queries. Also, you cannot ask the same query twice.Once you have exhausted all your queries (or the judge responds \"Yes\" to any of your queries), your program must output its guess for the two houses and quit.See the Interaction section below for more details.[SOURCE CODE]import os,sys\r\nfrom random import randint\r\nfrom io import BytesIO, IOBase\r\n\r\nfrom collections import defaultdict,deque,Counter\r\nfrom bisect import bisect_left,bisect_right\r\nfrom heapq import heappush,heappop\r\nfrom functools import lru_cache\r\nfrom itertools import accumulate\r\nimport math\r\n\r\n# Fast IO Region\r\nBUFSIZE = 8192\r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\n\r\n\r\n# for _ in range(int(input())):\r\n#     n = int(input())\r\n#     a = list(map(int, input().split()))\r\n\r\n# for _ in range(int(input())):\r\n#     n = int(input())\r\n#     for i in range(n, n + 100000000):\r\n#         s = str(i)\r\n#         x = 0\r\n#         for j in range(len(s)):\r\n#             x += int(s[j])\r\n#         if math.gcd(x, i) > 1:\r\n#             print(i)\r\n#             break\r\n\r\n# for _ in range(int(input())):\r\n#     n, w = list(map(int, input().split()))\r\n#     a = list(map(int, input().split()))\r\n#     cnt = Counter(a)\r\n#     cnt = sorted([[i, j] for i, j in cnt.items()])\r\n#     ans = 0\r\n#     tot = 0\r\n#     for i, j in cnt:\r\n#         tot += j\r\n#     while tot > 0:\r\n#         i = len(cnt) - 1\r\n#         cur = 0\r\n#         while i >= 0 and cur < w:\r\n#             wi, c = cnt[i]\r\n#             if wi * c <= w - cur:\r\n#                 cur += wi * c\r\n#                 cnt[i][1] = 0\r\n#                 tot -= c\r\n#             else:\r\n#                 k = (w - cur) \/\/ wi\r\n#                 cur += k * wi\r\n#                 cnt[i][1] -= k\r\n#                 tot -= k\r\n#             i -= 1\r\n#         ans += 1\r\n#     print(ans)\r\n\r\n# mod = 10 ** 9 + 7\r\n# for _ in range(int(input())):\r\n#     n, k = list(map(int, input().split()))\r\n#     if k == 1:\r\n#         print(1)\r\n#         continue\r\n#     if n == 1:\r\n#         print(2)\r\n#         continue\r\n#     ans = 1 + n\r\n#     a = [1] * (n - 1)\r\n#     for i in range(k - 2):\r\n#         if i % 2 == 0:\r\n#             for j in range(n - 2)[::-1]:\r\n#                 a[j] = (a[j] + a[j + 1]) % mod\r\n#         else:\r\n#             for j in range(1, n - 1):\r\n#                 a[j] = (a[j] + a[j - 1]) % mod\r\n#         ans += sum(a)\r\n#     print(ans % mod)\r\n\r\n# N = 10 ** 5\r\n# n, m = list(map(int, input().split()))\r\n# q = deque()\r\n# q.append(0)\r\n# vis = [0] * (m + 1)\r\n# vis[0] = 1\r\n# ans = [-1] * (m + 1)\r\n# for idx in range(n):\r\n#     t, x, y = list(map(int, input().split()))\r\n#     if t == 1:\r\n#         x = (x + N - 1) \/\/ N\r\n#         for i in range(x):\r\n#             k = -1\r\n#             for j in range(i, m + 1, x):\r\n#                 if vis[j] == 1:\r\n#                     k = 0\r\n#                 elif k != -1:\r\n#                     k += 1\r\n#                     if vis[j] == 0 and k <= y:\r\n#                         ans[j] = idx + 1\r\n#                         vis[j] = 1\r\n#     else:\r\n#         vis2 = [0] * (m + 1)\r\n#         for i in range(1, m + 1):\r\n#             if vis2[i] == 0:\r\n#                 vis2[i] = 1\r\n#                 j = i\r\n#                 k = -1\r\n#                 while j <= m:\r\n#                     vis2[j] = 1\r\n#                     if vis[j] == 1:\r\n#                         k = 0\r\n#                     elif k != -1:\r\n#                         k += 1\r\n#                         if vis[j] == 0 and k <= y:\r\n#                             ans[j] = idx + 1\r\n#                             vis[j] = 1\r\n#                     j = (j * x + N - 1) \/\/ N\r\n# print(*ans[1:])\r\n\r\ndef solve():           \r\n    n = int(input())\r\n    a = list(map(int, input().split()))\r\n    # id = [i for i in range(n)]\r\n    # id.sort(key=lambda x : a[x], reverse=True)\r\n    id = []\r\n    for i in range(n):\r\n        for j in range(n):\r\n            if a[i] > a[j] or (a[i] == a[j] and i != j):\r\n                id.append([i, j])\r\n    # print(id)\r\n    id.sort(key=lambda x : a[x[1]] - a[x[0]])\r\n    # for i in range(n):\r\n    #     for j in range(i + 1, n)[::-1]:\r\n    #         print('?', id[i] + 1, id[j] + 1)\r\n    #             sys.stdout.flush()\r\n    #             if input() == 'Yes':\r\n    #                 print('!', id[i] + 1, id[j] + 1)\r\n    #                 sys.stdout.flush()\r\n    #                 return\r\n    for i, j in id:\r\n        print('?', i + 1, j + 1)\r\n        sys.stdout.flush()\r\n        if input() == 'Yes':\r\n            print('!', i + 1, j + 1)\r\n            sys.stdout.flush()\r\n            return\r\n    print('!', 0, 0)\r\n    sys.stdout.flush()\r\nsolve()","tags":["graphs"],"src_uid":"90a9d883408d5c283d6e7680c0b94c8b"}
{"text_full":"[DESCRIPTION]Your friend Salem is Warawreh's brother and only loves math and geometry problems. He has solved plenty of such problems, but according to Warawreh, in order to graduate from university he has to solve more graph problems. Since Salem is not good with graphs he asked your help with the following problem.  You are given a complete directed graph with $$$n$$$ vertices without self-loops. In other words, you have $$$n$$$ vertices and each pair of vertices $$$u$$$ and $$$v$$$ ($$$u \\neq v$$$) has both directed edges $$$(u, v)$$$ and $$$(v, u)$$$.Every directed edge of the graph is labeled with a single character: either 'a' or 'b' (edges $$$(u, v)$$$ and $$$(v, u)$$$ may have different labels).You are also given an integer $$$m &gt; 0$$$. You should find a path of length $$$m$$$ such that the string obtained by writing out edges' labels when going along the path is a palindrome. The length of the path is the number of edges in it.You can visit the same vertex and the same directed edge any number of times.[SOURCE CODE]import sys\n\ndef read_ints():\n    return [int(i) for i in sys.stdin.readline().strip().split()]\n\ndef read_int():\n    return int(sys.stdin.readline().strip())\n\ndef check_and_output(lines, nodes):\n    route = [lines[int(i)-1][int(j)-1] for i, j in zip(nodes[:-1],\n        nodes[1:])]\n    in_reverse = list(reversed(route))\n    print(\"YES\")\n    print(\" \".join(nodes))\n    #print(\"\".join(route))\n    #assert \"*\" not in route, \"self loop in route \" + route\n    #assert route == in_reverse, \" \".join(route) + \" is not palindrome\"\n\n\ndef nodes_for_3graph(length, start, middle, end):\n    #print(\"start %s middle %s end %s\" % (start, middle, end))\n    return [(start if (d + length \/\/ 2) % 2 else middle) for d in range(length \/\/ 2 + 1)] + [(middle if d % 2 else end) for d in range(length \/\/ 2)]\n\ndef output_for_3graph(lines, length, start, middle, end):\n    nodes = nodes_for_3graph(length, start, middle, end)\n    check_and_output(lines, nodes)\n\ndef solve(n, length, lines):\n    #print(length, \"-\".join(lines))\n    if length % 2 == 1:\n        nodes = [(\"1\" if d % 2 else \"2\") for d in range(length + 1)]\n        check_and_output(lines, nodes)\n        return\n\n    for i in range(n):\n        for j in range(n):\n            if i != j and lines[i][j] == lines[j][i]:\n                nodes = [str(i + 1 if d % 2 else j + 1) for d in range(length + 1)]\n                check_and_output(lines, nodes)\n                return\n\n    if n == 2:\n        print(\"NO\")\n        return\n\n    if length == 2:\n        for i in range(n):\n            for j in range(n):\n                for k in range(n):\n                    if i != j and j != k and i != k:\n                        if lines[i][j] == lines[j][k]:\n                            nodes = [str(i + 1), str(j + 1), str(k + 1)]\n                            check_and_output(lines, nodes)\n                            return\n        print(\"NO\")\n        return\n\n    # consider only nodes 1, 2, 3\n    if lines[0][1] == lines[1][2] == lines[2][0]:\n        nodes = [str((d % 3) + 1) for d in range(length + 1)]\n        check_and_output(lines, nodes)\n        return\n\n    if lines[0][2] == lines[2][1] == lines[1][0]:\n        nodes = [str(3 - (d % 3)) for d in range(length + 1)]\n        check_and_output(lines, nodes)\n        return\n\n    # centre at node 0 (1)\n    if lines[0][1] == lines[2][0]:\n        output_for_3graph(lines, length, \"2\", \"1\", \"3\")\n        return\n\n    # centre at node 1 (2)\n    if lines[0][1] == lines[1][2]:\n        output_for_3graph(lines, length, \"1\", \"2\", \"3\")\n        return\n\n    # centre at node 2 (3)\n    if lines[0][2] == lines[2][1]:\n        output_for_3graph(lines, length, \"1\", \"3\", \"2\")\n        return\n\n\n\nncases = read_int()\nlines = []\n\n\"\"\"\nskip = False\nif ncases == 320:\n    n, length = read_ints()\n    skip = True\n    if length == 6:\n        for j in range(n):\n            lines.append(sys.stdin.readline().strip())\n\n        for i in range(53):\n            lines = []\n            n, length = read_ints()\n            for j in range(n):\n                lines.append(sys.stdin.readline().strip())\n        output = \"\";\n        for i in range(20):\n            output += sys.stdin.readline().strip() + \"----\"\n        print(output)\n        \"\"\"\n\nfor i in range(ncases):\n    lines = []\n    n, length = read_ints()\n    skip = False\n    for j in range(n):\n        lines.append(sys.stdin.readline().strip())\n    solve(n, length, lines)","tags":["graphs"],"src_uid":"79b629047e674883a9bc04b1bf0b7f09"}
{"text_full":"[DESCRIPTION]Recently Vova found $$$n$$$ candy wrappers. He remembers that he bought $$$x$$$ candies during the first day, $$$2x$$$ candies during the second day, $$$4x$$$ candies during the third day, $$$\\dots$$$, $$$2^{k-1} x$$$ candies during the $$$k$$$-th day. But there is an issue: Vova remembers neither $$$x$$$ nor $$$k$$$ but he is sure that $$$x$$$ and $$$k$$$ are positive integers and $$$k &gt; 1$$$.Vova will be satisfied if you tell him any positive integer $$$x$$$ so there is an integer $$$k&gt;1$$$ that $$$x + 2x + 4x + \\dots + 2^{k-1} x = n$$$. It is guaranteed that at least one solution exists. Note that $$$k &gt; 1$$$.You have to answer $$$t$$$ independent test cases.[SOURCE CODE]from __future__ import division, print_function\n \nimport os,sys\nfrom io import BytesIO, IOBase\n \nif sys.version_info[0] < 3:\n    from __builtin__ import xrange as range\n    from future_builtins import ascii, filter, hex, map, oct, zip\n \n \ndef ii():  return int(input())\ndef si():  return input()\ndef mi():  return map(int,input().split(\" \"))\ndef msi(): return map(str,input().split(\" \"))\ndef li():  return list(mi())\n \ndef dmain():\n    sys.setrecursionlimit(1000000)\n    threading.stack_size(1024000)\n    thread = threading.Thread(target=main)\n    thread.start()\n    \n#from collections import deque, Counter, OrderedDict,defaultdict\n#from heapq import nsmallest, nlargest, heapify,heappop ,heappush, heapreplace\nimport math\n#from bisect import bisect,bisect_left,bisect_right,insort,insort_left,insort_right\n#from decimal import *\n#import threading\n#from itertools import permutations\n#Copy 2D list  m = [x[:] for x in mark] .. Avoid Using Deepcopy\n \nabc='abcdefghijklmnopqrstuvwxyz'\nabd={'a': 0, 'b': 1, 'c': 2, 'd': 3, 'e': 4, 'f': 5, 'g': 6, 'h': 7, 'i': 8, 'j': 9, 'k': 10, 'l': 11, 'm': 12, 'n': 13, 'o': 14, 'p': 15, 'q': 16, 'r': 17, 's': 18, 't': 19, 'u': 20, 'v': 21, 'w': 22, 'x': 23, 'y': 24, 'z': 25}\nmod=1000000007\n#mod=998244353\ninf = float(\"inf\")\nvow=['a','e','i','o','u']\ndx,dy=[-1,1,0,0],[0,0,1,-1]\ndef getKey(item): return item[1] \ndef sort2(l):return sorted(l, key=getKey,reverse=True)\ndef d2(n,m,num):return [[num for x in range(m)] for y in range(n)]\ndef isPowerOfTwo (x): return (x and (not(x & (x - 1))) )\ndef decimalToBinary(n): return bin(n).replace(\"0b\",\"\")\ndef ntl(n):return [int(i) for i in str(n)]\ndef ncr(n,r): return factorial(n)\/\/(factorial(r)*factorial(max(n-r,1)))\n \ndef ceil(x,y):\n    if x%y==0:\n        return x\/\/y\n    else:\n        return x\/\/y+1\n \ndef powerMod(x,y,p):\n    res = 1\n    x %= p\n    while y > 0:\n        if y&1:\n            res = (res*x)%p\n        y = y>>1\n        x = (x*x)%p\n    return res\n \ndef gcd(x, y):\n    while y:\n        x, y = y, x % y\n    return x\n    \ndef isPrime(n) : # Check Prime Number or not \n    if (n <= 1) : return False\n    if (n <= 3) : return True\n    if (n % 2 == 0 or n % 3 == 0) : return False\n    i = 5\n    while(i * i <= n) : \n        if (n % i == 0 or n % (i + 2) == 0) : \n            return False\n        i = i + 6\n    return True\n \n \n \ndef read():\n    sys.stdin = open('input.txt', 'r')  \n    sys.stdout = open('output.txt', 'w') \n \ndef main():\n    \n    for _ in range(ii()):\n        n=ii()\n        k=2\n        while True:\n            if (int(n%(pow(2,k)-1))==0):\n                print(int(n\/(pow(2,k)-1)))\n                break\n            k+=1\n            \n# region fastio\n# template taken from https:\/\/github.com\/cheran-senthil\/PyRival\/blob\/master\/templates\/template.py\n \nBUFSIZE = 8192\n \n \nclass FastIO(IOBase):\n    newlines = 0\n \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n \n \ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n \n \nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n \ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n \n# endregion\n \n \nif __name__ == \"__main__\":\n    #read()\n    main()\n    #dmain()\n \n# Comment Read()","tags":["math"],"src_uid":"d04cbe78b836e53b51292401c8c969b2"}
{"text_full":"[DESCRIPTION]You are given a string $$$s$$$, consisting only of Latin letters 'a', and a string $$$t$$$, consisting of lowercase Latin letters.In one move, you can replace any letter 'a' in the string $$$s$$$ with a string $$$t$$$. Note that after the replacement string $$$s$$$ might contain letters other than 'a'.You can perform an arbitrary number of moves (including zero). How many different strings can you obtain? Print the number, or report that it is infinitely large.Two strings are considered different if they have different length, or they differ at some index.[SOURCE CODE]'''\r\n# Submitted By Ala3rjMo7@gmail.com\r\nDon't Copy This Code, Try To Solve It By Yourself\r\n'''\r\n# Problem Name = \"Infinite Replacement\"\r\n# Class: C\r\n \r\ndef Solve():\r\n    ss, rs = [], []\r\n    for t in range(int(input())):\r\n        ss.append(input())\r\n        rs.append(input())\r\n    for s, r in zip(ss, rs):\r\n        if \"a\" in s:\r\n            if r==\"a\":\r\n                print(1)\r\n            elif \"a\" in r:\r\n                print(-1)\r\n            else:\r\n                print(2**len(s))\r\n        else:\r\n            print(0)\r\n \r\n \r\nif __name__ == \"__main__\":\r\n    Solve()","tags":["strings"],"src_uid":"d6ac9ca9cc5dfd9f43f5f65ce226349e"}
{"text_full":"[DESCRIPTION]You are given a directed acyclic graph, consisting of $$$n$$$ vertices and $$$m$$$ edges. The vertices are numbered from $$$1$$$ to $$$n$$$. There are no multiple edges and self-loops.Let $$$\\mathit{in}_v$$$ be the number of incoming edges (indegree) and $$$\\mathit{out}_v$$$ be the number of outgoing edges (outdegree) of vertex $$$v$$$.You are asked to remove some edges from the graph. Let the new degrees be $$$\\mathit{in'}_v$$$ and $$$\\mathit{out'}_v$$$.You are only allowed to remove the edges if the following conditions hold for every vertex $$$v$$$:   $$$\\mathit{in'}_v &lt; \\mathit{in}_v$$$ or $$$\\mathit{in'}_v = \\mathit{in}_v = 0$$$;  $$$\\mathit{out'}_v &lt; \\mathit{out}_v$$$ or $$$\\mathit{out'}_v = \\mathit{out}_v = 0$$$. Let's call a set of vertices $$$S$$$ cute if for each pair of vertices $$$v$$$ and $$$u$$$ ($$$v \\neq u$$$) such that $$$v \\in S$$$ and $$$u \\in S$$$, there exists a path either from $$$v$$$ to $$$u$$$ or from $$$u$$$ to $$$v$$$ over the non-removed edges.What is the maximum possible size of a cute set $$$S$$$ after you remove some edges from the graph and both indegrees and outdegrees of all vertices either decrease or remain equal to $$$0$$$?[SOURCE CODE]import sys\r\nfrom collections import defaultdict\r\nn, m = tuple(map(int,input().split()))\r\nadj = defaultdict(list)\r\nindg = [0] * n\r\noutdg = [0] * n\r\ndp = [1] * n\r\nvis = set()\r\nfinish = []\r\n\r\ndef dfs(u):\r\n    vis.add(u)\r\n    for v in adj[u]:\r\n        if v not in vis:\r\n            dfs(v)\r\n    finish.append(u)\r\n\r\nfor _ in range(m):     \r\n    u, v = tuple(map(int,input().split()))\r\n    u -= 1\r\n    v -= 1\r\n    adj[u].append(v)\r\n    indg[v] += 1\r\n    outdg[u] += 1\r\n    \r\nfor i in range(n):\r\n    if i not in vis:\r\n        stk = [i] \r\n        while stk:\r\n            u = stk.pop()\r\n            if u in vis:\r\n                finish.append(u)\r\n                continue\r\n            vis.add(u)\r\n            stk.append(u)\r\n            for v in adj[u]:\r\n                if v not in vis:\r\n                    stk.append(v)         \r\nres = 1\r\nfor i in finish:\r\n    if outdg[i] > 1:\r\n        for v in adj[i]:\r\n            if indg[v] > 1:\r\n                dp[i] = max(dp[i], dp[v] + 1)\r\n        res = max(res, dp[i])\r\n                \r\nprint(res)","tags":["graphs"],"src_uid":"2d3af7ca9bf074d03408d5ade3ddd14c"}
{"text_full":"[DESCRIPTION]This is an interactive problem.We picked an array of whole numbers $$$a_1, a_2, \\ldots, a_n$$$ ($$$0 \\le a_i \\le 10^9$$$) and concealed exactly one zero in it! Your goal is to find the location of this zero, that is, to find $$$i$$$ such that $$$a_i = 0$$$.You are allowed to make several queries to guess the answer. For each query, you can think up three distinct indices $$$i, j, k$$$, and we will tell you the value of $$$\\max(a_i, a_j, a_k) - \\min(a_i, a_j, a_k)$$$. In other words, we will tell you the difference between the maximum and the minimum number among $$$a_i$$$, $$$a_j$$$ and $$$a_k$$$.You are allowed to make no more than $$$2 \\cdot n - 2$$$ queries, and after that you have two tries to guess where the zero is. That is, you have to tell us two numbers $$$i$$$ and $$$j$$$ and you win if $$$a_i = 0$$$ or $$$a_j = 0$$$.Can you guess where we hid the zero?Note that the array in each test case is fixed beforehand and will not change during the game. In other words, the interactor is not adaptive.[SOURCE CODE]from sys import stdin, stdout, exit\r\ninput = stdin.readline\r\n\r\ndef f(i, j, k):\r\n    aaa = [i, j, k]\r\n    aaa.sort()\r\n    i, j, k = aaa[0], aaa[1], aaa[2]\r\n    \r\n    if (i, j, k) in d.keys():\r\n        return d[(i, j, k)]\r\n\r\n    print('?', i, j, k)\r\n    stdout.flush()\r\n\r\n    a = int(input())\r\n\r\n    d[(i, j, k)] = a\r\n\r\n    return a\r\n\r\nt = int(input())\r\n\r\nfor _ in range(t):\r\n    n = int(input())\r\n    d = dict()\r\n    aa = []\r\n\r\n    for x in range(3, n + 1):\r\n        b = f(1, 2, x)\r\n        aa.append([b, x])\r\n\r\n    aa.sort()\r\n\r\n    bb = []\r\n\r\n    if aa[0][0] == aa[-1][0]:\r\n        for x in range(1, n + 1):\r\n            if x == 3 or x == 4:\r\n                continue\r\n\r\n            c = f(3, 4, x)\r\n            bb.append([c, x])\r\n\r\n        bb.sort()\r\n\r\n        if bb[0][0] == bb[-1][0]:\r\n            t1 = f(1, 2, 3)\r\n            t2 = f(3, 4, 1)\r\n\r\n            if t1 > t2:\r\n                print('!', 1, 2)\r\n            else:\r\n                print('!', 3, 4)\r\n        else:\r\n            tt1, tt2, tt3, tt4 = 1, 2, bb[-1][1], bb[-2][1]\r\n\r\n            if bb[-1][1] == 1 or bb[-1][1] == 2:\r\n                tt3 = 3\r\n\r\n            if bb[-2][1] == 1 or bb[-2][1] == 2 or bb[-2][1] == tt3:\r\n                if tt3 == 3:\r\n                    tt4 = 4\r\n                else:\r\n                    tt4 = 3\r\n\r\n            cc1 = f(tt1, tt2, tt3)\r\n            cc2 = f(tt1, tt2, tt4)\r\n            cc3 = f(tt1, tt3, tt4)\r\n            cc4 = f(tt2, tt3, tt4)\r\n\r\n            cc34 = min(cc3, cc4)\r\n\r\n            if cc34 < cc1:\r\n                print('!', tt1, tt2)\r\n            else:\r\n                print('!', tt3, tt4)\r\n\r\n        stdout.flush()\r\n\r\n    else:\r\n        if aa[-1][0] > aa[-2][0]:\r\n            b1 = aa[-1][1]\r\n            a1 = 1\r\n            ee = []\r\n\r\n            for x in range(1, n + 1):\r\n                if x == b1 or x == a1:\r\n                    continue\r\n\r\n                tt = f(b1, a1, x)\r\n\r\n                ee.append([tt, x])\r\n\r\n            ee.sort()\r\n\r\n            if ee[-1][0] == ee[0][0]:\r\n                print('!', b1, a1)\r\n            else:\r\n                print('!', b1, ee[-1][1])\r\n\r\n            stdout.flush()\r\n\r\n        else:\r\n            b1 = aa[-1][1]\r\n            b2 = aa[-2][1]\r\n            ee = []\r\n\r\n            for x in range(1, n + 1):\r\n                if x == b1 or x == b2:\r\n                    continue\r\n\r\n                tt = f(b1, b2, x)\r\n\r\n                ee.append([tt, x])\r\n\r\n            ee.sort()\r\n\r\n            if ee[0][0] == ee[-1][0]:\r\n                print('!', b1, b2)\r\n            else:\r\n                print('!', ee[-1][1], b1)\r\n\r\n            stdout.flush()\r\n\r\n    print()\r\n    stdout.flush()","tags":["math"],"src_uid":"84e79bd83c51a4966b496bb767ec4f0d"}
{"text_full":"[DESCRIPTION]The grasshopper is located on the numeric axis at the point with coordinate $$$x_0$$$.Having nothing else to do he starts jumping between integer points on the axis. Making a jump from a point with coordinate $$$x$$$ with a distance $$$d$$$ to the left moves the grasshopper to a point with a coordinate $$$x - d$$$, while jumping to the right moves him to a point with a coordinate $$$x + d$$$.The grasshopper is very fond of positive integers, so for each integer $$$i$$$ starting with $$$1$$$ the following holds: exactly $$$i$$$ minutes after the start he makes a jump with a distance of exactly $$$i$$$. So, in the first minutes he jumps by $$$1$$$, then by $$$2$$$, and so on.The direction of a jump is determined as follows: if the point where the grasshopper was before the jump has an even coordinate, the grasshopper jumps to the left, otherwise he jumps to the right.For example, if after $$$18$$$ consecutive jumps he arrives at the point with a coordinate $$$7$$$, he will jump by a distance of $$$19$$$ to the right, since $$$7$$$ is an odd number, and will end up at a point $$$7 + 19 = 26$$$. Since $$$26$$$ is an even number, the next jump the grasshopper will make to the left by a distance of $$$20$$$, and it will move him to the point $$$26 - 20 = 6$$$.Find exactly which point the grasshopper will be at after exactly $$$n$$$ jumps.[SOURCE CODE]t=int(input())\r\nfor _ in range(t):\r\n    x,times=map(int,input().split())\r\n    x=int(x)\r\n    times=int(times)\r\n    r=times%4\r\n    d=times\/\/4*4+1\r\n    for i in range(r):\r\n        if x%2==0:\r\n            x-=d\r\n        else:\r\n            x+=d\r\n        d+=1\r\n    print(x)","tags":["math"],"src_uid":"dbe12a665c374ce3745e20b4a8262eac"}
{"text_full":"[DESCRIPTION]You are given a tree consisting of $$$n$$$ vertices. Recall that a tree is an undirected connected acyclic graph. The given tree is rooted at the vertex $$$1$$$.You have to process $$$q$$$ queries. In each query, you are given a vertex of the tree $$$v$$$ and an integer $$$k$$$.To process a query, you may delete any vertices from the tree in any order, except for the root and the vertex $$$v$$$. When a vertex is deleted, its children become the children of its parent. You have to process a query in such a way that maximizes the value of $$$c(v) - m \\cdot k$$$ (where $$$c(v)$$$ is the resulting number of children of the vertex $$$v$$$, and $$$m$$$ is the number of vertices you have deleted). Print the maximum possible value you can obtain.The queries are independent: the changes you make to the tree while processing a query don't affect the tree in other queries.[SOURCE CODE]import sys, collections\r\nn = int(sys.stdin.readline())\r\ne = [[] for i in range(n+1)]\r\nfor i in range(n-1):\r\n    a, b = [int(i) for i in sys.stdin.readline().split()]\r\n    e[a].append(b)\r\n    e[b].append(a)\r\no = [len(e[i])-1 for i in range(0, n+1)]\r\no[1]+=1\r\nr = [[] for i in range(n+1)]\r\nst = collections.deque([1])\r\nd = [0]*(n+1)\r\np = [0]*(n+1)\r\nwhile st:\r\n    x = st.popleft()\r\n    for i in e[x]:\r\n        if i != p[x]: st.append(i); d[i] = d[x]+1; p[i] = x\r\nd = [(d[i], i) for i in range(1,n+1)]\r\nd.sort(key=lambda x:x[0], reverse=True)\r\nfor _, v in d:\r\n    r[v] = [o[v]]*max(max(len(r[i]) for i in e[v]), o[v]-1)\r\n    for i in e[v]:\r\n        if i == p: continue\r\n        for idx, x in enumerate(r[i]):\r\n            r[v][idx]+=max(x-idx-1, 0)\r\nfor q in range(int(sys.stdin.readline())):\r\n    v, k = [int(i) for i in sys.stdin.readline().split()]\r\n    if k >= len(r[v]): print(o[v])\r\n    else: print(r[v][k])","tags":["trees"],"src_uid":"c7f0fefd9616e4ba2d309a7c5c8a8a0a"}
{"text_full":"[DESCRIPTION]You are given three integers $$$n$$$, $$$l$$$, and $$$r$$$. You need to construct an array $$$a_1,a_2,\\dots,a_n$$$ ($$$l\\le a_i\\le r$$$) such that $$$\\gcd(i,a_i)$$$ are all distinct or report there's no solution.Here $$$\\gcd(x, y)$$$ denotes the greatest common divisor (GCD) of integers $$$x$$$ and $$$y$$$.[SOURCE CODE]for _ in range(int(input())):\r\n    n,l,r=[int(num) for num in input().split(\" \",2)]\r\n    truth=True\r\n    for i in range(1,n+1):\r\n        if i*(1+(l-1)\/\/i)>r:\r\n            print(\"No\")\r\n            truth=False\r\n            break\r\n    if truth:\r\n        print(\"Yes\")\r\n        a=[i*(1+(l-1)\/\/i) for i in range(1,n+1)]\r\n        print(*a)","tags":["math"],"src_uid":"d2cc6efe7173a64482659ba59efeec16"}
{"text_full":"[DESCRIPTION]You are given an array $$$a$$$ consisting of $$$n$$$ positive integers.You are allowed to perform this operation any number of times (possibly, zero):   choose an index $$$i$$$ ($$$2 \\le i \\le n$$$), and change $$$a_i$$$ to $$$a_i - a_{i-1}$$$. Is it possible to make $$$a_i=0$$$ for all $$$2\\le i\\le n$$$?[SOURCE CODE]for _ in range(int(input())): \r\n    n = int(input()) \r\n    a = [int(i) for i in input().split()]\r\n    for _ in range(n): \r\n        for i in range(n-1, 0, -1): \r\n            q = a[i]%a[i-1] \r\n            if q == 0 : q = a[i-1] \r\n            a[i] = q\r\n\r\n    if len(set(a)) == 1 : print(\"YES\") \r\n    else : print(\"NO\")","tags":["math"],"src_uid":"1c597da89880e87ffe791dd6b9fb2ac7"}
{"text_full":"[DESCRIPTION]$$$n$$$ players are playing a game. There are two different maps in the game. For each player, we know his strength on each map. When two players fight on a specific map, the player with higher strength on that map always wins. No two players have the same strength on the same map. You are the game master and want to organize a tournament. There will be a total of $$$n-1$$$ battles. While there is more than one player in the tournament, choose any map and any two remaining players to fight on it. The player who loses will be eliminated from the tournament. In the end, exactly one player will remain, and he is declared the winner of the tournament. For each player determine if he can win the tournament.[SOURCE CODE]import os\r\nimport sys\r\nfrom io import BytesIO, IOBase\r\n\r\n## PYRIVAL BOOTSTRAP\r\n# https:\/\/github.com\/cheran-senthil\/PyRival\/blob\/master\/pyrival\/misc\/bootstrap.py\r\n# This decorator allows for recursion without actually doing recursion\r\nfrom types import GeneratorType\r\n## @bootstrap, yield when getting and returning value in recursive functions\r\n\r\n\r\ndef main():\r\n    @bootstrap\r\n    def dfs(value):\r\n        for v in beaten_by[value]:\r\n            if iptw[v] == '1':\r\n                continue\r\n            else:\r\n                iptw[v] = '1'\r\n                yield dfs(v)\r\n        yield\r\n\r\n    for _ in range(iip()):\r\n        n = iip()\r\n        a = liip()\r\n        b = liip()\r\n\r\n        beaten_by = [set() for _ in range(n)]\r\n        li = []\r\n        for i in range(n):\r\n            li.append((a[i], b[i], i))\r\n\r\n        starts = set()\r\n\r\n        li.sort(key=lambda x: -x[0])\r\n        starts.add(li[0][2])\r\n        for i in range(n - 1):\r\n            beaten_by[li[i + 1][2]].add(li[i][2])\r\n\r\n        li.sort(key=lambda x: -x[1])\r\n        starts.add(li[0][2])\r\n        for i in range(n - 1):\r\n            beaten_by[li[i + 1][2]].add(li[i][2])\r\n\r\n        iptw = ['0'] * n # is possible to win\r\n        for v in starts:\r\n            iptw[v] = '1'\r\n\r\n        for start in starts:\r\n            dfs(start)\r\n\r\n        print(''.join(iptw))\r\n\r\n    \r\n# region fastio\r\n \r\nBUFSIZE = 8192\r\n \r\n\r\nclass FastIO(IOBase):\r\n    newlines = 0\r\n \r\n    def __init__(self, file):\r\n        self._fd = file.fileno()\r\n        self.buffer = BytesIO()\r\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\r\n        self.write = self.buffer.write if self.writable else None\r\n \r\n    def read(self):\r\n        while True:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            if not b:\r\n                break\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines = 0\r\n        return self.buffer.read()\r\n \r\n    def readline(self):\r\n        while self.newlines == 0:\r\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\r\n            self.newlines = b.count(b\"\\n\") + (not b)\r\n            ptr = self.buffer.tell()\r\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\r\n        self.newlines -= 1\r\n        return self.buffer.readline()\r\n \r\n    def flush(self):\r\n        if self.writable:\r\n            os.write(self._fd, self.buffer.getvalue())\r\n            self.buffer.truncate(0), self.buffer.seek(0)\r\n \r\n \r\nclass IOWrapper(IOBase):\r\n    def __init__(self, file):\r\n        self.buffer = FastIO(file)\r\n        self.flush = self.buffer.flush\r\n        self.writable = self.buffer.writable\r\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\r\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\r\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\r\n \r\n \r\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\r\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\r\n \r\n# endregion\r\n \r\nif __name__ == \"__main__\":\r\n    def bootstrap(f, stack=[]):\r\n        def wrappedfunc(*args, **kwargs):\r\n            if stack:\r\n                return f(*args, **kwargs)\r\n            else:\r\n                to = f(*args, **kwargs)\r\n                while True:\r\n                    if type(to) is GeneratorType:\r\n                        stack.append(to)\r\n                        to = next(to)\r\n                    else:\r\n                        stack.pop()\r\n                        if not stack:\r\n                            break\r\n                        to = stack[-1].send(to)\r\n                return to\r\n        return wrappedfunc\r\n    \r\n    ip = lambda: input()\r\n    iip = lambda: int(input())\r\n    miip = lambda: map(int, input().split())\r\n    liip = lambda: list(map(int, input().split()))\r\n    sip = lambda: input().split() # splitted input\r\n    lip = lambda: list(input())\r\n    \r\n    main()","tags":["graphs"],"src_uid":"f9cf1a6971a7003078b63195198e5a51"}
{"text_full":"[DESCRIPTION]For an array of non-negative integers $$$a$$$ of size $$$n$$$, we construct another array $$$d$$$ as follows: $$$d_1 = a_1$$$, $$$d_i = |a_i - a_{i - 1}|$$$ for $$$2 \\le i \\le n$$$.Your task is to restore the array $$$a$$$ from a given array $$$d$$$, or to report that there are multiple possible arrays.[SOURCE CODE]for _ in range(int(input())):\r\n    n=int(input())\r\n    d=list(map(int,input().split()))\r\n    ans=[]\r\n    ans.append(d[0])\r\n    \r\n    count=0\r\n    # print(ans[1]+d[2])\r\n    for i in range(1,n):\r\n        \r\n        first=ans[i-1]+d[i]\r\n        second=ans[i-1]-d[i]\r\n        \r\n        if first>=0 and second>=0 and first!=second:\r\n            count+=1\r\n            break\r\n            \r\n        else:\r\n            ans.append(first)\r\n    if count==0:\r\n        print(*ans)\r\n    else:\r\n        print(-1)","tags":["math"],"src_uid":"f4b790bef9a6cbcd5d1f9235bcff7c8f"}
{"text_full":"[DESCRIPTION]Consider a game with $$$n$$$ cards ($$$n$$$ is even). Each card has a number written on it, between $$$1$$$ and $$$n$$$. All numbers on the cards are different. We say that a card with number $$$x$$$ is stronger than a card with number $$$y$$$ if $$$x &gt; y$$$.Two players, Alex and Boris, play this game. In the beginning, each of them receives exactly $$$\\frac{n}{2}$$$ cards, so each card belongs to exactly one player. Then, they take turns. Alex goes first, then Boris, then Alex again, and so on.On a player's turn, he must play exactly one of his cards. Then, if the opponent doesn't have any cards stronger than the card played, the opponent loses, and the game ends. Otherwise, the opponent has to play a stronger card (exactly one card as well). These two cards are removed from the game, and the turn ends. If there are no cards left, the game ends in a draw; otherwise it's the opponent's turn.Consider all possible ways to distribute the cards between two players, so that each of them receives exactly half of the cards. You have to calculate three numbers:  the number of ways to distribute the cards so that Alex wins;  the number of ways to distribute the cards so that Boris wins;  the number of ways to distribute the cards so that the game ends in a draw. You may assume that both players play optimally (i. e. if a player can win no matter how his opponent plays, he wins). Two ways to distribute the cards are different if there is at least one card such that, in one of these ways, it is given to Alex, and in the other way, it is given to Boris.For example, suppose $$$n = 4$$$, Alex receives the cards $$$[2, 3]$$$, and Boris receives the cards $$$[1, 4]$$$. Then the game may go as follows:  if Alex plays the card $$$2$$$, then Boris has to respond with the card $$$4$$$. Then, Alex's turn ends, and Boris' turn starts. Boris has only one card left, which is $$$1$$$; he plays it, and Alex responds with the card $$$3$$$. So, the game ends in a draw;  if Alex plays the card $$$3$$$, then Boris has to respond with the card $$$4$$$. Then, Alex's turn ends, and Boris' turn starts. Boris has only one card left, which is $$$1$$$; he plays it, and Alex responds with the card $$$2$$$. So, the game ends in a draw. So, in this case, the game ends in a draw.[SOURCE CODE]# Libraries\r\n\r\nimport sys\r\nfrom math import *\r\nfrom queue import PriorityQueue\r\n\r\n# Definitions\r\nmod = 998244353\r\ne = pow(10,-6)\r\ninput = sys.stdin.readline\r\npq = PriorityQueue()\r\n# sys.setrecursionlimit(10**6)\r\n\r\n#Input forms\r\n\r\ndef imap():\r\n    return map(int,input().split())\r\n\r\ndef ilist():\r\n    return list(map(int,input().split()))\r\n\r\n# Common functions\r\n\r\ndef freq(l):\r\n    d = {}\r\n    for i in l:\r\n        d[i] = d.get(i,0)+1\r\n    return d\r\n\r\ndef lgcd(l):\r\n    a = 0\r\n    for i in l:\r\n        a = gcd(a,i)\r\n    return a\r\n\r\ndef SieveOfEratosthenes(num):\r\n    prime = [True for i in range(num+1)]\r\n    p = 2\r\n    while (p * p <= num):\r\n        if (prime[p] == True):\r\n            for i in range(p * p, num+1, p):\r\n                prime[i] = False\r\n        p += 1\r\n    return p[2:]\r\n\r\ndef bs_on_ans(l,r):\r\n    for i in range(100):\r\n        mid = (l+r)\/2\r\n        # if f(mid)>f(mid+e):\r\n        #     l = mid+e\r\n        # else:\r\n        #     if f(mid-e)>f(mid):\r\n        #         break\r\n        #     else:\r\n        #         r = mid-e\r\n    return mid\r\n    \r\n# Starting off; \r\n\r\nf = {0:1}\r\nfor i in range(1,61):\r\n    f[i] = (f[i-1]*i)\r\n    \r\nt = int(input())\r\nfor _ in range(t):\r\n    n = int(input())\r\n    a = 1\r\n    sum = -(f[n-1]\/\/(f[n\/\/2-1]*f[n\/\/2]))%mod\r\n    total = (f[n]\/\/(f[n\/\/2]*f[n\/\/2]))\r\n    while n>=2:\r\n        sum = ((sum)%mod + (2*f[n-1]\/\/(f[n\/\/2-1]*f[n\/\/2]))%mod)%mod\r\n        if n-4>=0 and a==0:\r\n            sum = ((sum)%mod + (f[n-1]\/\/(f[n\/\/2-2]*f[n\/\/2+1]))%mod)%mod\r\n        n-=4\r\n        a = 0\r\n\r\n    print(sum,(total-sum-1)%mod,1)\r\n\r\n\r\n\r\n\r\n\r\n###################################################### By Shri ##############################################################","tags":["games"],"src_uid":"63fc2fb08d248f8ccdb3f5364c96dac1"}
{"text_full":"[DESCRIPTION]You have an array $$$a_1, a_2, \\dots, a_n$$$ consisting of $$$n$$$ distinct integers. You are allowed to perform the following operation on it:  Choose two elements from the array $$$a_i$$$ and $$$a_j$$$ ($$$i \\ne j$$$) such that $$$\\gcd(a_i, a_j)$$$ is not present in the array, and add $$$\\gcd(a_i, a_j)$$$ to the end of the array. Here $$$\\gcd(x, y)$$$ denotes greatest common divisor (GCD) of integers $$$x$$$ and $$$y$$$. Note that the array changes after each operation, and the subsequent operations are performed on the new array.What is the maximum number of times you can perform the operation on the array?[SOURCE CODE]# import sys, os\r\n# if not os.environ.get(\"ONLINE_JUDGE\"):\r\n#     sys.stdin = open('in.txt', 'r')\r\n#     sys.stdout = open('out.txt', 'w')\r\n\r\n\r\n\r\nimport sys\r\nimport io, os\r\ninput = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline\r\nimport math\r\n\r\nn = int(input())\r\narr = list(map(int, input().split()))\r\n\r\nm = max(arr)\r\navail = {i:False for i in range(1, m+1)}\r\nfor i in arr:\r\n    avail[i] = True\r\nans = 0\r\nfor i in range(1, m+1):\r\n    if not avail[i]:\r\n        g = 0\r\n        for j in range(2*i, m+1, i):\r\n            if avail[j]:\r\n                g = math.gcd(g, j)\r\n        if g == i:\r\n            ans += 1\r\nprint(ans)","tags":["math","number theory"],"src_uid":"1a37e42263fdd1cb62e2a18313eed989"}
{"text_full":"[DESCRIPTION]Polycarp has a string $$$s$$$ consisting of lowercase Latin letters.He encodes it using the following algorithm.He goes through the letters of the string $$$s$$$ from left to right and for each letter Polycarp considers its number in the alphabet:  if the letter number is single-digit number (less than $$$10$$$), then just writes it out;  if the letter number is a two-digit number (greater than or equal to $$$10$$$), then it writes it out and adds the number 0 after. For example, if the string $$$s$$$ is code, then Polycarp will encode this string as follows:  'c' — is the $$$3$$$-rd letter of the alphabet. Consequently, Polycarp adds 3 to the code (the code becomes equal to 3);  'o' — is the $$$15$$$-th letter of the alphabet. Consequently, Polycarp adds 15 to the code and also 0 (the code becomes 3150);  'd' — is the $$$4$$$-th letter of the alphabet. Consequently, Polycarp adds 4 to the code (the code becomes 31504);  'e' — is the $$$5$$$-th letter of the alphabet. Therefore, Polycarp adds 5 to the code (the code becomes 315045). Thus, code of string code is 315045.You are given a string $$$t$$$ resulting from encoding the string $$$s$$$. Your task is to decode it (get the original string $$$s$$$ by $$$t$$$).[SOURCE CODE]import string\nq = int(input())\nfor i in range(q):\n  n = int(input())\n  str = list(input())\n  def my_function(x):\n    return x[::-1]\n  str = my_function(str)\n  ans = []\n  while(len(str)):\n    if int(str[0]) == 0:\n      ans.append(string.ascii_lowercase[int(str[2] + str[1])-1])\n      del str[0:3]\n    else:\n      ans.append(string.ascii_lowercase[int(str[0])-1])\n      del str[0]\n  answer = \"\".join(ans)\n  print(my_function(answer))","tags":["strings"],"src_uid":"43081557fe2fbac39dd9b72b137b8fb0"}
{"text_full":"[DESCRIPTION]You are given two non-empty strings $$$s$$$ and $$$t$$$, consisting of Latin letters.In one move, you can choose an occurrence of the string $$$t$$$ in the string $$$s$$$ and replace it with dots.Your task is to remove all occurrences of the string $$$t$$$ in the string $$$s$$$ in the minimum number of moves, and also calculate how many different sequences of moves of the minimum length exist.Two sequences of moves are considered different if the sets of indices at which the removed occurrences of the string $$$t$$$ in $$$s$$$ begin differ. For example, the sets $$$\\{1, 2, 3\\}$$$ and $$$\\{1, 2, 4\\}$$$ are considered different, the sets $$$\\{2, 4, 6\\}$$$ and $$$\\{2, 6\\}$$$ — too, but sets $$$\\{3, 5\\}$$$ and $$$\\{5, 3\\}$$$ — not.For example, let the string $$$s =$$$ \"abababacababa\" and the string $$$t =$$$ \"aba\". We can remove all occurrences of the string $$$t$$$ in $$$2$$$ moves by cutting out the occurrences of the string $$$t$$$ at the $$$3$$$th and $$$9$$$th positions. In this case, the string $$$s$$$ is an example of the form \"ab...bac...ba\". It is also possible to cut occurrences of the string $$$t$$$ at the $$$3$$$th and $$$11$$$th positions. There are two different sequences of minimum length moves.Since the answer can be large, output it modulo $$$10^9 + 7$$$.[SOURCE CODE]from typing import List, Dict, Set, Sequence, Tuple, Deque, AnyStr, Optional\r\n# from sortedcontainers import SortedDict, SortedSet, SortedList\r\nfrom collections import deque, Counter, OrderedDict\r\nimport bisect\r\n\r\ncase_num = int(input())\r\nfor case_index in range(case_num):\r\n    s = input()\r\n    t = input()\r\n    t_indexes = []  # 记录t在s中出现的起点索引的位置\r\n    for i in range(len(s)):\r\n        if s[i:i + len(t)] == t:\r\n            t_indexes.append(i)\r\n    if len(t_indexes) == 0:\r\n        print('0 1')\r\n        continue\r\n    if len(t) == 1:\r\n        print(f'{len(t_indexes)} 1')\r\n        continue\r\n    dp1 = [0 for i in range(len(t_indexes) + 1)]  # dp[i]表示从t_indexes[i]开始（包括）且t_indexes[i]处的t被删去时的最少操作次数\r\n    min1 = 1000000  # 总体的最少操作次数\r\n    for i in range(len(t_indexes) - 1, -1, -1):\r\n        j = bisect.bisect_left(t_indexes, t_indexes[i] + len(t))  # 因为t_indexes[i]要被删去，那么，接下来可能要被删去的就是t_indexes[j]处开始的t\r\n        dp1[i] = 100000000\r\n        if j >= len(t_indexes):\r\n            dp1[i] = 1\r\n        else:\r\n            l = bisect.bisect_left(t_indexes, t_indexes[j] + len(t))  # 从t_indexes[j]开始到t_indexes[l]（不包括）为止，必须有一个t被删去\r\n            for k in range(j, l):  # 遍历j，l间被删去的t，选择其中最小的，就是i开始且删除i时的最少操作次数\r\n                dp1[i] = min(dp1[i], 1 + dp1[k])\r\n        if t_indexes[i] - t_indexes[0] < len(\r\n                t):  # 当当前s中的索引t_indexes[i]已经和最小的t的索引t_indexes[0]相差小于len(t)时，说明再往前已经没有t可以删了，可以更新min1了\r\n            min1 = min(min1, dp1[i])\r\n    dp2 = [[0 for i in range(len(t_indexes) + 1)] for j in\r\n           range(len(t_indexes) + 1)]  # dp2[i][j]表示从t_indexes[i]开始（包括）且t_indexes[i]处的t被删去且总删除次数为j时的删除方式种数\r\n    dp2[len(t_indexes)][0] = 1\r\n    for i in range(len(t_indexes) - 1, -1, -1):\r\n        j = bisect.bisect_left(t_indexes, t_indexes[i] + len(t))  # 同dp1计算时中j的作用\r\n        if j >= len(t_indexes):\r\n            dp2[i][1] = 1\r\n            continue\r\n        # 只需要计算t_indexes[i]开始的最少删除次数时的操作种数，因为如果从当前索引开始的删除次数不是最少的，且总体删除次数最少时用到了当前这种方式，那么可以选择当前索引开始的最少删除次数，使总体删除次数更少，就矛盾了\r\n        l = bisect.bisect_left(t_indexes, t_indexes[j] + len(t))  # 同dp1计算时的l的作用\r\n        dp2[i][dp1[i]] = sum(dp2[k][dp1[i] - 1] for k in range(j, l)) % 1000000007\r\n    # print(min1)\r\n    # print(t_indexes)\r\n    # print(dp1)\r\n    # print(dp2)\r\n    ans = 0\r\n    for i in range(len(t_indexes)):\r\n        if t_indexes[i] - t_indexes[0] >= len(t):\r\n            break\r\n        ans = (ans + dp2[i][min1]) % 1000000007\r\n    print(f'{min1} {ans}')","tags":["strings"],"src_uid":"904af5d6a9d84b7b7b7ff8d63e6f0254"}
{"text_full":"[DESCRIPTION]Polycarp was given a row of tiles. Each tile contains one lowercase letter of the Latin alphabet. The entire sequence of tiles forms the string $$$s$$$.In other words, you are given a string $$$s$$$ consisting of lowercase Latin letters.Initially, Polycarp is on the first tile of the row and wants to get to the last tile by jumping on the tiles. Jumping from $$$i$$$-th tile to $$$j$$$-th tile has a cost equal to $$$|index(s_i) - index(s_j)|$$$, where $$$index(c)$$$ is the index of the letter $$$c$$$ in the alphabet (for example, $$$index($$$'a'$$$)=1$$$, $$$index($$$'b'$$$)=2$$$, ..., $$$index($$$'z'$$$)=26$$$) .Polycarp wants to get to the $$$n$$$-th tile for the minimum total cost, but at the same time make maximum number of jumps.In other words, among all possible ways to get to the last tile for the minimum total cost, he will choose the one with the maximum number of jumps.Polycarp can visit each tile at most once.Polycarp asks you to help — print the sequence of indices of string $$$s$$$ on which he should jump.[SOURCE CODE]from string import ascii_lowercase as asc\r\nimport sys\r\ninput = lambda: sys.stdin.buffer.readline().decode().strip()\r\nprint = sys.stdout.write\r\n\r\n\r\nfor _ in range(int(input())):\r\n    word = list(input())\r\n    ci, ti = asc.index(word[0]) + 1, asc.index(word[-1]) + 1\r\n\r\n    ans = []\r\n    if ci <= ti:\r\n        for i in range(ci, ti + 1):\r\n            [ans.append(j + 1) for j, l in enumerate(word) if l == chr(i + 96)]\r\n    else:\r\n        for i in range(ci, ti - 1, -1):\r\n            [ans.append(k + 1) for k, l in enumerate(word) if l == chr(i + 96)]\r\n\r\n    print(str(abs(ti - ci)) + \" \" + str(len(ans)) + \"\\n\" + ' '.join(map(str, ans)) + \"\\n\")","tags":["strings"],"src_uid":"d17c9f91504e1d4c4eae7294bf09dcfc"}
{"text_full":"[DESCRIPTION]You are an ambitious king who wants to be the Emperor of The Reals. But to do that, you must first become Emperor of The Integers.Consider a number axis. The capital of your empire is initially at $$$0$$$. There are $$$n$$$ unconquered kingdoms at positions $$$0&lt;x_1&lt;x_2&lt;\\ldots&lt;x_n$$$. You want to conquer all other kingdoms.There are two actions available to you:   You can change the location of your capital (let its current position be $$$c_1$$$) to any other conquered kingdom (let its position be $$$c_2$$$) at a cost of $$$a\\cdot |c_1-c_2|$$$.  From the current capital (let its current position be $$$c_1$$$) you can conquer an unconquered kingdom (let its position be $$$c_2$$$) at a cost of $$$b\\cdot |c_1-c_2|$$$. You cannot conquer a kingdom if there is an unconquered kingdom between the target and your capital. Note that you cannot place the capital at a point without a kingdom. In other words, at any point, your capital can only be at $$$0$$$ or one of $$$x_1,x_2,\\ldots,x_n$$$. Also note that conquering a kingdom does not change the position of your capital.Find the minimum total cost to conquer all kingdoms. Your capital can be anywhere at the end.[SOURCE CODE]import math\nfrom sys import stdin, stdout\nfrom collections import deque\ndef do_it(a,b,kingdoms,previous,position,states):\n    if len(kingdoms) == 0:\n        return 0\n    current = kingdoms[0]\n    if position in states:\n        return states[position]\n    gap = current-position\n    prev_gap = current-previous\n    positin_gap = previous-position\n    if(a*(previous-position)<b*(previous-position)*len(kingdoms)):\n        return a*(previous-position) + b*prev_gap + do_it(a,b,kingdoms[1:],current,previous,states)\n    else:\n        return b*gap + do_it(a,b,kingdoms[1:],current,position,states)\n\nif __name__ == '__main__':\n    T = int(stdin.readline().strip())\n    for t in range(0,T):\n        n,a,b = [int(x) for x in stdin.readline().strip().split(\" \")]\n        kingdoms = [int(x) for x in stdin.readline().strip().split(\" \")]\n        previous = 0\n        position = 0\n        res = 0\n        count = 0\n        for current in kingdoms:\n            gap = current - position\n            prev_gap = current - previous\n            positin_gap = previous - position\n            if (a * (previous - position) < b * (previous - position) * (len(kingdoms)-count)):\n                res += a * (previous - position) + b * prev_gap\n                position = previous\n                previous = current\n            else:\n                res += b * gap\n                previous = current\n            count += 1\n        stdout.write(str(res) + \"\\n\")","tags":["math"],"src_uid":"ce2b12f1d7c0388c39fee52f5410b94b"}
{"text_full":"[DESCRIPTION]Luis has a sequence of $$$n+1$$$ integers $$$a_1, a_2, \\ldots, a_{n+1}$$$. For each $$$i = 1, 2, \\ldots, n+1$$$ it is guaranteed that $$$0\\leq a_i &lt; n$$$, or $$$a_i=n^2$$$. He has calculated the sum of all the elements of the sequence, and called this value $$$s$$$. Luis has lost his sequence, but he remembers the values of $$$n$$$ and $$$s$$$. Can you find the number of elements in the sequence that are equal to $$$n^2$$$?We can show that the answer is unique under the given constraints.[SOURCE CODE]t=int(input())\r\nfor i in range(t):\r\n    x=input()\r\n    a=x.split()\r\n    print(int(a[1])\/\/(int(a[0]))**2)","tags":["math"],"src_uid":"7226a7d2700ee52f52d417f404c42ab7"}
{"text_full":"[DESCRIPTION]While performing complex market analysis William encountered the following problem:For a given array $$$a$$$ of size $$$n$$$ and a natural number $$$e$$$, calculate the number of pairs of natural numbers $$$(i, k)$$$ which satisfy the following conditions:   $$$1 \\le i, k$$$  $$$i + e \\cdot k \\le n$$$.  Product $$$a_i \\cdot a_{i + e} \\cdot a_{i + 2 \\cdot e} \\cdot \\ldots \\cdot a_{i + k \\cdot e} $$$ is a prime number. A prime number (or a prime) is a natural number greater than 1 that is not a product of two smaller natural numbers.[SOURCE CODE]# 16:34-\r\nimport sys\r\ninput = lambda: sys.stdin.readline().rstrip()\r\n\r\nfrom functools import lru_cache\r\n@lru_cache(maxsize=None)\r\ndef is_prime(a):\r\n\tif a==1:return False\r\n\tfor i in range(2,int(a**0.5)+1):\r\n\t\tif a%i==0:\r\n\t\t\treturn False\r\n\treturn True\r\n\r\ndef cal(B):\r\n\tans = 0\r\n\tfor i,b in enumerate(B):\r\n\t\tif b==2:\r\n\t\t\tl,r = i,i\r\n\t\t\tfor j in range(i-1,-1,-1):\r\n\t\t\t\tif B[j]==1:\r\n\t\t\t\t\tl=j\r\n\t\t\t\telse:\r\n\t\t\t\t\tbreak\r\n\t\t\tfor j in range(i+1,len(B)):\r\n\t\t\t\tif B[j]==1:\r\n\t\t\t\t\tr=j\r\n\t\t\t\telse:\r\n\t\t\t\t\tbreak\r\n\t\t\tans += (r-i)+(i-l)+(r-i)*(i-l)\r\n\treturn ans\r\n\r\nfor _ in range(int(input())):\r\n\tN,E = map(int, input().split())\r\n\tA = list(map(int, input().split()))\r\n\tB = [[] for _ in range(E)]\r\n\tfor i in range(E):\r\n\t\tfor j in range(i,N,E):\r\n\t\t\tB[i].append(A[j])\r\n\r\n\tans = 0\r\n\tfor b in B:\r\n\t\tfor i,d in enumerate(b):\r\n\t\t\tif d==1:continue\r\n\t\t\tif is_prime(d):\r\n\t\t\t\tb[i] = 2\r\n\t\t\telse:\r\n\t\t\t\tb[i] = 0\r\n\t\tans += cal(b)\r\n\tprint(ans)","tags":["number theory"],"src_uid":"32130f939336bb6f2deb4dfa5402867d"}
{"text_full":"[DESCRIPTION]Before becoming a successful trader William got a university degree. During his education an interesting situation happened, after which William started to listen to homework assignments much more attentively. What follows is the correct formal description of the homework assignment:You are given a string $$$s$$$ of length $$$n$$$ only consisting of characters \"a\", \"b\" and \"c\". There are $$$q$$$ queries of format ($$$pos, c$$$), meaning replacing the element of string $$$s$$$ at position $$$pos$$$ with character $$$c$$$. After each query you must output the minimal number of characters in the string, which have to be replaced, so that the string doesn't contain string \"abc\" as a substring. A valid replacement of a character is replacing it with \"a\", \"b\" or \"c\".A string $$$x$$$ is a substring of a string $$$y$$$ if $$$x$$$ can be obtained from $$$y$$$ by deletion of several (possibly, zero or all) characters from the beginning and several (possibly, zero or all) characters from the end.[SOURCE CODE]from sys import stdin,stdout\r\nimport re\r\nn,m=map(int,input().split())\r\ns=list(input())\r\nk=\"\".join(s)\r\nl=k.count(\"abc\")\r\nfor i in range(m):\r\n    j,x=map(str,input().split())\r\n    j=int(j)-1\r\n    if(s[j]==x):\r\n        stdout.write(str(l)+\"\\n\")\r\n        continue\r\n    if(j+2<n and s[j]==\"a\" and s[j+1]==\"b\" and s[j+2]==\"c\"):\r\n        l-=1\r\n    elif(1<j+1<n and s[j-1]==\"a\" and s[j]==\"b\" and s[j+1]==\"c\"):\r\n        l-=1\r\n    elif(1<j and s[j-2]==\"a\" and s[j-1]==\"b\" and s[j]==\"c\"):\r\n        l-=1\r\n    s[j]=x\r\n    if(j+2<n and s[j]==\"a\" and s[j+1]==\"b\" and s[j+2]==\"c\"):\r\n        l+=1\r\n    elif(1<j+1<n and s[j-1]==\"a\" and s[j]==\"b\" and s[j+1]==\"c\"):\r\n        l+=1\r\n    elif(1<j and s[j-2]==\"a\" and s[j-1]==\"b\" and s[j]==\"c\"):\r\n        l+=1\r\n    if(l<=0):\r\n        l=0\r\n    stdout.write(str(l)+\"\\n\")","tags":["strings"],"src_uid":"db473ad780a93983667d12b1357c6e2f"}
{"text_full":"[DESCRIPTION]William arrived at a conference dedicated to cryptocurrencies. Networking, meeting new people, and using friends' connections are essential to stay up to date with the latest news from the world of cryptocurrencies.The conference has $$$n$$$ participants, who are initially unfamiliar with each other. William can introduce any two people, $$$a$$$ and $$$b$$$, who were not familiar before, to each other. William has $$$d$$$ conditions, $$$i$$$'th of which requires person $$$x_i$$$ to have a connection to person $$$y_i$$$. Formally, two people $$$x$$$ and $$$y$$$ have a connection if there is such a chain $$$p_1=x, p_2, p_3, \\dots, p_k=y$$$ for which for all $$$i$$$ from $$$1$$$ to $$$k - 1$$$ it's true that two people with numbers $$$p_i$$$ and $$$p_{i + 1}$$$ know each other.For every $$$i$$$ ($$$1 \\le i \\le d$$$) William wants you to calculate the maximal number of acquaintances one person can have, assuming that William satisfied all conditions from $$$1$$$ and up to and including $$$i$$$ and performed exactly $$$i$$$ introductions. The conditions are being checked after William performed $$$i$$$ introductions. The answer for each $$$i$$$ must be calculated independently. It means that when you compute an answer for $$$i$$$, you should assume that no two people have been introduced to each other yet.[SOURCE CODE]from collections import defaultdict\r\nn = (10 ** 3)+10\r\nparent = [i for i in range(n)]\r\nsize = [1 for i in range(n)]\r\n\r\n\r\ndef find(root):\r\n    a = root\r\n    while parent[a] != a:\r\n        a = parent[a]\r\n\r\n    # path comprehension\r\n    while root != a:\r\n        nextnode = parent[root]\r\n        parent[root] = a\r\n        root = nextnode\r\n    return a\r\n\r\n\r\ndef union(a, b):\r\n    a = find(a)\r\n    b = find(b)\r\n    if a != b:\r\n        if size[a] < size[b]:\r\n            a, b = b, a\r\n        parent[b] = a\r\n        size[a] += size[b]\r\n        return False\r\n    else:\r\n        return True\r\n\r\n\r\nc=0\r\nl,d=map(int,input().split())\r\nfor j in range(d):\r\n    a,b=map(int,input().split())\r\n    cans = union(a,b)\r\n    if cans:\r\n        c+=1\r\n    ans=0\r\n    allp=set()\r\n    grps=[]\r\n    for k in range(1,l+1):\r\n        pr= find(k)\r\n        if pr not in allp:\r\n            allp.add(pr)\r\n            grps.append(size[pr])\r\n    grps.sort(reverse=True)\r\n    # print(grps)\r\n    # print(parent[:l+1])\r\n    # print(c)\r\n    for k in range(min(c+1,len(grps))):\r\n        ans+=grps[k]\r\n    print(ans-1)","tags":["graphs","trees"],"src_uid":"29bc7a22baa3dc6bb508b00048e50114"}
{"text_full":"[DESCRIPTION]The city Valera lives in is going to hold elections to the city Parliament.The city has n districts and n - 1 bidirectional roads. We know that from any district there is a path along the roads to any other district. Let's enumerate all districts in some way by integers from 1 to n, inclusive. Furthermore, for each road the residents decided if it is the problem road or not. A problem road is a road that needs to be repaired.There are n candidates running the elections. Let's enumerate all candidates in some way by integers from 1 to n, inclusive. If the candidate number i will be elected in the city Parliament, he will perform exactly one promise — to repair all problem roads on the way from the i-th district to the district 1, where the city Parliament is located.Help Valera and determine the subset of candidates such that if all candidates from the subset will be elected to the city Parliament, all problem roads in the city will be repaired. If there are several such subsets, you should choose the subset consisting of the minimum number of candidates.[SOURCE CODE]import sys\nfrom math import sqrt, gcd, ceil, log\n# from bisect import bisect, bisect_left\nfrom collections import defaultdict, Counter, deque\n# from heapq import heapify, heappush, heappop\ninput = sys.stdin.readline\nread = lambda: list(map(int, input().strip().split()))\n\nsys.setrecursionlimit(200000)\n\n\ndef main(): \n\tn = int(input()); \n\tadj = defaultdict(list)\n\tproblem = set()\n\tfor i in range(n-1):\n\t\tx, y, t = read()\n\t\tadj[x].append(y)\n\t\tadj[y].append(x)\n\t\tif t == 2:problem.add((x, y))\n\n\n\tparent = defaultdict(int)\n\torder = []\n\tdef dfs():\n\t\tstk = [(1, 0)]\n\t\twhile stk:\n\t\t\tnode, par = stk.pop()\n\t\t\torder.append(node); parent[node] = par\n\t\t\tfor child in adj[node]:\n\t\t\t\tif child != par:\n\t\t\t\t\tstk.append((child, node))\n\t\t# return(order)\n\t\t# lis = []\n\t\t# for child in adj[node]:\n\t\t# \tif child != par:\n\t\t# \t\ttem = dfs(child, node)\n\t\t# \t\tif (node, child) in problem or (child, node) in problem:\n\t\t# \t\t\tif tem == []:lis.append(child)\n\t\t# \t\t\telse:lis.extend(tem)\n\t\t# \t\telif tem:\n\t\t# \t\t\tlis.extend(tem)\n\t\t# return(lis)\n\tdfs()\n\t# print(order)\n\t# print(parent)\n\tdic = defaultdict(int)\n\tans = []\n\tfor i in range(n-1, -1, -1):\n\t\tchild = order[i]; par = parent[order[i]]\n\t\tif dic[child]:\n\t\t\tdic[par] += dic[child]\n\t\telif (child, par) in problem or (par, child) in problem:\n\t\t\tans.append(child)\n\t\t\tdic[par] += 1\n\tprint(len(ans))\n\tprint(*ans)\n\n\n\n\t\t\t\n\n\n\n\n\n\nif __name__ == \"__main__\":\n\tmain()","tags":["trees","graphs"],"src_uid":"6dafebcc521b7523427724753187715a"}
{"text_full":"[DESCRIPTION]Volodya likes listening to heavy metal and (occasionally) reading. No wonder Volodya is especially interested in texts concerning his favourite music style.Volodya calls a string powerful if it starts with \"heavy\" and ends with \"metal\". Finding all powerful substrings (by substring Volodya means a subsequence of consecutive characters in a string) in a given text makes our hero especially joyful. Recently he felt an enormous fit of energy while reading a certain text. So Volodya decided to count all powerful substrings in this text and brag about it all day long. Help him in this difficult task. Two substrings are considered different if they appear at the different positions in the text.For simplicity, let us assume that Volodya's text can be represented as a single string.[SOURCE CODE]#_________________ Mukul Mohan Varshney _______________#\n\n#Template\nimport sys\nimport os\nimport math\nimport copy\nfrom math import gcd\nfrom bisect import bisect\nfrom io import BytesIO, IOBase\nfrom math import sqrt,floor,factorial,gcd,log,ceil\nfrom collections import deque,Counter,defaultdict\nfrom itertools import permutations, combinations\n\n#define function \ndef Int(): return int(sys.stdin.readline())\ndef Mint(): return map(int,sys.stdin.readline().split())\ndef Lstr(): return list(sys.stdin.readline().strip())\ndef Str(): return sys.stdin.readline().strip()\ndef Mstr(): return map(str,sys.stdin.readline().strip().split())\ndef List(): return list(map(int,sys.stdin.readline().split()))\ndef Hash(): return dict()\ndef Mod(): return 1000000007\ndef Ncr(n,r,p): return ((fact[n])*((ifact[r]*ifact[n-r])%p))%p\ndef Most_frequent(list): return max(set(list), key = list.count)\ndef Mat2x2(n): return [List() for _ in range(n)]\ndef btod(n): \n    return int(n,2) \n    \ndef dtob(n): \n    return bin(n).replace(\"0b\",\"\")    \n\n \n# Driver Code \t\ndef solution():\n     #for _ in range(Int()):\n          n=Str()\n          s=0\n          e=0\n          for i in range(len(n)):\n               if(n[i:i+5]=='heavy'):\n                    s+=1\n               if(n[i:i+5]=='metal'):\n                    e+=s\n          print(e)          \n          \n          \n#Call the solve function          \nif __name__ == \"__main__\":\n     solution()","tags":["strings"],"src_uid":"960e4c234666d2444b80d5966f1d285d"}
{"text_full":"[DESCRIPTION]Little X used to play a card game called \"24 Game\", but recently he has found it too easy. So he invented a new game.Initially you have a sequence of n integers: 1, 2, ..., n. In a single step, you can pick two of them, let's denote them a and b, erase them from the sequence, and append to the sequence either a + b, or a - b, or a × b.After n - 1 steps there is only one number left. Can you make this number equal to 24?[SOURCE CODE]a=input()\nif(a<4):\n\tprint \"NO\"\nelif(a==4):\n\tprint \"YES\"\n\tprint \"4 * 3 = 12\"\n\tprint \"2 * 1 = 2\"\n\tprint \"12 * 2 = 24\"\nelif(a==5):\n\tprint \"YES\"\n\tprint \"5 - 3 = 2\"\n\tprint \"2 + 1 = 3\"\n\tprint \"2 * 3 = 6\"\n\tprint \"6 * 4 = 24\"\nelif(a>5):\n\tprint \"YES\"\n\tprint \"6 * 4 = 24\"\n\tprint \"3 - 2 = 1\"\n\tprint \"1 - 1 = 0\"\n\tprint \"0 * 5 = 0\"\n\tif(a>6):\n\t\tfor i in range(7,a+1):\n\t\t\tprint \"0 * \"+str(i)+\" = 0\"\n\tprint \"24 + 0 = 24\"","tags":["math"],"src_uid":"1bd1a7fd2a07e3f8633d5bc83d837769"}
{"text_full":"[DESCRIPTION]You are given two integers $$$n$$$ and $$$m$$$. You have to construct the array $$$a$$$ of length $$$n$$$ consisting of non-negative integers (i.e. integers greater than or equal to zero) such that the sum of elements of this array is exactly $$$m$$$ and the value $$$\\sum\\limits_{i=1}^{n-1} |a_i - a_{i+1}|$$$ is the maximum possible. Recall that $$$|x|$$$ is the absolute value of $$$x$$$.In other words, you have to maximize the sum of absolute differences between adjacent (consecutive) elements. For example, if the array $$$a=[1, 3, 2, 5, 5, 0]$$$ then the value above for this array is $$$|1-3| + |3-2| + |2-5| + |5-5| + |5-0| = 2 + 1 + 3 + 0 + 5 = 11$$$. Note that this example doesn't show the optimal answer but it shows how the required value for some array is calculated.You have to answer $$$t$$$ independent test cases.[SOURCE CODE]cases=int(input(\"\"))\noutput=[]\nfor c in range(cases):\n\tlist1=[]\n\tx=input(\"\").split()\n\tfor i in range(2):\n\t\tlist1.append(int(x[i]))\n\tif list1[0]==1:\n\t\toutput.append(0)\n\t\tcontinue \n\tif list1[0]==2:\n\t\toutput.append(list1[1])\n\t\tcontinue\n\n\tif list1[1]%2 == 0 :\n\t\tif list1[0] >= 5:\n\t\t\toutput.append(int(int(list1[1]\/2)*4))\n\t\telif list1[0] == 4 or list1[0] == 3:\n\t\t\toutput.append(list1[1]*2)\n\t\t\t#output.append(int(list1[1]\/2)*(list1[0]-1))\n\n\tif int(x[1])%2 != 0 :\n\t\tif int(x[0]) >= 5:\n\t\t\toutput.append(int(int(list1[1])\/2)*2+((int(list1[1]\/2))+1)*2)\n\t\telif int(x[0]) == 4 or list1[0] == 3:\n\t\t\toutput.append(list1[1]*2)\n\t\t\t#output.append(int((int(list1[1]\/2)+1)*2+int(list1[1]\/2)))\n\t\t#elif int(x[0]) == 3 :\n\t\t\t#output.append(int((int(list1[1]\/2)+1)+int(list1[1]\/2)))\n\nprint(*output, sep=\"\\n\")","tags":["math"],"src_uid":"905cc16ecbbb3305416f9aa6e4412642"}
{"text_full":"[DESCRIPTION]You are given an array $$$a_1, a_2, \\dots, a_n$$$ where all $$$a_i$$$ are integers and greater than $$$0$$$. In one operation, you can choose two different indices $$$i$$$ and $$$j$$$ ($$$1 \\le i, j \\le n$$$). If $$$gcd(a_i, a_j)$$$ is equal to the minimum element of the whole array $$$a$$$, you can swap $$$a_i$$$ and $$$a_j$$$. $$$gcd(x, y)$$$ denotes the greatest common divisor (GCD) of integers $$$x$$$ and $$$y$$$. Now you'd like to make $$$a$$$ non-decreasing using the operation any number of times (possibly zero). Determine if you can do this. An array $$$a$$$ is non-decreasing if and only if $$$a_1 \\le a_2 \\le \\ldots \\le a_n$$$.[SOURCE CODE]for i in range(int(input())):\n    n=int(input())\n    l=list(map(int,input().split()))\n    y=sorted(l)\n    x=min(l)\n    a=[]\n    b=[]\n    for i in range(n):\n        if l[i]%x==0:\n            a.append(l[i])\n            b.append(i)\n    a.sort()\n    for i in range(len(b)):\n        l[b[i]]=a[i]\n    if(l==y):\n        print('YES')\n    else:\n        print('NO')","tags":["number theory","math"],"src_uid":"f2070c2bd7bdbf0919aef1e915a21a24"}
{"text_full":"[DESCRIPTION]You are given a set of $$$2n+1$$$ integer points on a Cartesian plane. Points are numbered from $$$0$$$ to $$$2n$$$ inclusive. Let $$$P_i$$$ be the $$$i$$$-th point. The $$$x$$$-coordinate of the point $$$P_i$$$ equals $$$i$$$. The $$$y$$$-coordinate of the point $$$P_i$$$ equals zero (initially). Thus, initially $$$P_i=(i,0)$$$.The given points are vertices of a plot of a piecewise function. The $$$j$$$-th piece of the function is the segment $$$P_{j}P_{j + 1}$$$.In one move you can increase the $$$y$$$-coordinate of any point with odd $$$x$$$-coordinate (i.e. such points are $$$P_1, P_3, \\dots, P_{2n-1}$$$) by $$$1$$$. Note that the corresponding segments also change.For example, the following plot shows a function for $$$n=3$$$ (i.e. number of points is $$$2\\cdot3+1=7$$$) in which we increased the $$$y$$$-coordinate of the point $$$P_1$$$ three times and $$$y$$$-coordinate of the point $$$P_5$$$ one time:  Let the area of the plot be the area below this plot and above the coordinate axis OX. For example, the area of the plot on the picture above is 4 (the light blue area on the picture above is the area of the plot drawn on it).Let the height of the plot be the maximum $$$y$$$-coordinate among all initial points in the plot (i.e. points $$$P_0, P_1, \\dots, P_{2n}$$$). The height of the plot on the picture above is 3.Your problem is to say which minimum possible height can have the plot consisting of $$$2n+1$$$ vertices and having an area equal to $$$k$$$. Note that it is unnecessary to minimize the number of moves.It is easy to see that any answer which can be obtained by performing moves described above always exists and is an integer number not exceeding $$$10^{18}$$$.[SOURCE CODE]import math\nn,k = list(map(int, input().split(' ')))\nprint(-(-k\/\/n))\n# if k<= n:\n#     print(1)\n# else:\n#     if k%n:\n#         print(int(math.ceil(k\/n)))\n#     else:\n#         print(int(k\/n))","tags":["math"],"src_uid":"31014efa929af5e4b7d9987bd9b59918"}
{"text_full":"[DESCRIPTION]A competitive eater, Alice is scheduling some practices for an eating contest on a magical calendar. The calendar is unusual because a week contains not necessarily $$$7$$$ days!In detail, she can choose any integer $$$k$$$ which satisfies $$$1 \\leq k \\leq r$$$, and set $$$k$$$ days as the number of days in a week.Alice is going to paint some $$$n$$$ consecutive days on this calendar. On this calendar, dates are written from the left cell to the right cell in a week. If a date reaches the last day of a week, the next day's cell is the leftmost cell in the next (under) row.She wants to make all of the painted cells to be connected by side. It means, that for any two painted cells there should exist at least one sequence of painted cells, started in one of these cells, and ended in another, such that any two consecutive cells in this sequence are connected by side.Alice is considering the shape of the painted cells. Two shapes are the same if there exists a way to make them exactly overlapped using only parallel moves, parallel to the calendar's sides.For example, in the picture, a week has $$$4$$$ days and Alice paints $$$5$$$ consecutive days. [1] and [2] are different shapes, but [1] and [3] are equal shapes.    Alice wants to know how many possible shapes exists if she set how many days a week has and choose consecutive $$$n$$$ days and paints them in calendar started in one of the days of the week. As was said before, she considers only shapes, there all cells are connected by side.[SOURCE CODE]from sys import stdin\ninput=stdin.readline\n\nfor _ in range(int(input())):\n    n,m=map(int,input().split())\n    if n<=m:\n        print((n*(n-1))\/\/2+1)\n    else:\n        print((m*(m+1))\/\/2)","tags":["math"],"src_uid":"eb3d8259ca598c3c455ddfdbe433cb78"}
{"text_full":"[DESCRIPTION]Note that this is the second problem of the two similar problems. You can hack this problem if you solve it. But you can hack the previous problem only if you solve both problems.You are given a tree with $$$n$$$ nodes. In the beginning, $$$0$$$ is written on all edges. In one operation, you can choose any $$$2$$$ distinct leaves $$$u$$$, $$$v$$$ and any integer number $$$x$$$ and add $$$x$$$ to values written on all edges on the simple path between $$$u$$$ and $$$v$$$. Note that in previous subtask $$$x$$$ was allowed to be any real, here it has to be integer.For example, on the picture below you can see the result of applying two operations to the graph: adding $$$2$$$ on the path from $$$7$$$ to $$$6$$$, and then adding $$$-1$$$ on the path from $$$4$$$ to $$$5$$$.   You are given some configuration of nonnegative integer pairwise different even numbers, written on the edges. For a given configuration determine if it is possible to achieve it with these operations, and, if it is possible, output the sequence of operations that leads to the given configuration. Constraints on the operations are listed in the output format section.Leave is a node of a tree of degree $$$1$$$. Simple path is a path that doesn't contain any node twice.[SOURCE CODE]from sys import stdin\n\nclass solution():\n    def dfs(self, x, par, adj_arr):\n        for adj in adj_arr[x]:\n            if adj != par:\n                return self.dfs(adj, x, adj_arr)\n\n        return x\n\n    def get_two_child(self, x, y, adj_arr):\n        if len(adj_arr[x]) == 1:\n            return x + 1, x + 1\n\n        child1 = adj_arr[x][0]\n        child2 = adj_arr[x][1]\n\n        if child1 == y:\n            child1 = child2\n            child2 = adj_arr[x][2]\n\n        if child2 == y:\n            child2 = adj_arr[x][2]\n\n        return self.dfs(child1, x, adj_arr) + 1, self.dfs(child2, x, adj_arr) + 1\n\n    def main(self):\n        n = int(stdin.readline())\n        a = [[] for _ in range(n)]\n        edges = []\n\n        for i in range(n - 1):\n            x, y, w = [int(val) for val in stdin.readline().split(\" \")]\n            x -= 1\n            y -= 1\n            a[x].append(y)\n            a[y].append(x)\n            edges.append((x, y, w))\n\n        for val in a:\n            if len(val) == 2:\n                print \"NO\"\n                return\n\n        print \"YES\"\n        result = []\n        for x, y, w in edges:\n            if w == 0:\n                continue\n\n            l1, l2 = self.get_two_child(x, y, a)\n            r1, r2 = self.get_two_child(y, x, a)\n\n            result.append((l1, r1, w \/ 2))\n            result.append((l2, r2, w \/ 2))\n\n            if l1 != l2:\n                result.append((l1, l2, -(w \/ 2)))\n\n            if r1 != r2:\n                result.append((r1, r2, -(w \/ 2)))\n\n        print len(result)\n        for x in result:\n            print \" \".join([str(y) for y in x])\n\nx = solution()\nx.main()","tags":["trees"],"src_uid":"0ef40ec5578a61c93254149c59282ee3"}
{"text_full":"[DESCRIPTION]Nowadays the one-way traffic is introduced all over the world in order to improve driving safety and reduce traffic jams. The government of Berland decided to keep up with new trends. Formerly all n cities of Berland were connected by n two-way roads in the ring, i. e. each city was connected directly to exactly two other cities, and from each city it was possible to get to any other city. Government of Berland introduced one-way traffic on all n roads, but it soon became clear that it's impossible to get from some of the cities to some others. Now for each road is known in which direction the traffic is directed at it, and the cost of redirecting the traffic. What is the smallest amount of money the government should spend on the redirecting of roads so that from every city you can get to any other?[SOURCE CODE]# our function\ndef find_next_path(cont, N, path, indx):\n    for i in range(N):\n        if cont[indx][i] != 0 and i not in path or \\\n                cont[i][indx] != 0 and i not in path:\n            return i\n\n    return -1\n\n\n# end of fuction\nN = int(input())\ncont = [[0] * N for i in range(N)]\nfor i in range(N):\n    a, b, price = [int(item) for item in input().split()]\n    cont[a - 1][b - 1] = price\n\npath = [0]\nnindx = find_next_path(cont, N, path, 0)\nwhile nindx != -1:\n    path.append(nindx)\n    nindx = find_next_path(cont, N, path, path[len(path) - 1])\n\nCW = cont[path[N - 1]][0]\nACW = cont[0][path[N - 1]]\ni, j = 0, N - 1\nwhile i < N - 1:\n    CW += cont[path[i]][path[i + 1]]\n    ACW += cont[path[j]][path[j - 1]]\n    i += 1\n    j -= 1\n\nprint(CW if ACW > CW else ACW)","tags":["graphs"],"src_uid":"d85c7a8f7e6f5fc6dffed554bffef3ec"}
{"text_full":"[DESCRIPTION]You are given a matrix with $$$n$$$ rows (numbered from $$$1$$$ to $$$n$$$) and $$$m$$$ columns (numbered from $$$1$$$ to $$$m$$$). A number $$$a_{i, j}$$$ is written in the cell belonging to the $$$i$$$-th row and the $$$j$$$-th column, each number is either $$$0$$$ or $$$1$$$.A chip is initially in the cell $$$(1, 1)$$$, and it will be moved to the cell $$$(n, m)$$$. During each move, it either moves to the next cell in the current row, or in the current column (if the current cell is $$$(x, y)$$$, then after the move it can be either $$$(x + 1, y)$$$ or $$$(x, y + 1)$$$). The chip cannot leave the matrix.Consider each path of the chip from $$$(1, 1)$$$ to $$$(n, m)$$$. A path is called palindromic if the number in the first cell is equal to the number in the last cell, the number in the second cell is equal to the number in the second-to-last cell, and so on.Your goal is to change the values in the minimum number of cells so that every path is palindromic.[SOURCE CODE]# import sys\n# sys.stdin = open('inputf.in','r')\n#sys.stdout = open('outputf.in','w')\nt = int(input())\nwhile(t):\n\tt -= 1\n\tn,m = map(int, input().split(' '))\n\td0 = {}\n\td1 = {}\n\tfor i in range(1, n + 1):\n\t\tl = list(map(int, input().split(' ')))\n\t\tfor j in range(1, m + 1):\n\t\t\tx = i + j\n\t\t\tif x not in d0:\n\t\t\t\td0[x] = 0\n\t\t\tif x not in d1:\n\t\t\t\td1[x] = 0\n\t\t\td0[x] += (l[j - 1] == 0)\n\t\t\td1[x] += (l[j - 1] == 1)\n\tans = 0\n\ti = 2\n\tj = n + m\n\twhile(i < j):\n   \t\tx1 = d1[i] + d1[j]\n   \t\tx2 = d0[i] + d0[j]\n   \t\ti += 1\n   \t\tj -= 1\n   \t\tans += min(x1, x2)\n\tprint(ans)","tags":["math"],"src_uid":"b62586b55bcfbd616d936459c30579a6"}
{"text_full":"[DESCRIPTION]There is a prison that can be represented as a rectangular matrix with $$$n$$$ rows and $$$m$$$ columns. Therefore, there are $$$n \\cdot m$$$ prison cells. There are also $$$n \\cdot m$$$ prisoners, one in each prison cell. Let's denote the cell in the $$$i$$$-th row and the $$$j$$$-th column as $$$(i, j)$$$.There's a secret tunnel in the cell $$$(r, c)$$$, that the prisoners will use to escape! However, to avoid the risk of getting caught, they will escape at night.Before the night, every prisoner is in his own cell. When night comes, they can start moving to adjacent cells. Formally, in one second, a prisoner located in cell $$$(i, j)$$$ can move to cells $$$( i - 1 , j )$$$ , $$$( i + 1 , j )$$$ , $$$( i , j - 1 )$$$ , or $$$( i , j + 1 )$$$, as long as the target cell is inside the prison. They can also choose to stay in cell $$$(i, j)$$$.The prisoners want to know the minimum number of seconds needed so that every prisoner can arrive to cell $$$( r , c )$$$ if they move optimally. Note that there can be any number of prisoners in the same cell at the same time.[SOURCE CODE]t=int(input())\nfor i in range(t):\n    n,m,r,c=map(int,input().split())\n    a1=1\n    a2=n\n    b1=1\n    b2=m\n    c1=abs(a1-r)+abs(b1-c)\n    c2=abs(a1-r)+abs(b2-c)\n    c3=abs(a2-r)+abs(b1-c)\n    c4=abs(a2-r)+abs(b2-c)\n    print(max(c1,max(c2,max(c3,c4))))","tags":["math"],"src_uid":"3a3fbb61c7e1ccda69cd6d186da653ae"}
{"text_full":"[DESCRIPTION]You are given a string $$$s$$$ of length $$$n$$$, which consists only of the first $$$k$$$ letters of the Latin alphabet. All letters in string $$$s$$$ are uppercase.A subsequence of string $$$s$$$ is a string that can be derived from $$$s$$$ by deleting some of its symbols without changing the order of the remaining symbols. For example, \"ADE\" and \"BD\" are subsequences of \"ABCDE\", but \"DEA\" is not.A subsequence of $$$s$$$ called good if the number of occurences of each of the first $$$k$$$ letters of the alphabet is the same.Find the length of the longest good subsequence of $$$s$$$.[SOURCE CODE]n, k = map(int, raw_input().split(\" \"))\ns = raw_input()\n\nll = []\nfor i in xrange(26):\n    ll.append(0)\n\nfor ch in s:\n    ll[ord(ch) - ord('A')] += 1\n\nprint min(ll[:k]) * k","tags":["strings"],"src_uid":"d9d5db63b1e48214d02abe9977709384"}
{"text_full":"[DESCRIPTION]Pinkie Pie has bought a bag of patty-cakes with different fillings! But it appeared that not all patty-cakes differ from one another with filling. In other words, the bag contains some patty-cakes with the same filling.Pinkie Pie eats the patty-cakes one-by-one. She likes having fun so she decided not to simply eat the patty-cakes but to try not to eat the patty-cakes with the same filling way too often. To achieve this she wants the minimum distance between the eaten with the same filling to be the largest possible. Herein Pinkie Pie called the distance between two patty-cakes the number of eaten patty-cakes strictly between them.Pinkie Pie can eat the patty-cakes in any order. She is impatient about eating all the patty-cakes up so she asks you to help her to count the greatest minimum distance between the eaten patty-cakes with the same filling amongst all possible orders of eating!Pinkie Pie is going to buy more bags of patty-cakes so she asks you to solve this problem for several bags![SOURCE CODE]import sys\nimport math\nfrom collections import defaultdict,Counter\n\n# input=sys.stdin.readline\n# def print(x):\n#     sys.stdout.write(str(x)+\"\\n\")\n\n# sys.stdout=open(\"CP3\/output.txt\",'w')\n# sys.stdin=open(\"CP3\/input.txt\",'r')\n\n# m=pow(10,9)+7\nt=int(input())\nfor i in range(t):\n    n=int(input())\n    a=list(map(int,input().split()))\n    d={}\n    for j in a:\n        d[j]=d.get(j,0)+1\n    ma=max(list(d.values()))\n    # print(d)\n    ans=n-ma+1\n    for j in d:\n        if d[j]==ma:\n            ans-=1\n    print(ans\/\/(ma-1))","tags":["math"],"src_uid":"9d480b3979a7c9789fd8247120f31f03"}
{"text_full":"[DESCRIPTION]You are both a shop keeper and a shop assistant at a small nearby shop. You have $$$n$$$ goods, the $$$i$$$-th good costs $$$a_i$$$ coins.You got tired of remembering the price of each product when customers ask for it, thus you decided to simplify your life. More precisely you decided to set the same price for all $$$n$$$ goods you have.However, you don't want to lose any money so you want to choose the price in such a way that the sum of new prices is not less than the sum of the initial prices. It means that if you sell all $$$n$$$ goods for the new price, you will receive at least the same (or greater) amount of money as if you sell them for their initial prices.On the other hand, you don't want to lose customers because of big prices so among all prices you can choose you need to choose the minimum one.So you need to find the minimum possible equal price of all $$$n$$$ goods so if you sell them for this price, you will receive at least the same (or greater) amount of money as if you sell them for their initial prices.You have to answer $$$q$$$ independent queries.[SOURCE CODE]#Equalize_Prices_Again\nt=int(input())\nfor _ in range(t):\n    n=int(input())\n    l=list(map(int,input().split()))\n    print(((sum(l)-1)\/\/n)+1)","tags":["math"],"src_uid":"c457b77b16d94c6c4c95b7403a1dd0c7"}
{"text_full":"[DESCRIPTION]Let's define a forest as a non-directed acyclic graph (also without loops and parallel edges). One day Misha played with the forest consisting of n vertices. For each vertex v from 0 to n - 1 he wrote down two integers, degreev and sv, were the first integer is the number of vertices adjacent to vertex v, and the second integer is the XOR sum of the numbers of vertices adjacent to v (if there were no adjacent vertices, he wrote down 0). Next day Misha couldn't remember what graph he initially had. Misha has values degreev and sv left, though. Help him find the number of edges and the edges of the initial graph. It is guaranteed that there exists a forest that corresponds to the numbers written by Misha.[SOURCE CODE]from collections import deque\nn = int(input())\nprocess = deque()\nvs = []\nfor i in range(n):\n    d, s = map(int, input().split())\n    if d == 1:\n        process.append(i)\n    vs.append((d, s))\nedges = []\nwhile process:\n    a = process.popleft()\n    d, s = vs[a]\n    if d == 0:\n        continue\n    dd, ss = vs[s]\n    vs[s] = (dd - 1, ss ^ a)\n    if dd == 2:\n        process.append(s)\n    edges.append((a, s))\nprint(len(edges))\nfor a, b in edges:\n    print(a,b)","tags":["graphs"],"src_uid":"14ad30e33bf8cad492e665b0a486008e"}
{"text_full":"[DESCRIPTION]Jeff's got n cards, each card contains either digit 0, or digit 5. Jeff can choose several cards and put them in a line so that he gets some number. What is the largest possible number divisible by 90 Jeff can make from the cards he's got?Jeff must make the number without leading zero. At that, we assume that number 0 doesn't contain any leading zeroes. Jeff doesn't have to use all the cards.[SOURCE CODE]n=int(input())\nl=list(map(int,input().split()))\na,b=0,0\ns=\"\"\nfor i in l:\n    if i==5:\n        a=a+1\n    if i==0:\n        b=b+1        \nfor i in range(a\/\/9):\n    s=s+\"555555555\"\nif a<9:\n  if b>0:  \n     s=\"0\" \nelse:    \n  for i in range(b):  \n    s=s+\"0\" \nif b>0:\n print(s)\nelse:\n print(\"-1\")","tags":["math"],"src_uid":"409b27044d5ec97b5315c92d4112376f"}
{"text_full":"[DESCRIPTION]Today at the lesson of mathematics, Petya learns about the digital root.The digital root of a non-negative integer is the single digit value obtained by an iterative process of summing digits, on each iteration using the result from the previous iteration to compute a digit sum. The process continues until a single-digit number is reached. Let's denote the digital root of $$$x$$$ as $$$S(x)$$$. Then $$$S(5)=5$$$, $$$S(38)=S(3+8=11)=S(1+1=2)=2$$$, $$$S(10)=S(1+0=1)=1$$$.As a homework Petya got $$$n$$$ tasks of the form: find $$$k$$$-th positive number whose digital root is $$$x$$$.Petya has already solved all the problems, but he doesn't know if it's right. Your task is to solve all $$$n$$$ tasks from Petya's homework.[SOURCE CODE]n = int(input())\nfor _ in range(n):\n k,x = map(int,input().split())\n if (k==1):\n  print(x)\n else:\n  print(x+((k-1)%1000000000007)*9)","tags":["number theory","math"],"src_uid":"891fabbb6ee8a4969b6f413120f672a8"}
{"text_full":"[DESCRIPTION]You are a coach of a group consisting of $$$n$$$ students. The $$$i$$$-th student has programming skill $$$a_i$$$. All students have distinct programming skills. You want to divide them into teams in such a way that:  No two students $$$i$$$ and $$$j$$$ such that $$$|a_i - a_j| = 1$$$ belong to the same team (i.e. skills of each pair of students in the same team have the difference strictly greater than $$$1$$$);  the number of teams is the minimum possible. You have to answer $$$q$$$ independent queries.[SOURCE CODE]q=int(input())\nwhile q>0:\n    q-=1\n    n=int(input())\n    a=list(map(int,input().split()))\n    a.sort()\n    s=1\n    z=1\n    i=0\n    while i<(n-1):\n        if (a[i]-a[i+1])==-1:\n            z=2\n        s=max(z,s)\n        i+=1\n        z=1\n    print(s)","tags":["math"],"src_uid":"dd2cd365d7afad9c2b5bdbbd45d87c8a"}
{"text_full":"[DESCRIPTION]In Aramic language words can only represent objects.Words in Aramic have special properties:   A word is a root if it does not contain the same letter more than once.  A root and all its permutations represent the same object.  The root $$$x$$$ of a word $$$y$$$ is the word that contains all letters that appear in $$$y$$$ in a way that each letter appears once. For example, the root of \"aaaa\", \"aa\", \"aaa\" is \"a\", the root of \"aabb\", \"bab\", \"baabb\", \"ab\" is \"ab\".  Any word in Aramic represents the same object as its root. You have an ancient script in Aramic. What is the number of different objects mentioned in the script?[SOURCE CODE]n = int(raw_input().strip())\nx = raw_input().split(' ')\nres = len(set([''.join(sorted(set(i))) for i in x]))\nprint res","tags":["strings"],"src_uid":"cf1eb164c4c970fd398ef9e98b4c07b1"}
{"text_full":"[DESCRIPTION]There is a square painted on a piece of paper, the square's side equals n meters. John Doe draws crosses on the square's perimeter. John paints the first cross in the lower left corner of the square. Then John moves along the square's perimeter in the clockwise direction (first upwards, then to the right, then downwards, then to the left and so on). Every time he walks (n + 1) meters, he draws a cross (see picture for clarifications).John Doe stops only when the lower left corner of the square has two crosses. How many crosses will John draw?   The figure shows the order in which John draws crosses for a square with side 4. The lower left square has two crosses. Overall John paints 17 crosses.[SOURCE CODE]n = int(raw_input())\n\nparts = [int(x) for x in raw_input().split()]\n\nfor p in parts:\n  if p % 2 == 0:\n    print p * 4 + 1\n  else:\n    if (p + 3) % 4 == 0:\n      res = 1 + (((p + 3) \/ 4) - 1) * 4\n      print res * 2 + 1\t  \n    elif (p + 1) % 4 == 0 :\n      res = 3 + (((p + 1) \/ 4) - 1) * 4\n      print res + 1","tags":["math"],"src_uid":"168dbc4994529f5407a440b0c71086da"}
{"text_full":"[DESCRIPTION]INTERCAL is the oldest of esoteric programming languages. One of its many weird features is the method of character-based output, known as Turing Tape method. It converts an array of unsigned 8-bit integers into a sequence of characters to print, using the following method.The integers of the array are processed one by one, starting from the first. Processing i-th element of the array is done in three steps:1. The 8-bit binary notation of the ASCII-code of the previous printed character is reversed. When the first element of the array is processed, the result of this step is considered to be 0.2. The i-th element of the array is subtracted from the result of the previous step modulo 256.3. The binary notation of the result of the previous step is reversed again to produce ASCII-code of the i-th character to be printed.You are given the text printed using this method. Restore the array used to produce this text.[SOURCE CODE]s = raw_input()\npre = 0\nfor i in s:\n    nxt = format(ord(i), \"b\")[::-1]\n    while (len(nxt) < 8):\n        nxt += \"0\"\n    print (pre - int(nxt, 2)) % 256\n    pre = int(nxt, 2)","tags":["math"],"src_uid":"a65e12186430f74c18c50d2eb55a9794"}
{"text_full":"[DESCRIPTION]Recently, Mike was very busy with studying for exams and contests. Now he is going to chill a bit by doing some sight seeing in the city.City consists of n intersections numbered from 1 to n. Mike starts walking from his house located at the intersection number 1 and goes along some sequence of intersections. Walking from intersection number i to intersection j requires |i - j| units of energy. The total energy spent by Mike to visit a sequence of intersections p1 = 1, p2, ..., pk is equal to  units of energy.Of course, walking would be boring if there were no shortcuts. A shortcut is a special path that allows Mike walking from one intersection to another requiring only 1 unit of energy. There are exactly n shortcuts in Mike's city, the ith of them allows walking from intersection i to intersection ai (i ≤ ai ≤ ai + 1) (but not in the opposite direction), thus there is exactly one shortcut starting at each intersection. Formally, if Mike chooses a sequence p1 = 1, p2, ..., pk then for each 1 ≤ i &lt; k satisfying pi + 1 = api and api ≠ pi Mike will spend only 1 unit of energy instead of |pi - pi + 1| walking from the intersection pi to intersection pi + 1. For example, if Mike chooses a sequence p1 = 1, p2 = ap1, p3 = ap2, ..., pk = apk - 1, he spends exactly k - 1 units of total energy walking around them.Before going on his adventure, Mike asks you to find the minimum amount of energy required to reach each of the intersections from his home. Formally, for each 1 ≤ i ≤ n Mike is interested in finding minimum possible total energy of some sequence p1 = 1, p2, ..., pk = i.[SOURCE CODE]from Queue import Queue\n\nn = int(raw_input())\nlist = map(int, raw_input().split())\n\nadj = []\ndist = []\n\nfor i in xrange(n): \n\tadj.append([])\n\tdist.append(10**9)\n\t\nfor i in xrange(n-1):\n\tadj[i].append(i+1)\n\tadj[i+1].append(i)\n\t\nfor i in xrange(n):\n\telement = list[i]\n\tif (element-1 != i and element != 0 and element-2 != i) :\n\t\tadj[i].append(list[i]-1)\n\ndef bfs(ind) :\n\tq = Queue()\n\tq.put(ind)\n\tdist[ind] = 0\n\twhile not q.empty():\n\t\tv = q.get()\t\n\t\tfor vizinho in adj[v] :\n\t\t\tif (dist[vizinho] > dist[v] +1) :\n\t\t\t\tdist[vizinho] = dist[v] +1\n\t\t\t\t#print v\n\t\t\t\t#print str(vizinho) + \" \" + str(dist[v] +1)\n\t\t\t\tq.put(vizinho)\nbfs(0)\nresult = \"\"\nfor x in xrange(n):\n\tif (x == n-1) :\n\t\tresult += str(dist[x])\n\telse :\n\t\tresult += str(dist[x]) + \" \"\nprint result","tags":["graphs"],"src_uid":"d465aec304757dff34a770f7877dd940"}
{"text_full":"[DESCRIPTION]You are given a tree (a connected undirected graph without cycles) of $$$n$$$ vertices. Each of the $$$n - 1$$$ edges of the tree is colored in either black or red.You are also given an integer $$$k$$$. Consider sequences of $$$k$$$ vertices. Let's call a sequence $$$[a_1, a_2, \\ldots, a_k]$$$ good if it satisfies the following criterion:  We will walk a path (possibly visiting same edge\/vertex multiple times) on the tree, starting from $$$a_1$$$ and ending at $$$a_k$$$.  Start at $$$a_1$$$, then go to $$$a_2$$$ using the shortest path between $$$a_1$$$ and $$$a_2$$$, then go to $$$a_3$$$ in a similar way, and so on, until you travel the shortest path between $$$a_{k-1}$$$ and $$$a_k$$$. If you walked over at least one black edge during this process, then the sequence is good.   Consider the tree on the picture. If $$$k=3$$$ then the following sequences are good: $$$[1, 4, 7]$$$, $$$[5, 5, 3]$$$ and $$$[2, 3, 7]$$$. The following sequences are not good: $$$[1, 4, 6]$$$, $$$[5, 5, 5]$$$, $$$[3, 7, 3]$$$.There are $$$n^k$$$ sequences of vertices, count how many of them are good. Since this number can be quite large, print it modulo $$$10^9+7$$$.[SOURCE CODE]\"\"\"\nif num edges red <= k - 1:\n    return (n choose k)\n\n# num edges red >= k\n\"\"\"\n\ndef n_perm_k(n, k):\n    return n ** k\n\ndef ways(xs, k):\n    total = n_perm_k(sum(xs), k)\n\n    for x in xs:\n        total -= n_perm_k(x, k)\n    \n    return total\n\ndef dfs(i, graph, visited):\n    stack = [i]\n    count = 0\n    while stack:\n        current = stack.pop()\n        count += 1\n        visited.add(current)\n        for neighbor, black in graph[current].items():\n            if not black and neighbor not in visited:\n                stack.append(neighbor)\n    return count                \n\ndef get_forest_sizes(n, graph):\n    visited = set()\n    components = []\n    for i in range(1, n + 1):\n        if i not in visited:\n            ans = dfs(i, graph, visited)\n            components.append(ans)\n    return components\n\ndef solve(n, k, graph, black_count):\n    if black_count == 0:\n        # no black\n        return 0\n    else:\n        return ways(get_forest_sizes(n, graph), k)\n\nn, k = map(int, input().split())\ngraph = { x: {} for x in range(1, n + 1) }\nblack_count = 0\nfor _ in range(1, n):\n    a, b, black = map(int, input().split())\n    black_count += black\n    graph[a][b] = (black == 1)\n    graph[b][a] = (black == 1)\n\nprint(solve(n, k, graph, black_count) % (10 ** 9 + 7))","tags":["graphs","math","trees"],"src_uid":"94559f08866b6136ba4791c440025a68"}
{"text_full":"[DESCRIPTION]Bandits appeared in the city! One of them is trying to catch as many citizens as he can.The city consists of $$$n$$$ squares connected by $$$n-1$$$ roads in such a way that it is possible to reach any square from any other square. The square number $$$1$$$ is the main square.After Sunday walk all the roads were changed to one-way roads in such a way that it is possible to reach any square from the main square.At the moment when the bandit appeared on the main square there were $$$a_i$$$ citizens on the $$$i$$$-th square. Now the following process will begin. First, each citizen that is currently on a square with some outgoing one-way roads chooses one of such roads and moves along it to another square. Then the bandit chooses one of the one-way roads outgoing from the square he is located and moves along it. The process is repeated until the bandit is located on a square with no outgoing roads. The bandit catches all the citizens on that square.The bandit wants to catch as many citizens as possible; the citizens want to minimize the number of caught people. The bandit and the citizens know positions of all citizens at any time, the citizens can cooperate. If both sides act optimally, how many citizens will be caught?[SOURCE CODE]n = int(input())\np = list(map(int, input().split()))\na = list(map(int, input().split()))\n\ntree = {}\n\nfor i, pp in enumerate(p, start=2):\n    tree.setdefault(pp, []).append(i)\n    \ncache = {}\n\nfor s in range(n, 0, -1):\n    children = tree.get(s, [])\n    if len(children) == 0:\n        cache[s] = (a[s - 1], a[s - 1], 1)\n        continue\n    ch_p = [cache[c] for c in children]\n    ch_max = max(pp[0] for pp in ch_p)\n    ch_sum = sum(pp[1] for pp in ch_p)\n    ch_l = sum(pp[2] for pp in ch_p)\n    sm = ch_sum + a[s - 1]\n    m = sm \/\/ ch_l\n    if sm % ch_l != 0:\n        m += 1\n    cache[s] = (max(ch_max, m), sm, ch_l)\n    \nprint(cache[1][0])","tags":["graphs","trees"],"src_uid":"18cf79b50d0a389e6c3afd5d2f6bd9ed"}
{"text_full":"[DESCRIPTION]You are given an array $$$a$$$ of $$$n$$$ positive integers.You can use the following operation as many times as you like: select any integer $$$1 \\le k \\le n$$$ and do one of two things:   decrement by one $$$k$$$ of the first elements of the array.  decrement by one $$$k$$$ of the last elements of the array. For example, if $$$n=5$$$ and $$$a=[3,2,2,1,4]$$$, then you can apply one of the following operations to it (not all possible options are listed below):   decrement from the first two elements of the array. After this operation $$$a=[2, 1, 2, 1, 4]$$$;  decrement from the last three elements of the array. After this operation $$$a=[3, 2, 1, 0, 3]$$$;  decrement from the first five elements of the array. After this operation $$$a=[2, 1, 1, 0, 3]$$$; Determine if it is possible to make all the elements of the array equal to zero by applying a certain number of operations.[SOURCE CODE]t = int(input())\n \nfor i in range(t):\n    n = int(input())\n    a = [0] + list(map(int, input().split()))\n    \n    ans = [a[i] - a[i-1] for i in range(1, n+1)]\n    \n    result = 0\n    for i in range(1, n):\n        if ans[i] < 0:\n            result = result + (-1)*ans[i]\n    if result <= a[1]:\n        print(\"YES\")\n    else:\n        print(\"NO\")","tags":["math"],"src_uid":"6e6356adb23da0dfa38834a0e157524c"}
{"text_full":"[DESCRIPTION]If the girl doesn't go to Denis, then Denis will go to the girl. Using this rule, the young man left home, bought flowers and went to Nastya. On the way from Denis's house to the girl's house is a road of $$$n$$$ lines. This road can't be always crossed in one green light. Foreseeing this, the good mayor decided to place safety islands in some parts of the road. Each safety island is located after a line, as well as at the beginning and at the end of the road. Pedestrians can relax on them, gain strength and wait for a green light.Denis came to the edge of the road exactly at the moment when the green light turned on. The boy knows that the traffic light first lights up $$$g$$$ seconds green, and then $$$r$$$ seconds red, then again $$$g$$$ seconds green and so on.Formally, the road can be represented as a segment $$$[0, n]$$$. Initially, Denis is at point $$$0$$$. His task is to get to point $$$n$$$ in the shortest possible time.He knows many different integers $$$d_1, d_2, \\ldots, d_m$$$, where $$$0 \\leq d_i \\leq n$$$  — are the coordinates of points, in which the safety islands are located. Only at one of these points, the boy can be at a time when the red light is on.Unfortunately, Denis isn't always able to control himself because of the excitement, so some restrictions are imposed:  He must always move while the green light is on because it's difficult to stand when so beautiful girl is waiting for you. Denis can change his position by $$$\\pm 1$$$ in $$$1$$$ second. While doing so, he must always stay inside the segment $$$[0, n]$$$.  He can change his direction only on the safety islands (because it is safe). This means that if in the previous second the boy changed his position by $$$+1$$$ and he walked on a safety island, then he can change his position by $$$\\pm 1$$$. Otherwise, he can change his position only by $$$+1$$$. Similarly, if in the previous second he changed his position by $$$-1$$$, on a safety island he can change position by $$$\\pm 1$$$, and at any other point by $$$-1$$$.  At the moment when the red light is on, the boy must be on one of the safety islands. He can continue moving in any direction when the green light is on. Denis has crossed the road as soon as his coordinate becomes equal to $$$n$$$.This task was not so simple, because it's possible that it is impossible to cross the road. Since Denis has all thoughts about his love, he couldn't solve this problem and asked us to help him. Find the minimal possible time for which he can cross the road according to these rules, or find that it is impossible to do.[SOURCE CODE]import collections\n\nn,m=map(int,input().split())\nm+=2\narr=list(map(int,input().split()))\narr.append(0)\narr.append(n)\narr=sorted(arr)\ng,r=map(int,input().split())\nq=collections.deque()\nq.append((0,0))\ndist=[[0]*(g+1) for _ in range(m+2)]\nchecked=[[0]*(g+1) for _ in range(m+2)]\nchecked[0][0]=1\nans=-1\nwhile len(q)!=0:\n  v,t=q.popleft()\n  if t==0:\n    if n-arr[v]<=g:\n      tmp=dist[v][t]*(g+r)+n-arr[v]\n      if ans==-1 or ans>tmp:\n        ans=tmp\n  if t==g:\n    if checked[v][0]==0:\n      checked[v][0]=1\n      dist[v][0]=dist[v][t]+1\n      q.append((v,0))\n    continue\n  if v!=0:\n    cost=t+arr[v]-arr[v-1]\n    if cost<=g and checked[v-1][cost]==0:\n      checked[v-1][cost]=1\n      dist[v-1][cost]=dist[v][t]\n      q.appendleft((v-1,cost))\n  if v!=m-1:\n    cost=t+arr[v+1]-arr[v]\n    if cost<=g and checked[v+1][cost]==0:\n      checked[v+1][cost]=1\n      dist[v+1][cost]=dist[v][t]\n      q.appendleft((v+1,cost))\nprint(ans)","tags":["graphs"],"src_uid":"64625b26514984c4425c2813612115b3"}
{"text_full":"[DESCRIPTION]Having bought his own apartment, Boris decided to paper the walls in every room. Boris's flat has n rooms, each of which has the form of a rectangular parallelepiped. For every room we known its length, width and height of the walls in meters (different rooms can have different dimensions, including height).Boris chose m types of wallpaper to paper the walls of the rooms with (but it is not necessary to use all the types). Each type of wallpaper is sold in rolls of a fixed length and width (the length, naturally, shows how long the unfolded roll will be). In addition, for each type we know the price of one roll of this type.The wallpaper of each type contains strips running along the length of the roll. When gluing the strips must be located strictly vertically (so the roll cannot be rotated, even if the length is less than the width). Besides, a roll can be cut in an arbitrary manner, but the joints of glued pieces should also be vertical. In addition, each room should be papered by only one type of wallpaper. And pieces of the same roll cannot be used to paper different rooms. That is, for each room the rolls are purchased separately. Also, some rolls can be used not completely.After buying an apartment Boris is short of cash, so he wants to spend the minimum money on wallpaper. Help him.[SOURCE CODE]n = int(input())\nrooms = [[int(i) for i in input().split()] for i in range(n)]\nm = int(input())\npapers = [[int(i) for i in input().split()] for i in range(m)]\nans = 0\nfor room in rooms:\n\tper = (room[0]+room[1])*2\n\tprices = []\n\tfor cur in papers:\n\t\tpower = cur[0]\/\/room[2]*cur[1]\n\t\tif(power == 0):\n\t\t\tcontinue\n\t\tprices.append((per+power-1)\/\/power*cur[2])\n\tans += min(prices)\nprint(ans)","tags":["math"],"src_uid":"29639971c98dd98f0292d994d4433e3a"}
{"text_full":"[DESCRIPTION]You and your $$$n - 1$$$ friends have found an array of integers $$$a_1, a_2, \\dots, a_n$$$. You have decided to share it in the following way: All $$$n$$$ of you stand in a line in a particular order. Each minute, the person at the front of the line chooses either the first or the last element of the array, removes it, and keeps it for himself. He then gets out of line, and the next person in line continues the process.You are standing in the $$$m$$$-th position in the line. Before the process starts, you may choose up to $$$k$$$ different people in the line, and persuade them to always take either the first or the last element in the array on their turn (for each person his own choice, not necessarily equal for all people), no matter what the elements themselves are. Once the process starts, you cannot persuade any more people, and you cannot change the choices for the people you already persuaded.Suppose that you're doing your choices optimally. What is the greatest integer $$$x$$$ such that, no matter what are the choices of the friends you didn't choose to control, the element you will take from the array will be greater than or equal to $$$x$$$?Please note that the friends you don't control may do their choice arbitrarily, and they will not necessarily take the biggest element available.[SOURCE CODE]def inp(dtype=str, strip=True):\n    s = input()\n    res = [dtype(p) for p in s.split()]\n    res = res[0] if len(res) == 1 and strip else res\n    return res\n\n\ndef problemA():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        s = input()\n        s = [int(el) for el in s]\n\n        res = '-1'\n        cum = sum(s)\n        i = 1\n        while i <= n:\n            if s[-i] % 2 != 0 and cum % 2 == 0:\n                res = ''.join([str(s[j]) for j in range(n - i + 1)])\n                break\n            cum -= s[-i]\n            i += 1\n\n        print(res)\n\n\ndef problemB():\n    t = int(input())\n    for tcase in range(t):\n        n = int(input())\n        a = inp(int, strip=False)\n\n        next = a[0] + 1 if a[0] <= 0 else 1\n        i = 1\n        while i < n and a[i] >= next:\n            if a[i] < 0:\n                next = a[i] + 1\n            elif next <= 0:\n                next = 1\n            else:\n                next += 1\n            i += 1\n\n        if i == n:\n            print('YES')\n            continue\n\n        ileft = i - 1\n        gapleft = a[ileft] < next - 1\n\n        i = n - 1\n        next = a[i] + 1 if a[i] <= 0 else 1\n        i -= 1\n        while i >= 0 and a[i] >= next:\n            if a[i] < 0:\n                next = a[i] + 1\n            elif next <= 0:\n                next = 1\n            else:\n                next += 1\n            i -= 1\n\n        if i < 0:\n            print('YES')\n            continue\n\n        iright = i + 1\n        gapright = a[iright] < next - 1\n\n        # print(tcase, ileft, iright)\n\n        if ileft + 1 > iright:\n            print('YES')\n        elif ileft + 1 == iright:\n            if a[ileft] != a[iright]:\n                print('YES')\n            elif a[ileft] > 0 and (gapleft or gapright):\n                print('YES')\n            else:\n                print('NO')\n        else:\n            print('NO')\n\n\ndef problemC():\n    t = int(input())\n    for _ in range(t):\n        n, m, k = inp(int)\n        k = min(k, m - 1)\n        a = inp(int, strip=False)\n\n        b = [max(a[i], a[i + (n - m)]) for i in range(0, m)]\n\n        x = max(min(b[i:i+(m-k)]) for i in range(k+1))\n\n        print(x)\n\n\nif __name__ == '__main__':\n    # problemA()\n    # problemB()\n    problemC()","tags":["math"],"src_uid":"f2f9f63a952794f27862eb24ccbdbf36"}
{"text_full":"[DESCRIPTION]Since the giant heads have appeared in the sky all humanity is in danger, so all Ricks and Mortys from all parallel universes are gathering in groups to find a solution to get rid of them. There are n parallel universes participating in this event (n Ricks and n Mortys). I. e. each of n universes has one Rick and one Morty. They're gathering in m groups. Each person can be in many groups and a group can contain an arbitrary number of members.Ricks and Mortys have registered online in these groups. So, a person can have joined a group more than once (developer of this website hadn't considered this possibility).  Summer from universe #1 knows that in each parallel universe (including hers) exactly one of Rick and Morty from that universe is a traitor and is loyal, but no one knows which one. She knows that we are doomed if there's a group such that every member in that group is a traitor (they will plan and destroy the world). Summer knows that if there's a possibility that world ends (there's a group where all members are traitors) she should immediately cancel this event. So she wants to know if she should cancel the event. You have to tell her yes if and only if there's at least one scenario (among all 2n possible scenarios, 2 possible scenarios for who a traitor in each universe) such that in that scenario the world will end.[SOURCE CODE]n, m = map(int, input().split())\n\nfor i in range(m):\n    bad = True\n    l = set(map(int, input().split()[1:]))\n    for j in l:\n        if -j in l:\n            bad = False\n            break\n            \n    if bad:\n        break\n        \nprint(\"YES\" if bad else \"NO\")","tags":["math"],"src_uid":"f110b9351fe8ff20676d11ecfc92aee3"}
{"text_full":"[DESCRIPTION]Vasya has got a magic matrix $$$a$$$ of size $$$n \\times m$$$. The rows of the matrix are numbered from $$$1$$$ to $$$n$$$ from top to bottom, the columns are numbered from $$$1$$$ to $$$m$$$ from left to right. Let $$$a_{ij}$$$ be the element in the intersection of the $$$i$$$-th row and the $$$j$$$-th column.Vasya has also got a chip. Initially, the chip is in the intersection of the $$$r$$$-th row and the $$$c$$$-th column (that is, in the element $$$a_{rc}$$$). Vasya performs the following process as long as possible: among all elements of the matrix having their value less than the value of the element with the chip in it, Vasya randomly and equiprobably chooses one element and moves his chip to this element.After moving the chip, he adds to his score the square of the Euclidean distance between these elements (that is, between the element in which the chip is now and the element the chip was moved from). The process ends when there are no elements having their values less than the value of the element with the chip in it.Euclidean distance between matrix elements with coordinates $$$(i_1, j_1)$$$ and $$$(i_2, j_2)$$$ is equal to $$$\\sqrt{(i_1-i_2)^2 + (j_1-j_2)^2}$$$.Calculate the expected value of the Vasya's final score.It can be shown that the answer can be represented as $$$\\frac{P}{Q}$$$, where $$$P$$$ and $$$Q$$$ are coprime integer numbers, and $$$Q \\not\\equiv 0~(mod ~ 998244353)$$$. Print the value $$$P \\cdot Q^{-1}$$$ modulo $$$998244353$$$.[SOURCE CODE]n,m = map(int,raw_input().split(\" \"))\nmat = [0]*(n*m)\nfor i in range(n):\n    mat[i*m:i*m+m] = map(int,raw_input().split(\" \"))\nr,c = map(int,raw_input().split(\" \"))\n\nidx = range(n*m)\nidx.sort(key = lambda x:mat[x])\nrank = [0]*(n*m)\nfor i in xrange(n*m):\n    rank[idx[i]] = i\n\ndp = [0]*(n*m)\n\nmod = 998244353\ninv = [1]*(n*m)\n\nfor i in xrange(2,n*m):\n    inv[i] = (mod-mod\/i)*inv[mod%i] % mod\ni = idx[0]\nx1,y1,x2,y2,s = [0]*2,[0]*2,[0]*2,[0]*2,[0]*2\n\nx1[1] = i\/m\ny1[1] = i%m\nx2[1] = (x1[1]*x1[1])\ny2[1] = (y1[1]*y1[1])\ns[1] = 0\nla = -1\nfinal = (r-1)*m+c-1\nfor i in xrange(1,rank[final]+1):\n    j = idx[i]\n    x,y = j\/m,j%m\n    if mat[j] == mat[idx[i-1]]:\n        dp[i] =(s[0]*deno+x*x+y*y+deno*(x2[0]+y2[0]-2*x1[0]*x-2*y1[0]*y))%mod if la!=-1 else 0\n    else:\n        deno = inv[i]\n        dp[i] = (s[-1]*deno+x*x+y*y+deno*(x2[-1]+y2[-1]-2*x1[-1]*x-2*y1[-1]*y))%mod\n        x1[0] = x1[1]\n        y1[0] = y1[1]\n        x2[0] = x2[1]\n        y2[0] = y2[1]\n        s[0] = s[1]\n        la = 0\n    x1[-1] = (x1[-1]+x)%mod\n    y1[-1] = (y1[-1]+y)%mod\n    x2[-1] = (x2[-1]+x*x)%mod\n    y2[-1] = (y2[-1]+y*y)%mod\n    s[-1] = (s[-1]+dp[i])%mod\nprint dp[rank[final]]","tags":["probabilities","math"],"src_uid":"881c694ecf973da66073e77f38abcae2"}
{"text_full":"[DESCRIPTION]Karafs is some kind of vegetable in shape of an 1 × h rectangle. Tavaspolis people love Karafs and they use Karafs in almost any kind of food. Tavas, himself, is crazy about Karafs.  Each Karafs has a positive integer height. Tavas has an infinite 1-based sequence of Karafses. The height of the i-th Karafs is si = A + (i - 1) × B.For a given m, let's define an m-bite operation as decreasing the height of at most m distinct not eaten Karafses by 1. Karafs is considered as eaten when its height becomes zero.Now SaDDas asks you n queries. In each query he gives you numbers l, t and m and you should find the largest number r such that l ≤ r and sequence sl, sl + 1, ..., sr can be eaten by performing m-bite no more than t times or print -1 if there is no such number r.[SOURCE CODE]import math\nA, B, n = map(int, input().split())\nans = []\n\nfor _ in range(n):\n\tl, t, m = map(int, input().split())\n\t\n\tif A + B * (l - 1) > t:\n\t\tans.append(-1)\n\t\tcontinue\n\n\tr1 = (t - A) \/ B + 1\n\tD = (B-2*A)*(B-2*A)-4*B*(-2*l*A+2*A-B*(l-2)*(l-1)-2*m*t)\n\tr2 = int(((B-2*A) + math.sqrt(D)) \/ 2 \/ B)\n\n\tif r1 > r2:\n\t\tr1 = r2\n\tans.append(int(r1))\n\n\nprint(\"\\n\".join(map(str, ans)))","tags":["math"],"src_uid":"89c97b6c302bbb51e9d5328c680a7ea7"}
{"text_full":"[DESCRIPTION]Polycarpus has an array, consisting of n integers a1, a2, ..., an. Polycarpus likes it when numbers in an array match. That's why he wants the array to have as many equal numbers as possible. For that Polycarpus performs the following operation multiple times:  he chooses two elements of the array ai, aj (i ≠ j);  he simultaneously increases number ai by 1 and decreases number aj by 1, that is, executes ai = ai + 1 and aj = aj - 1. The given operation changes exactly two distinct array elements. Polycarpus can apply the described operation an infinite number of times. Now he wants to know what maximum number of equal array elements he can get if he performs an arbitrary number of such operation. Help Polycarpus.[SOURCE CODE]def solve(n, a):\n  s = sum(a)\n  if s % n == 0: return n\n  return n-1\n\nn = int(raw_input())\na = map(int, raw_input().split())\nprint solve(n, a)","tags":["math"],"src_uid":"71cead8cf45126902c518c9ce6e5e186"}
{"text_full":"[DESCRIPTION]There is a given string S consisting of N symbols. Your task is to find the number of ordered pairs of integers i and j such that1. 1 ≤ i, j ≤ N2. S[i] = S[j], that is the i-th symbol of string S is equal to the j-th.[SOURCE CODE]def f(x=input()):\n\td = dict()\n\tfor i in x:\n\t\tif i in d: d[i]+=1\n\t\telse: d[i] = 1\n\treturn sum([j*j for _,j in d.items()])\nprint(f())","tags":["strings"],"src_uid":"6bb2793e275426eb076972fab69d0eba"}
{"text_full":"[DESCRIPTION]Valera had two bags of potatoes, the first of these bags contains x (x ≥ 1) potatoes, and the second — y (y ≥ 1) potatoes. Valera — very scattered boy, so the first bag of potatoes (it contains x potatoes) Valera lost. Valera remembers that the total amount of potatoes (x + y) in the two bags, firstly, was not gerater than n, and, secondly, was divisible by k.Help Valera to determine how many potatoes could be in the first bag. Print all such possible numbers in ascending order.[SOURCE CODE]y, k, n = map(int, input().split())\nprint(' '.join(map(str, range(y\/\/k*k+k-y, n-y+1, k))) if n\/\/k>y\/\/k else -1)","tags":["math"],"src_uid":"2deda3a05740e1184735bf437e3850a8"}
{"text_full":"[DESCRIPTION]Petya and Vasya are competing with each other in a new interesting game as they always do.At the beginning of the game Petya has to come up with an array of $$$N$$$ positive integers. Sum of all elements in his array should be equal to $$$S$$$. Then Petya has to select an integer $$$K$$$ such that $$$0 \\leq K \\leq S$$$.In order to win, Vasya has to find a non-empty subarray in Petya's array such that the sum of all selected elements equals to either $$$K$$$ or $$$S - K$$$. Otherwise Vasya loses.You are given integers $$$N$$$ and $$$S$$$. You should determine if Petya can win, considering Vasya plays optimally. If Petya can win, help him to do that.[SOURCE CODE]n,s = list(map(int,input().split()))\n\nval = s\/\/n\nrem = s%n\n\nv1 = val\nv2 = val+rem\nif v1>1:\n    print('YES')\n    for i in range(0,n-1):\n        print(v1,end=\" \")\n    print(v2)\n    print(1)\nelse:\n    print('NO')","tags":["math"],"src_uid":"4a644d97824d29c42dbb48d79b9958fe"}
{"text_full":"[DESCRIPTION]Bachgold problem is very easy to formulate. Given a positive integer n represent it as a sum of maximum possible number of prime numbers. One can prove that such representation exists for any integer greater than 1.Recall that integer k is called prime if it is greater than 1 and has exactly two positive integer divisors — 1 and k.[SOURCE CODE]n = int(input())\nprint n >> 1\nwhile n > 0:\n\tif n % 2 > 0:\n\t\tprint 3, \n\t\tn -= 3\n\telse:\n\t\tprint 2, \n\t\tn -= 2","tags":["number theory","math"],"src_uid":"98fd00d3c83d4b3f0511d8afa6fdb27b"}
{"text_full":"[DESCRIPTION]Bessie the cow has just intercepted a text that Farmer John sent to Burger Queen! However, Bessie is sure that there is a secret message hidden inside.The text is a string $$$s$$$ of lowercase Latin letters. She considers a string $$$t$$$ as hidden in string $$$s$$$ if $$$t$$$ exists as a subsequence of $$$s$$$ whose indices form an arithmetic progression. For example, the string aab is hidden in string aaabb because it occurs at indices $$$1$$$, $$$3$$$, and $$$5$$$, which form an arithmetic progression with a common difference of $$$2$$$. Bessie thinks that any hidden string that occurs the most times is the secret message. Two occurrences of a subsequence of $$$S$$$ are distinct if the sets of indices are different. Help her find the number of occurrences of the secret message!For example, in the string aaabb, a is hidden $$$3$$$ times, b is hidden $$$2$$$ times, ab is hidden $$$6$$$ times, aa is hidden $$$3$$$ times, bb is hidden $$$1$$$ time, aab is hidden $$$2$$$ times, aaa is hidden $$$1$$$ time, abb is hidden $$$1$$$ time, aaab is hidden $$$1$$$ time, aabb is hidden $$$1$$$ time, and aaabb is hidden $$$1$$$ time. The number of occurrences of the secret message is $$$6$$$.[SOURCE CODE]from string import ascii_lowercase\n\n\ns = input()\nlc = {c: 0 for c in ascii_lowercase}\nllc = dict()\n\nfor c in s:\n    for v in lc:\n        if v + c not in llc:\n            llc[v + c] = lc[v]\n        else:\n            llc[v + c] += lc[v]\n    lc[c] += 1\n\nprint(max(*lc.values(), *llc.values()))","tags":["math","strings"],"src_uid":"69135ef7422b5811ae935a9d00796f88"}
{"text_full":"[DESCRIPTION]You may have already known that a standard ICPC team consists of exactly three members. The perfect team however has more restrictions. A student can have some specialization: coder or mathematician. She\/he can have no specialization, but can't have both at the same time.So the team is considered perfect if it includes at least one coder, at least one mathematician and it consists of exactly three members.You are a coach at a very large university and you know that $$$c$$$ of your students are coders, $$$m$$$ are mathematicians and $$$x$$$ have no specialization.What is the maximum number of full perfect teams you can distribute them into? Note that some students can be left without a team and each student can be a part of no more than one team.You are also asked to answer $$$q$$$ independent queries.[SOURCE CODE]#! \/usr\/bin\/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n\n\ndef numTeam(c, m, x):\n    cmMin = min(c, m)\n\n    # max(c,m) >= x >= min(c,m): Somente min(c,n) times com 1 de cada\n    if x >= cmMin:\n        return cmMin\n    # max(c,m) >= min(c,m) > x: Times podem ter 2 c ou 2 m\n    else:\n        return min((c+m+x)\/\/3, cmMin)\n        # times = x\n        # a, b = max(c-x, m-x), min(c-x, m-x)\n        # while(True):\n        #     b -= 1\n        #     a -= 2\n        #     if b >= 0 and a >= 0:\n        #         times += 1\n        #         a, b = max(a, b), min(a, b)\n        #     else:\n        #         break\n        # return times\n\n\nfor i in range(int(input())):\n    coder, mathMan, normalMan = map(int, input().split())\n    print(numTeam(coder, mathMan, normalMan))","tags":["math"],"src_uid":"b18dac401b655c06bee331e71eb3e4de"}
{"text_full":"[DESCRIPTION]When Serezha was three years old, he was given a set of cards with letters for his birthday. They were arranged into words in the way which formed the boy's mother favorite number in binary notation. Serezha started playing with them immediately and shuffled them because he wasn't yet able to read. His father decided to rearrange them. Help him restore the original number, on condition that it was the maximum possible one.[SOURCE CODE]n = int(input())\nw = input()\nw.upper()\na=0\nb=0\nfor i in range(n):\n    if w[i]=='n':\n        a=a+1\n    elif w[i]=='z':\n        b=b+1\nprint(\"1 \"*a+\"0 \"*b)","tags":["strings"],"src_uid":"5e5dbd70c7fcedf0f965aed5bafeb06c"}
{"text_full":"[DESCRIPTION]You are given a functional graph. It is a directed graph, in which from each vertex goes exactly one arc. The vertices are numerated from 0 to n - 1.Graph is given as the array f0, f1, ..., fn - 1, where fi — the number of vertex to which goes the only arc from the vertex i. Besides you are given array with weights of the arcs w0, w1, ..., wn - 1, where wi — the arc weight from i to fi.    The graph from the first sample test. Also you are given the integer k (the length of the path) and you need to find for each vertex two numbers si and mi, where:  si — the sum of the weights of all arcs of the path with length equals to k which starts from the vertex i;  mi — the minimal weight from all arcs on the path with length k which starts from the vertex i. The length of the path is the number of arcs on this path.[SOURCE CODE]import sys\nn, k = map(int, sys.stdin.buffer.readline().decode('utf-8').split())\na = list(map(int, sys.stdin.buffer.readline().decode('utf-8').split()))\nb = list(map(int, sys.stdin.buffer.readline().decode('utf-8').split()))\n\nlogk = len(bin(k)) - 2\nsum_w, sum_w_p = b[:], b[:]\nmin_w, min_w_p = b[:], b[:]\ndest, dest_p = a[:], a[:]\n\nans_sum, ans_min, pos = [0]*n, b[:], list(range(n))\nif k & 1:\n    ans_sum = b[:]\n    pos = [a[i] for i in range(n)]\nk >>= 1\n\nfor j in range(1, logk):\n    for i in range(n):\n        d = dest[i]\n        p = 0 if d > i else 1\n        dest_p[i] = d\n        dest[i] = (dest_p if p else dest)[d]\n        sum_w_p[i] = sum_w[i]\n        sum_w[i] += (sum_w_p if p else sum_w)[d]\n        min_w_p[i] = min_w[i]\n        if min_w[i] > (min_w_p if p else min_w)[d]:\n            min_w[i] = (min_w_p if p else min_w)[d]\n\n    if k & 1:\n        for i in range(n):\n            ans_sum[i] += sum_w[pos[i]]\n            if ans_min[i] > min_w[pos[i]]:\n                ans_min[i] = min_w[pos[i]]\n            pos[i] = dest[pos[i]]\n    k >>= 1\n\n\nsys.stdout.buffer.write('\\n'.join(\n    (str(ans_sum[i]) + ' ' + str(ans_min[i]) for i in range(n))).encode('utf-8'))","tags":["graphs"],"src_uid":"d84d878719124acf7ab3af6ae787ceee"}
{"text_full":"[DESCRIPTION]You are given a permutation p of length n. Remove one element from permutation to make the number of records the maximum possible.We remind that in a sequence of numbers a1, a2, ..., ak the element ai is a record if for every integer j (1 ≤ j &lt; i) the following holds: aj &lt; ai.[SOURCE CODE]import sys\n\ncases = sys.stdin.readline()\nmy_list = [int(a) for a in sys.stdin.readline().split(\" \")]\n#my_list = [4, 5, 3, 2, 1]\n\nmax_val_a = my_list[0]\nmax_val_b = 0\n\nmy_counts = dict()\nfor x in my_list:\n  my_counts[x] = 0\n\nmy_counts[max_val_a] = -1\n\nfor x in my_list:\n  #print(my_counts)\n  if(x > max_val_a):\n    my_counts[x] = my_counts[x] - 1\n    max_val_a, max_val_b = x, max_val_a\n  elif (x < max_val_a and x > max_val_b):\n    my_counts[max_val_a] = my_counts[max_val_a] + 1\n    max_val_b = x\n    \n#print(my_counts)\nhighest = max(my_counts.values())\nprint(min([k for k, v in my_counts.items() if v == highest]))","tags":["math"],"src_uid":"c15ad483441864b3222eb62723b598e1"}
{"text_full":"[DESCRIPTION]We guessed some integer number $$$x$$$. You are given a list of almost all its divisors. Almost all means that there are all divisors except $$$1$$$ and $$$x$$$ in the list.Your task is to find the minimum possible integer $$$x$$$ that can be the guessed number, or say that the input data is contradictory and it is impossible to find such number.You have to answer $$$t$$$ independent queries.[SOURCE CODE]from bisect import bisect_right as br\nfrom bisect import bisect_left as bl\nfrom collections import *\nfrom itertools import *\nimport functools\nimport sys\nfrom math import *\nfrom decimal import *\nfrom copy import *\ngetcontext().prec = 30\nMAX = sys.maxsize\nMAXN = 10**6+10\nMOD = 10**9+7\ndef isprime(n):\n    n = abs(int(n))\n    if n < 2:\n        return False\n    if n == 2: \n        return True    \n    if not n & 1: \n        return False\n    for x in range(3, int(n**0.5) + 1, 2):\n        if n % x == 0:\n            return False\n    return True\n\ndef mhd(a,b,x,y):\n    return abs(a-x)+abs(b-y)\n\ndef numIN(x = \" \"):\n    return(map(int,sys.stdin.readline().strip().split(x)))\n\ndef charIN(x= ' '):\n    return(sys.stdin.readline().strip().split(x))\n\ndef arrIN():\n    return list(numIN())\n\ndef dis(x,y):\n    a = y[0]-x[0]\n    b = x[1]-y[1]\n    return (a*a+b*b)**0.5\n\ndef lgcd(a):\n    g = a[0]\n    for i in range(1,len(a)):\n        g = math.gcd(g,a[i])\n    return g\n\ndef ms(a):\n    msf = -MAX\n    meh = 0\n    st = en = be = 0\n    for i in range(len(a)):\n        meh+=a[i]\n        if msf<meh:\n            msf = meh\n            st = be\n            en = i\n        if meh<0:\n            meh = 0\n            be = i+1\n    return msf,st,en\n\n\ndef res(ans,t):\n    print('Case #{}: {} {}'.format(t,ans[0],ans[1]))\n\ndef divi(n):\n    l = []\n    for i in range(1,int(n**0.5)+1):\n        if n%i==0:\n            if n\/\/i==i:\n                l.append(i)\n            else:\n                l.append(i)\n                l.append(n\/\/i)\n    return l\n\nfor _ in range(int(input())):\n    n = int(input())\n    a = arrIN()\n    a.sort()\n    x = a[0]*a[-1]\n    fl = [0]*MAXN\n    f = 1\n    for i in a:\n        fl[i] = 1\n    fl[1] = 1\n    for j in a:\n        l = divi(j)\n        for i in l:\n            if not fl[i]:\n                print(-1)\n                f = 0\n                break\n        if not f:\n            break\n    if f:\n        for i in range(n\/\/2+1):\n            if a[i]*a[n-i-1]!=x:\n                print(-1)\n                f = 0\n                break\n    if f:\n        print(x)","tags":["number theory","math"],"src_uid":"fe9b1527571ea37f402512ac378dee13"}
{"text_full":"[DESCRIPTION]Mahmoud was trying to solve the vertex cover problem on trees. The problem statement is:Given an undirected tree consisting of n nodes, find the minimum number of vertices that cover all the edges. Formally, we need to find a set of vertices such that for each edge (u, v) that belongs to the tree, either u is in the set, or v is in the set, or both are in the set. Mahmoud has found the following algorithm:  Root the tree at node 1.  Count the number of nodes at an even depth. Let it be evenCnt.  Count the number of nodes at an odd depth. Let it be oddCnt.  The answer is the minimum between evenCnt and oddCnt. The depth of a node in a tree is the number of edges in the shortest path between this node and the root. The depth of the root is 0.Ehab told Mahmoud that this algorithm is wrong, but he didn't believe because he had tested his algorithm against many trees and it worked, so Ehab asked you to find 2 trees consisting of n nodes. The algorithm should find an incorrect answer for the first tree and a correct answer for the second one.[SOURCE CODE]def wrong(x):\n    if n < 6:\n        print(-1)\n    else:\n        print(\"1 2\")\n        print(\"2 3\")\n        print(\"2 4\")\n        print(\"4 5\")\n        print(\"4 6\")\n        for i in range(7, x + 1):\n            print(\"4\", i)\n\n\ndef true(x):\n    for i in range(x-1):\n        print(i+1,i+2)\n\nn = int(input())\nwrong(n)\ntrue(n)","tags":["trees"],"src_uid":"b1959af75dfdf8281e70ae66375caa14"}
{"text_full":"[DESCRIPTION]You are given two positive integers $$$a$$$ and $$$b$$$. In one move you can increase $$$a$$$ by $$$1$$$ (replace $$$a$$$ with $$$a+1$$$). Your task is to find the minimum number of moves you need to do in order to make $$$a$$$ divisible by $$$b$$$. It is possible, that you have to make $$$0$$$ moves, as $$$a$$$ is already divisible by $$$b$$$. You have to answer $$$t$$$ independent test cases.[SOURCE CODE]for i in range(int(input())) :\n    a1, a2 = map(int, input().split())\n    if a1%a2 == 0 : \n        print(0)\n    else :\n        tempmin = a1\/\/a2+1  \n        ans = a2*tempmin -a1\n        print(ans)","tags":["math"],"src_uid":"d9fd10700cb122b148202a664e7f7689"}
{"text_full":"[DESCRIPTION]Let's consider all integers in the range from $$$1$$$ to $$$n$$$ (inclusive).Among all pairs of distinct integers in this range, find the maximum possible greatest common divisor of integers in pair. Formally, find the maximum value of $$$\\mathrm{gcd}(a, b)$$$, where $$$1 \\leq a &lt; b \\leq n$$$.The greatest common divisor, $$$\\mathrm{gcd}(a, b)$$$, of two positive integers $$$a$$$ and $$$b$$$ is the biggest integer that is a divisor of both $$$a$$$ and $$$b$$$.[SOURCE CODE]MOD = 1000000007\nii = lambda :  int(input())\nsi = lambda :  input()\ndgl = lambda : list(map(int, input()))\nf = lambda :   map(int, input().split())\nil = lambda :  list(map(int, input().split()))\nls = lambda :  list(input())\nfrom collections import *\nfor _ in range(ii()):\n    n=ii()\n    if(n%2==0):\n        print(n\/\/2)\n    elif(n<=3):\n        print(1)\n    else:\n        print((n-1)\/\/2)","tags":["number theory","math"],"src_uid":"b46244f39e30c0cfab592a97105c60f4"}
{"text_full":"[DESCRIPTION]Limak is an old brown bear. He often plays poker with his friends. Today they went to a casino. There are n players (including Limak himself) and right now all of them have bids on the table. i-th of them has bid with size ai dollars.Each player can double his bid any number of times and triple his bid any number of times. The casino has a great jackpot for making all bids equal. Is it possible that Limak and his friends will win a jackpot?[SOURCE CODE]from fractions import gcd\nimport math\n\ndef lcm(x, y):\n\treturn (x * y) \/\/ gcd(x, y)\n\ndef is_valid(num):\n\twhile num % 3 == 0:\n\t\tnum \/= 3\n\twhile num % 2 == 0:\n\t\tnum \/= 2\n\treturn num == 1\n\nn = int(raw_input())\nnums = map(int, raw_input().strip().split(\" \"))\npossible = True\n\nfor i in range(1, len(nums)):\n\tres = lcm(nums[i], nums[i-1])\n\tm1 = res \/\/ nums[i]\n\tm2 = res \/\/ nums[i-1]\n\n\tif not is_valid(m1) or not is_valid(m2):\n\t\tpossible = False\n\t\tbreak\n\nif possible:\n\tprint(\"Yes\")\nelse:\n\tprint(\"No\")","tags":["number theory","math"],"src_uid":"2bb893703cbffe9aeaa0bed02f42a05c"}
{"text_full":"[DESCRIPTION]Cat Noku has obtained a map of the night sky. On this map, he found a constellation with n stars numbered from 1 to n. For each i, the i-th star is located at coordinates (xi, yi). No two stars are located at the same position.In the evening Noku is going to take a look at the night sky. He would like to find three distinct stars and form a triangle. The triangle must have positive area. In addition, all other stars must lie strictly outside of this triangle. He is having trouble finding the answer and would like your help. Your job is to find the indices of three stars that would form a triangle that satisfies all the conditions. It is guaranteed that there is no line such that all stars lie on that line. It can be proven that if the previous condition is satisfied, there exists a solution to this problem.[SOURCE CODE]def dis(x,y):\n    return x**2+y**2\n\ndef check(a,b,c):\n    if (c[1]-b[1])*(b[0]-a[0])==(b[1]-a[1])*(c[0]-b[0]):\n        return True\n    return False\n\ndef solve():\n    n=input()\n    points=[]\n    dist=[]\n    for x in xrange(n):\n        points.append(map(int,raw_input().split()))\n        dist.append(dis(points[-1][0],points[-1][1]))\n    indices = sorted(range(n), key = dist.__getitem__)\n    for y in xrange(2,n):\n        if check(points[indices[0]],points[indices[1]],points[indices[y]]):\n            continue\n        else:\n            print indices[0]+1,indices[1]+1,indices[y]+1\n            break\n\nsolve()","tags":["geometry"],"src_uid":"0d3ac2472990aba36abee156069b1088"}
{"text_full":"[DESCRIPTION]Vasya owns three big integers — $$$a, l, r$$$. Let's define a partition of $$$x$$$ such a sequence of strings $$$s_1, s_2, \\dots, s_k$$$ that $$$s_1 + s_2 + \\dots + s_k = x$$$, where $$$+$$$ is a concatanation of strings. $$$s_i$$$ is the $$$i$$$-th element of the partition. For example, number $$$12345$$$ has the following partitions: [\"1\", \"2\", \"3\", \"4\", \"5\"], [\"123\", \"4\", \"5\"], [\"1\", \"2345\"], [\"12345\"] and lots of others.Let's call some partition of $$$a$$$ beautiful if each of its elements contains no leading zeros.Vasya want to know the number of beautiful partitions of number $$$a$$$, which has each of $$$s_i$$$ satisfy the condition $$$l \\le s_i \\le r$$$. Note that the comparison is the integer comparison, not the string one.Help Vasya to count the amount of partitions of number $$$a$$$ such that they match all the given requirements. The result can be rather big, so print it modulo $$$998244353$$$.[SOURCE CODE]def kmp(pat,text,t):\n    s=pat+\"?\"+text;\n    #z[i] es el tamaño del prefijo mas largo de, formado por una subcadena s[i:...]\n    z=[0 for i in range(len(s))]\n    L=0;R=0;n=len(s);\n    for i in range(1,len(s)):\n        if i>R:\n            L=R=i\n            while R<n and s[R-L]==s[R]:\n                R+=1\n            z[i]=R-L\n            R-=1\n        elif z[i-L]+i<=R:\n            z[i]=z[i-L]\n        else:\n            L=i\n            while R<n and s[R-L]==s[R]:\n                R+=1\n            z[i]=R-L\n            R-=1\n    for i in range(len(pat)+1,len(z)):\n        dp[t][i-(len(pat)+1)]=z[i]%len(pat)\nfrom sys import stdin\nmod=998244353\na=stdin.readline().strip()\nl=stdin.readline().strip()\nr=stdin.readline().strip()\nx=len(l)\ny=len(r)\nn=len(a)\ndp=[[0 for i in range(len(a))]for j in range(2)]\nans=[0 for i in range(len(a)+1)]\nans[-1]=1\nkmp(l,a,0)\nkmp(r,a,1)\nauxl=x-1\nauxr=y-1\nacum=[0 for i in range(n+2)]\nacum[n]=1\nfor i in range(n-1,-1,-1):\n    if a[i]==\"0\":\n        if l[0]==\"0\":\n            ans[i]=ans[i+1]\n        acum[i]=(acum[i+1]+ans[i])%mod\n        continue\n    if auxl>=n:\n        acum[i]=(acum[i+1]+ans[i])%mod\n        continue\n    if auxl!=auxr:\n        if (auxl+i)<n and a[dp[0][i]+i]>=l[dp[0][i]]:\n            ans[i]=(ans[i]+ans[i+auxl+1])%mod\n        if (auxr+i)<n and a[dp[1][i]+i]<=r[dp[1][i]]:\n            ans[i]=(ans[i]+ans[i+auxr+1])%mod\n    else:\n        if (auxl+i)<n and a[dp[0][i]+i]>=l[dp[0][i]] and a[dp[1][i]+i]<=r[dp[1][i]]:\n            ans[i]=(ans[i]+ans[i+auxl+1])%mod\n    lim1=auxl+i+2\n    lim2=min(auxr+i+1,n+1)\n    if lim1<lim2:\n        ans[i]=(ans[i]+acum[lim1]-acum[lim2])%mod\n    acum[i]=(acum[i+1]+ans[i])%mod\nprint(ans[0]%mod)","tags":["strings"],"src_uid":"0d212ea4fc9f03fdd682289fca9b517e"}
{"text_full":"[DESCRIPTION]On a random day, Neko found $$$n$$$ treasure chests and $$$m$$$ keys. The $$$i$$$-th chest has an integer $$$a_i$$$ written on it and the $$$j$$$-th key has an integer $$$b_j$$$ on it. Neko knows those chests contain the powerful mysterious green Grapes, thus Neko wants to open as many treasure chests as possible.The $$$j$$$-th key can be used to unlock the $$$i$$$-th chest if and only if the sum of the key number and the chest number is an odd number. Formally, $$$a_i + b_j \\equiv 1 \\pmod{2}$$$. One key can be used to open at most one chest, and one chest can be opened at most once.Find the maximum number of chests Neko can open.[SOURCE CODE]n,m=map(int,input().split())\na=list(map(int,input().split()))\nb=list(map(int,input().split()))\nae=0\nao=0\nbe=0\nbo=0\nfor ele in a:\n    if ele%2:\n        ao+=1\n    else:\n        ae+=1\nfor i in b:\n    if i%2:\n        bo+=1\n    else:\n        be+=1\nprint(min(ao,be)+min(ae,bo))","tags":["math"],"src_uid":"bc532d5c9845940b5f59485394187bf6"}
{"text_full":"[DESCRIPTION]Some dwarves that are finishing the StUDY (State University for Dwarven Youngsters) Bachelor courses, have been told \"no genome, no degree\". That means that all dwarves should write a thesis on genome. Dwarven genome is far from simple. It is represented by a string that consists of lowercase Latin letters.Dwarf Misha has already chosen the subject for his thesis: determining by two dwarven genomes, whether they belong to the same race. Two dwarves belong to the same race if we can swap two characters in the first dwarf's genome and get the second dwarf's genome as a result. Help Dwarf Misha and find out whether two gnomes belong to the same race or not.[SOURCE CODE]p=input()\np=p.replace('',' ')\np=p.split()\nq=input()\nq=q.replace('',' ')\nq=q.split()\nif len(p)==len(q):\n    c=0\n    l=[]\n    for i in range(len(p)):\n        if p[i]!=q[i]:\n            c+=1\n            l.append(p[i])\n            l.append(q[i])\n    if c==2:\n        d=0\n        for i in range(4):\n            if l.count(l[i])!=2:\n                d=1\n                break\n        if d==0:\n            print('YES')\n        else:\n            print('NO')\n    else:\n        print('NO')\nelse:\n    print('NO')","tags":["strings"],"src_uid":"c659bdeda1c1da08cfc7f71367222332"}
